ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"arm_fir_sparse_q31.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c"
  20              		.section	.text.arm_fir_sparse_q31,"ax",%progbits
  21              		.align	1
  22              		.global	arm_fir_sparse_q31
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	arm_fir_sparse_q31:
  28              	.LVL0:
  29              	.LFB139:
   1:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** /* ----------------------------------------------------------------------
   2:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Project:      CMSIS DSP Library
   3:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Title:        arm_fir_sparse_q31.c
   4:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Description:  Q31 sparse FIR filter processing function
   5:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
   6:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * $Date:        27. January 2017
   7:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * $Revision:    V.1.5.1
   8:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
   9:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Target Processor: Cortex-M cores
  10:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * -------------------------------------------------------------------- */
  11:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** /*
  12:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
  14:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * SPDX-License-Identifier: Apache-2.0
  15:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
  16:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * not use this file except in compliance with the License.
  18:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * You may obtain a copy of the License at
  19:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
  20:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
  22:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * Unless required by applicable law or agreed to in writing, software
  23:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * See the License for the specific language governing permissions and
  26:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * limitations under the License.
  27:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  */
  28:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  29:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** #include "arm_math.h"
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 2


  30:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  31:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  32:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** /**
  33:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @addtogroup FIR_Sparse
  34:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @{
  35:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  */
  36:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  37:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** /**
  38:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @brief Processing function for the Q31 sparse FIR filter.
  39:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @param[in]  *S          points to an instance of the Q31 sparse FIR structure.
  40:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @param[in]  *pSrc       points to the block of input data.
  41:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @param[out] *pDst       points to the block of output data
  42:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
  43:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @param[in]  blockSize   number of input samples to process per call.
  44:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * @return none.
  45:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  *
  46:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * <b>Scaling and Overflow Behavior:</b>
  47:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * \par
  48:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * The function is implemented using an internal 32-bit accumulator.
  49:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * The 1.31 x 1.31 multiplications are truncated to 2.30 format.
  50:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * This leads to loss of precision on the intermediate multiplications and provides only a single g
  51:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * If the accumulator result overflows, it wraps around rather than saturate.
  52:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  * In order to avoid overflows the input signal or coefficients must be scaled down by log2(numTaps
  53:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****  */
  54:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  55:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** void arm_fir_sparse_q31(
  56:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   arm_fir_sparse_instance_q31 * S,
  57:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t * pSrc,
  58:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t * pDst,
  59:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t * pScratchIn,
  60:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   uint32_t blockSize)
  61:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** {
  30              		.loc 1 61 1 view -0
  31              		.cfi_startproc
  32              		@ args = 4, pretend = 0, frame = 32
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		.loc 1 61 1 is_stmt 0 view .LVU1
  35 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 36
  38              		.cfi_offset 4, -36
  39              		.cfi_offset 5, -32
  40              		.cfi_offset 6, -28
  41              		.cfi_offset 7, -24
  42              		.cfi_offset 8, -20
  43              		.cfi_offset 9, -16
  44              		.cfi_offset 10, -12
  45              		.cfi_offset 11, -8
  46              		.cfi_offset 14, -4
  47 0004 89B0     		sub	sp, sp, #36
  48              	.LCFI1:
  49              		.cfi_def_cfa_offset 72
  50 0006 0646     		mov	r6, r0
  51 0008 0390     		str	r0, [sp, #12]
  52 000a DDF848B0 		ldr	fp, [sp, #72]
  62:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  63:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t *pState = S->pState;                     /* State pointer */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 3


  53              		.loc 1 63 3 is_stmt 1 view .LVU2
  54              		.loc 1 63 10 is_stmt 0 view .LVU3
  55 000e 4568     		ldr	r5, [r0, #4]
  56              	.LVL1:
  64:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
  57              		.loc 1 64 3 is_stmt 1 view .LVU4
  58              		.loc 1 64 10 is_stmt 0 view .LVU5
  59 0010 D0F80880 		ldr	r8, [r0, #8]
  60              	.LVL2:
  65:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t *px;                                     /* Scratch buffer pointer */
  61              		.loc 1 65 3 is_stmt 1 view .LVU6
  66:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t *py = pState;                            /* Temporary pointers for state buffer */
  62              		.loc 1 66 3 view .LVU7
  67:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */
  63              		.loc 1 67 3 view .LVU8
  68:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t *pOut;                                   /* Destination pointer */
  64              		.loc 1 68 3 view .LVU9
  69:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q63_t out;                                     /* Temporary output variable */
  65              		.loc 1 69 3 view .LVU10
  70:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the n
  66              		.loc 1 70 3 view .LVU11
  67              		.loc 1 70 12 is_stmt 0 view .LVU12
  68 0014 D0F810A0 		ldr	r10, [r0, #16]
  69              	.LVL3:
  71:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
  70              		.loc 1 71 3 is_stmt 1 view .LVU13
  71              		.loc 1 71 25 is_stmt 0 view .LVU14
  72 0018 8489     		ldrh	r4, [r0, #12]
  73              		.loc 1 71 12 view .LVU15
  74 001a 5C44     		add	r4, r4, fp
  75              	.LVL4:
  72:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   uint16_t numTaps = S->numTaps;                 /* Filter order */
  76              		.loc 1 72 3 is_stmt 1 view .LVU16
  77              		.loc 1 72 12 is_stmt 0 view .LVU17
  78 001c B0F800C0 		ldrh	ip, [r0]
  79              	.LVL5:
  73:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   int32_t readIndex;                             /* Read index of the state buffer */
  80              		.loc 1 73 3 is_stmt 1 view .LVU18
  74:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   uint32_t tapCnt, blkCnt;                       /* loop counters */
  81              		.loc 1 74 3 view .LVU19
  75:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t coeff = *pCoeffs++;                      /* Read the first coefficient value */
  82              		.loc 1 75 3 view .LVU20
  83              		.loc 1 75 9 is_stmt 0 view .LVU21
  84 0020 D8F80000 		ldr	r0, [r8]
  85              	.LVL6:
  76:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   q31_t in;
  86              		.loc 1 76 3 is_stmt 1 view .LVU22
  77:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  78:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  79:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* BlockSize of Input samples are copied into the state buffer */
  80:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* StateIndex points to the starting position to write in the state buffer */
  81:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,
  87              		.loc 1 81 3 view .LVU23
  88              	.LBB10:
  89              	.LBI10:
  90              		.file 2 "DSP/Inc/arm_math.h"
   1:DSP/Inc/arm_math.h **** /******************************************************************************
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 4


   2:DSP/Inc/arm_math.h ****  * @file     arm_math.h
   3:DSP/Inc/arm_math.h ****  * @brief    Public header file for CMSIS DSP LibraryU
   4:DSP/Inc/arm_math.h ****  * @version  V1.5.3
   5:DSP/Inc/arm_math.h ****  * @date     10. January 2018
   6:DSP/Inc/arm_math.h ****  ******************************************************************************/
   7:DSP/Inc/arm_math.h **** /*
   8:DSP/Inc/arm_math.h ****  * Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved.
   9:DSP/Inc/arm_math.h ****  *
  10:DSP/Inc/arm_math.h ****  * SPDX-License-Identifier: Apache-2.0
  11:DSP/Inc/arm_math.h ****  *
  12:DSP/Inc/arm_math.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:DSP/Inc/arm_math.h ****  * not use this file except in compliance with the License.
  14:DSP/Inc/arm_math.h ****  * You may obtain a copy of the License at
  15:DSP/Inc/arm_math.h ****  *
  16:DSP/Inc/arm_math.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:DSP/Inc/arm_math.h ****  *
  18:DSP/Inc/arm_math.h ****  * Unless required by applicable law or agreed to in writing, software
  19:DSP/Inc/arm_math.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:DSP/Inc/arm_math.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:DSP/Inc/arm_math.h ****  * See the License for the specific language governing permissions and
  22:DSP/Inc/arm_math.h ****  * limitations under the License.
  23:DSP/Inc/arm_math.h ****  */
  24:DSP/Inc/arm_math.h **** 
  25:DSP/Inc/arm_math.h **** /**
  26:DSP/Inc/arm_math.h ****    \mainpage CMSIS DSP Software Library
  27:DSP/Inc/arm_math.h ****    *
  28:DSP/Inc/arm_math.h ****    * Introduction
  29:DSP/Inc/arm_math.h ****    * ------------
  30:DSP/Inc/arm_math.h ****    *
  31:DSP/Inc/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  32:DSP/Inc/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
  33:DSP/Inc/arm_math.h ****    *
  34:DSP/Inc/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  35:DSP/Inc/arm_math.h ****    * - Basic math functions
  36:DSP/Inc/arm_math.h ****    * - Fast math functions
  37:DSP/Inc/arm_math.h ****    * - Complex math functions
  38:DSP/Inc/arm_math.h ****    * - Filters
  39:DSP/Inc/arm_math.h ****    * - Matrix functions
  40:DSP/Inc/arm_math.h ****    * - Transforms
  41:DSP/Inc/arm_math.h ****    * - Motor control functions
  42:DSP/Inc/arm_math.h ****    * - Statistical functions
  43:DSP/Inc/arm_math.h ****    * - Support functions
  44:DSP/Inc/arm_math.h ****    * - Interpolation functions
  45:DSP/Inc/arm_math.h ****    *
  46:DSP/Inc/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  47:DSP/Inc/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  48:DSP/Inc/arm_math.h ****    *
  49:DSP/Inc/arm_math.h ****    * Using the Library
  50:DSP/Inc/arm_math.h ****    * ------------
  51:DSP/Inc/arm_math.h ****    *
  52:DSP/Inc/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  53:DSP/Inc/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Cortex-M7, Little endian, Double Precision Floating Point Unit)
  54:DSP/Inc/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Cortex-M7, Big endian, Double Precision Floating Point Unit)
  55:DSP/Inc/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Cortex-M7, Little endian, Single Precision Floating Point Unit)
  56:DSP/Inc/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Cortex-M7, Big endian and Single Precision Floating Point Unit on
  57:DSP/Inc/arm_math.h ****    * - arm_cortexM7l_math.lib (Cortex-M7, Little endian)
  58:DSP/Inc/arm_math.h ****    * - arm_cortexM7b_math.lib (Cortex-M7, Big endian)
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 5


  59:DSP/Inc/arm_math.h ****    * - arm_cortexM4lf_math.lib (Cortex-M4, Little endian, Floating Point Unit)
  60:DSP/Inc/arm_math.h ****    * - arm_cortexM4bf_math.lib (Cortex-M4, Big endian, Floating Point Unit)
  61:DSP/Inc/arm_math.h ****    * - arm_cortexM4l_math.lib (Cortex-M4, Little endian)
  62:DSP/Inc/arm_math.h ****    * - arm_cortexM4b_math.lib (Cortex-M4, Big endian)
  63:DSP/Inc/arm_math.h ****    * - arm_cortexM3l_math.lib (Cortex-M3, Little endian)
  64:DSP/Inc/arm_math.h ****    * - arm_cortexM3b_math.lib (Cortex-M3, Big endian)
  65:DSP/Inc/arm_math.h ****    * - arm_cortexM0l_math.lib (Cortex-M0 / Cortex-M0+, Little endian)
  66:DSP/Inc/arm_math.h ****    * - arm_cortexM0b_math.lib (Cortex-M0 / Cortex-M0+, Big endian)
  67:DSP/Inc/arm_math.h ****    * - arm_ARMv8MBLl_math.lib (Armv8-M Baseline, Little endian)
  68:DSP/Inc/arm_math.h ****    * - arm_ARMv8MMLl_math.lib (Armv8-M Mainline, Little endian)
  69:DSP/Inc/arm_math.h ****    * - arm_ARMv8MMLlfsp_math.lib (Armv8-M Mainline, Little endian, Single Precision Floating Point 
  70:DSP/Inc/arm_math.h ****    * - arm_ARMv8MMLld_math.lib (Armv8-M Mainline, Little endian, DSP instructions)
  71:DSP/Inc/arm_math.h ****    * - arm_ARMv8MMLldfsp_math.lib (Armv8-M Mainline, Little endian, DSP instructions, Single Precis
  72:DSP/Inc/arm_math.h ****    *
  73:DSP/Inc/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  74:DSP/Inc/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  75:DSP/Inc/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endi
  76:DSP/Inc/arm_math.h ****    * Define the appropriate preprocessor macro ARM_MATH_CM7 or ARM_MATH_CM4 or ARM_MATH_CM3 or
  77:DSP/Inc/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  78:DSP/Inc/arm_math.h ****    * For Armv8-M cores define preprocessor macro ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
  79:DSP/Inc/arm_math.h ****    * Set preprocessor macro __DSP_PRESENT if Armv8-M Mainline core supports DSP instructions.
  80:DSP/Inc/arm_math.h ****    * 
  81:DSP/Inc/arm_math.h ****    *
  82:DSP/Inc/arm_math.h ****    * Examples
  83:DSP/Inc/arm_math.h ****    * --------
  84:DSP/Inc/arm_math.h ****    *
  85:DSP/Inc/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  86:DSP/Inc/arm_math.h ****    *
  87:DSP/Inc/arm_math.h ****    * Toolchain Support
  88:DSP/Inc/arm_math.h ****    * ------------
  89:DSP/Inc/arm_math.h ****    *
  90:DSP/Inc/arm_math.h ****    * The library has been developed and tested with MDK version 5.14.0.0
  91:DSP/Inc/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
  92:DSP/Inc/arm_math.h ****    *
  93:DSP/Inc/arm_math.h ****    * Building the Library
  94:DSP/Inc/arm_math.h ****    * ------------
  95:DSP/Inc/arm_math.h ****    *
  96:DSP/Inc/arm_math.h ****    * The library installer contains a project file to rebuild libraries on MDK toolchain in the <co
  97:DSP/Inc/arm_math.h ****    * - arm_cortexM_math.uvprojx
  98:DSP/Inc/arm_math.h ****    *
  99:DSP/Inc/arm_math.h ****    *
 100:DSP/Inc/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 101:DSP/Inc/arm_math.h ****    *
 102:DSP/Inc/arm_math.h ****    * Preprocessor Macros
 103:DSP/Inc/arm_math.h ****    * ------------
 104:DSP/Inc/arm_math.h ****    *
 105:DSP/Inc/arm_math.h ****    * Each library project have different preprocessor macros.
 106:DSP/Inc/arm_math.h ****    *
 107:DSP/Inc/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 108:DSP/Inc/arm_math.h ****    *
 109:DSP/Inc/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 110:DSP/Inc/arm_math.h ****    *
 111:DSP/Inc/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 112:DSP/Inc/arm_math.h ****    *
 113:DSP/Inc/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 114:DSP/Inc/arm_math.h ****    *
 115:DSP/Inc/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 6


 116:DSP/Inc/arm_math.h ****    *
 117:DSP/Inc/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
 118:DSP/Inc/arm_math.h ****    *
 119:DSP/Inc/arm_math.h ****    * - ARM_MATH_ROUNDING:
 120:DSP/Inc/arm_math.h ****    *
 121:DSP/Inc/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 122:DSP/Inc/arm_math.h ****    *
 123:DSP/Inc/arm_math.h ****    * - ARM_MATH_CMx:
 124:DSP/Inc/arm_math.h ****    *
 125:DSP/Inc/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 126:DSP/Inc/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 127:DSP/Inc/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 128:DSP/Inc/arm_math.h ****    *
 129:DSP/Inc/arm_math.h ****    * - ARM_MATH_ARMV8MxL:
 130:DSP/Inc/arm_math.h ****    *
 131:DSP/Inc/arm_math.h ****    * Define macro ARM_MATH_ARMV8MBL for building the library on Armv8-M Baseline target, ARM_MATH_A
 132:DSP/Inc/arm_math.h ****    * on Armv8-M Mainline target.
 133:DSP/Inc/arm_math.h ****    *
 134:DSP/Inc/arm_math.h ****    * - __FPU_PRESENT:
 135:DSP/Inc/arm_math.h ****    *
 136:DSP/Inc/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 137:DSP/Inc/arm_math.h ****    *
 138:DSP/Inc/arm_math.h ****    * - __DSP_PRESENT:
 139:DSP/Inc/arm_math.h ****    *
 140:DSP/Inc/arm_math.h ****    * Initialize macro __DSP_PRESENT = 1 when Armv8-M Mainline core supports DSP instructions.
 141:DSP/Inc/arm_math.h ****    *
 142:DSP/Inc/arm_math.h ****    * <hr>
 143:DSP/Inc/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 144:DSP/Inc/arm_math.h ****    * -----------------------------
 145:DSP/Inc/arm_math.h ****    *
 146:DSP/Inc/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
 147:DSP/Inc/arm_math.h ****    * |File/Folder                   |Content                                                       
 148:DSP/Inc/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
 149:DSP/Inc/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 150:DSP/Inc/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 151:DSP/Inc/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 152:DSP/Inc/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 153:DSP/Inc/arm_math.h ****    *
 154:DSP/Inc/arm_math.h ****    * <hr>
 155:DSP/Inc/arm_math.h ****    * Revision History of CMSIS-DSP
 156:DSP/Inc/arm_math.h ****    * ------------
 157:DSP/Inc/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 158:DSP/Inc/arm_math.h ****    *
 159:DSP/Inc/arm_math.h ****    * Copyright Notice
 160:DSP/Inc/arm_math.h ****    * ------------
 161:DSP/Inc/arm_math.h ****    *
 162:DSP/Inc/arm_math.h ****    * Copyright (C) 2010-2015 Arm Limited. All rights reserved.
 163:DSP/Inc/arm_math.h ****    */
 164:DSP/Inc/arm_math.h **** 
 165:DSP/Inc/arm_math.h **** 
 166:DSP/Inc/arm_math.h **** /**
 167:DSP/Inc/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 168:DSP/Inc/arm_math.h ****  */
 169:DSP/Inc/arm_math.h **** 
 170:DSP/Inc/arm_math.h **** /**
 171:DSP/Inc/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 172:DSP/Inc/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 7


 173:DSP/Inc/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
 174:DSP/Inc/arm_math.h ****  * operate on individual values and not arrays.
 175:DSP/Inc/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 176:DSP/Inc/arm_math.h ****  *
 177:DSP/Inc/arm_math.h ****  */
 178:DSP/Inc/arm_math.h **** 
 179:DSP/Inc/arm_math.h **** /**
 180:DSP/Inc/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 181:DSP/Inc/arm_math.h ****  * This set of functions operates on complex data vectors.
 182:DSP/Inc/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 183:DSP/Inc/arm_math.h ****  * (real, imag, real, imag, ...).
 184:DSP/Inc/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 185:DSP/Inc/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 186:DSP/Inc/arm_math.h ****  * real values.
 187:DSP/Inc/arm_math.h ****  */
 188:DSP/Inc/arm_math.h **** 
 189:DSP/Inc/arm_math.h **** /**
 190:DSP/Inc/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 191:DSP/Inc/arm_math.h ****  */
 192:DSP/Inc/arm_math.h **** 
 193:DSP/Inc/arm_math.h **** /**
 194:DSP/Inc/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 195:DSP/Inc/arm_math.h ****  *
 196:DSP/Inc/arm_math.h ****  * This set of functions provides basic matrix math operations.
 197:DSP/Inc/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 198:DSP/Inc/arm_math.h ****  * the type
 199:DSP/Inc/arm_math.h ****  * definition for the floating-point matrix structure is shown
 200:DSP/Inc/arm_math.h ****  * below:
 201:DSP/Inc/arm_math.h ****  * <pre>
 202:DSP/Inc/arm_math.h ****  *     typedef struct
 203:DSP/Inc/arm_math.h ****  *     {
 204:DSP/Inc/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 205:DSP/Inc/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
 206:DSP/Inc/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 207:DSP/Inc/arm_math.h ****  *     } arm_matrix_instance_f32;
 208:DSP/Inc/arm_math.h ****  * </pre>
 209:DSP/Inc/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 210:DSP/Inc/arm_math.h ****  *
 211:DSP/Inc/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 212:DSP/Inc/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 213:DSP/Inc/arm_math.h ****  * and the values are arranged in row order.  That is, the
 214:DSP/Inc/arm_math.h ****  * matrix element (i, j) is stored at:
 215:DSP/Inc/arm_math.h ****  * <pre>
 216:DSP/Inc/arm_math.h ****  *     pData[i*numCols + j]
 217:DSP/Inc/arm_math.h ****  * </pre>
 218:DSP/Inc/arm_math.h ****  *
 219:DSP/Inc/arm_math.h ****  * \par Init Functions
 220:DSP/Inc/arm_math.h ****  * There is an associated initialization function for each type of matrix
 221:DSP/Inc/arm_math.h ****  * data structure.
 222:DSP/Inc/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 223:DSP/Inc/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 224:DSP/Inc/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 225:DSP/Inc/arm_math.h ****  *
 226:DSP/Inc/arm_math.h ****  * \par
 227:DSP/Inc/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 228:DSP/Inc/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 229:DSP/Inc/arm_math.h ****  * To place the instance structure in a const data
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 8


 230:DSP/Inc/arm_math.h ****  * section, manually initialize the data structure.  For example:
 231:DSP/Inc/arm_math.h ****  * <pre>
 232:DSP/Inc/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 233:DSP/Inc/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 234:DSP/Inc/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 235:DSP/Inc/arm_math.h ****  * </pre>
 236:DSP/Inc/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 237:DSP/Inc/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 238:DSP/Inc/arm_math.h ****  * data array.
 239:DSP/Inc/arm_math.h ****  *
 240:DSP/Inc/arm_math.h ****  * \par Size Checking
 241:DSP/Inc/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 242:DSP/Inc/arm_math.h ****  * output matrices. For example, the matrix addition function verifies that the
 243:DSP/Inc/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
 244:DSP/Inc/arm_math.h ****  * columns. If the size check fails the functions return:
 245:DSP/Inc/arm_math.h ****  * <pre>
 246:DSP/Inc/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 247:DSP/Inc/arm_math.h ****  * </pre>
 248:DSP/Inc/arm_math.h ****  * Otherwise the functions return
 249:DSP/Inc/arm_math.h ****  * <pre>
 250:DSP/Inc/arm_math.h ****  *     ARM_MATH_SUCCESS
 251:DSP/Inc/arm_math.h ****  * </pre>
 252:DSP/Inc/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 253:DSP/Inc/arm_math.h ****  * The matrix size checking is enabled via the \#define
 254:DSP/Inc/arm_math.h ****  * <pre>
 255:DSP/Inc/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 256:DSP/Inc/arm_math.h ****  * </pre>
 257:DSP/Inc/arm_math.h ****  * within the library project settings.  By default this macro is defined
 258:DSP/Inc/arm_math.h ****  * and size checking is enabled. By changing the project settings and
 259:DSP/Inc/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 260:DSP/Inc/arm_math.h ****  * run a bit faster. With size checking disabled the functions always
 261:DSP/Inc/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 262:DSP/Inc/arm_math.h ****  */
 263:DSP/Inc/arm_math.h **** 
 264:DSP/Inc/arm_math.h **** /**
 265:DSP/Inc/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 266:DSP/Inc/arm_math.h ****  */
 267:DSP/Inc/arm_math.h **** 
 268:DSP/Inc/arm_math.h **** /**
 269:DSP/Inc/arm_math.h ****  * @defgroup groupController Controller Functions
 270:DSP/Inc/arm_math.h ****  */
 271:DSP/Inc/arm_math.h **** 
 272:DSP/Inc/arm_math.h **** /**
 273:DSP/Inc/arm_math.h ****  * @defgroup groupStats Statistics Functions
 274:DSP/Inc/arm_math.h ****  */
 275:DSP/Inc/arm_math.h **** /**
 276:DSP/Inc/arm_math.h ****  * @defgroup groupSupport Support Functions
 277:DSP/Inc/arm_math.h ****  */
 278:DSP/Inc/arm_math.h **** 
 279:DSP/Inc/arm_math.h **** /**
 280:DSP/Inc/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 281:DSP/Inc/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 282:DSP/Inc/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 283:DSP/Inc/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 284:DSP/Inc/arm_math.h ****  */
 285:DSP/Inc/arm_math.h **** 
 286:DSP/Inc/arm_math.h **** /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 9


 287:DSP/Inc/arm_math.h ****  * @defgroup groupExamples Examples
 288:DSP/Inc/arm_math.h ****  */
 289:DSP/Inc/arm_math.h **** #ifndef _ARM_MATH_H
 290:DSP/Inc/arm_math.h **** #define _ARM_MATH_H
 291:DSP/Inc/arm_math.h **** 
 292:DSP/Inc/arm_math.h **** /* Compiler specific diagnostic adjustment */
 293:DSP/Inc/arm_math.h **** #if   defined ( __CC_ARM )
 294:DSP/Inc/arm_math.h **** 
 295:DSP/Inc/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 296:DSP/Inc/arm_math.h **** 
 297:DSP/Inc/arm_math.h **** #elif defined ( __GNUC__ )
 298:DSP/Inc/arm_math.h **** #pragma GCC diagnostic push
 299:DSP/Inc/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
 300:DSP/Inc/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 301:DSP/Inc/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 302:DSP/Inc/arm_math.h **** 
 303:DSP/Inc/arm_math.h **** #elif defined ( __ICCARM__ )
 304:DSP/Inc/arm_math.h **** 
 305:DSP/Inc/arm_math.h **** #elif defined ( __TI_ARM__ )
 306:DSP/Inc/arm_math.h **** 
 307:DSP/Inc/arm_math.h **** #elif defined ( __CSMC__ )
 308:DSP/Inc/arm_math.h **** 
 309:DSP/Inc/arm_math.h **** #elif defined ( __TASKING__ )
 310:DSP/Inc/arm_math.h **** 
 311:DSP/Inc/arm_math.h **** #else
 312:DSP/Inc/arm_math.h ****   #error Unknown compiler
 313:DSP/Inc/arm_math.h **** #endif
 314:DSP/Inc/arm_math.h **** 
 315:DSP/Inc/arm_math.h **** 
 316:DSP/Inc/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
 317:DSP/Inc/arm_math.h **** 
 318:DSP/Inc/arm_math.h **** #if defined(ARM_MATH_CM7)
 319:DSP/Inc/arm_math.h ****   #include "core_cm7.h"
 320:DSP/Inc/arm_math.h ****   #define ARM_MATH_DSP
 321:DSP/Inc/arm_math.h **** #elif defined (ARM_MATH_CM4)
 322:DSP/Inc/arm_math.h ****   #include "core_cm4.h"
 323:DSP/Inc/arm_math.h ****   #define ARM_MATH_DSP
 324:DSP/Inc/arm_math.h **** #elif defined (ARM_MATH_CM3)
 325:DSP/Inc/arm_math.h ****   #include "core_cm3.h"
 326:DSP/Inc/arm_math.h **** #elif defined (ARM_MATH_CM0)
 327:DSP/Inc/arm_math.h ****   #include "core_cm0.h"
 328:DSP/Inc/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 329:DSP/Inc/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 330:DSP/Inc/arm_math.h ****   #include "core_cm0plus.h"
 331:DSP/Inc/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 332:DSP/Inc/arm_math.h **** #elif defined (ARM_MATH_ARMV8MBL)
 333:DSP/Inc/arm_math.h ****   #include "core_armv8mbl.h"
 334:DSP/Inc/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 335:DSP/Inc/arm_math.h **** #elif defined (ARM_MATH_ARMV8MML)
 336:DSP/Inc/arm_math.h ****   #include "core_armv8mml.h"
 337:DSP/Inc/arm_math.h ****   #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
 338:DSP/Inc/arm_math.h ****     #define ARM_MATH_DSP
 339:DSP/Inc/arm_math.h ****   #endif
 340:DSP/Inc/arm_math.h **** #else
 341:DSP/Inc/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 342:DSP/Inc/arm_math.h **** #endif
 343:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 10


 344:DSP/Inc/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 345:DSP/Inc/arm_math.h **** #include "string.h"
 346:DSP/Inc/arm_math.h **** #include "math.h"
 347:DSP/Inc/arm_math.h **** #ifdef   __cplusplus
 348:DSP/Inc/arm_math.h **** extern "C"
 349:DSP/Inc/arm_math.h **** {
 350:DSP/Inc/arm_math.h **** #endif
 351:DSP/Inc/arm_math.h **** 
 352:DSP/Inc/arm_math.h **** 
 353:DSP/Inc/arm_math.h ****   /**
 354:DSP/Inc/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 355:DSP/Inc/arm_math.h ****    */
 356:DSP/Inc/arm_math.h **** 
 357:DSP/Inc/arm_math.h **** #define DELTA_Q31          (0x100)
 358:DSP/Inc/arm_math.h **** #define DELTA_Q15          0x5
 359:DSP/Inc/arm_math.h **** #define INDEX_MASK         0x0000003F
 360:DSP/Inc/arm_math.h **** #ifndef PI
 361:DSP/Inc/arm_math.h ****   #define PI               3.14159265358979f
 362:DSP/Inc/arm_math.h **** #endif
 363:DSP/Inc/arm_math.h **** 
 364:DSP/Inc/arm_math.h ****   /**
 365:DSP/Inc/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 366:DSP/Inc/arm_math.h ****    */
 367:DSP/Inc/arm_math.h **** 
 368:DSP/Inc/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
 369:DSP/Inc/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 370:DSP/Inc/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 371:DSP/Inc/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 372:DSP/Inc/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 373:DSP/Inc/arm_math.h **** #define TABLE_SPACING_Q15     0x80
 374:DSP/Inc/arm_math.h **** 
 375:DSP/Inc/arm_math.h ****   /**
 376:DSP/Inc/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 377:DSP/Inc/arm_math.h ****    */
 378:DSP/Inc/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 379:DSP/Inc/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 380:DSP/Inc/arm_math.h **** #define INPUT_SPACING         0xB60B61
 381:DSP/Inc/arm_math.h **** 
 382:DSP/Inc/arm_math.h ****   /**
 383:DSP/Inc/arm_math.h ****    * @brief Macro for Unaligned Support
 384:DSP/Inc/arm_math.h ****    */
 385:DSP/Inc/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 386:DSP/Inc/arm_math.h ****     #define ALIGN4
 387:DSP/Inc/arm_math.h **** #else
 388:DSP/Inc/arm_math.h ****   #if defined  (__GNUC__)
 389:DSP/Inc/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 390:DSP/Inc/arm_math.h ****   #else
 391:DSP/Inc/arm_math.h ****     #define ALIGN4 __align(4)
 392:DSP/Inc/arm_math.h ****   #endif
 393:DSP/Inc/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 394:DSP/Inc/arm_math.h **** 
 395:DSP/Inc/arm_math.h ****   /**
 396:DSP/Inc/arm_math.h ****    * @brief Error status returned by some functions in the library.
 397:DSP/Inc/arm_math.h ****    */
 398:DSP/Inc/arm_math.h **** 
 399:DSP/Inc/arm_math.h ****   typedef enum
 400:DSP/Inc/arm_math.h ****   {
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 11


 401:DSP/Inc/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
 402:DSP/Inc/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 403:DSP/Inc/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 404:DSP/Inc/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 405:DSP/Inc/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 406:DSP/Inc/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 407:DSP/Inc/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 408:DSP/Inc/arm_math.h ****   } arm_status;
 409:DSP/Inc/arm_math.h **** 
 410:DSP/Inc/arm_math.h ****   /**
 411:DSP/Inc/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 412:DSP/Inc/arm_math.h ****    */
 413:DSP/Inc/arm_math.h ****   typedef int8_t q7_t;
 414:DSP/Inc/arm_math.h **** 
 415:DSP/Inc/arm_math.h ****   /**
 416:DSP/Inc/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 417:DSP/Inc/arm_math.h ****    */
 418:DSP/Inc/arm_math.h ****   typedef int16_t q15_t;
 419:DSP/Inc/arm_math.h **** 
 420:DSP/Inc/arm_math.h ****   /**
 421:DSP/Inc/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 422:DSP/Inc/arm_math.h ****    */
 423:DSP/Inc/arm_math.h ****   typedef int32_t q31_t;
 424:DSP/Inc/arm_math.h **** 
 425:DSP/Inc/arm_math.h ****   /**
 426:DSP/Inc/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 427:DSP/Inc/arm_math.h ****    */
 428:DSP/Inc/arm_math.h ****   typedef int64_t q63_t;
 429:DSP/Inc/arm_math.h **** 
 430:DSP/Inc/arm_math.h ****   /**
 431:DSP/Inc/arm_math.h ****    * @brief 32-bit floating-point type definition.
 432:DSP/Inc/arm_math.h ****    */
 433:DSP/Inc/arm_math.h ****   typedef float float32_t;
 434:DSP/Inc/arm_math.h **** 
 435:DSP/Inc/arm_math.h ****   /**
 436:DSP/Inc/arm_math.h ****    * @brief 64-bit floating-point type definition.
 437:DSP/Inc/arm_math.h ****    */
 438:DSP/Inc/arm_math.h ****   typedef double float64_t;
 439:DSP/Inc/arm_math.h **** 
 440:DSP/Inc/arm_math.h ****   /**
 441:DSP/Inc/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 442:DSP/Inc/arm_math.h ****    */
 443:DSP/Inc/arm_math.h **** #if   defined ( __CC_ARM )
 444:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 445:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 446:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 447:DSP/Inc/arm_math.h **** 
 448:DSP/Inc/arm_math.h **** #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 449:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 450:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 451:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 452:DSP/Inc/arm_math.h **** 
 453:DSP/Inc/arm_math.h **** #elif defined ( __GNUC__ )
 454:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 455:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 456:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE __attribute__((always_inline))
 457:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 12


 458:DSP/Inc/arm_math.h **** #elif defined ( __ICCARM__ )
 459:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 460:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED
 461:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE
 462:DSP/Inc/arm_math.h **** 
 463:DSP/Inc/arm_math.h **** #elif defined ( __TI_ARM__ )
 464:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 465:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 466:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE
 467:DSP/Inc/arm_math.h **** 
 468:DSP/Inc/arm_math.h **** #elif defined ( __CSMC__ )
 469:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 470:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED
 471:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE
 472:DSP/Inc/arm_math.h **** 
 473:DSP/Inc/arm_math.h **** #elif defined ( __TASKING__ )
 474:DSP/Inc/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
 475:DSP/Inc/arm_math.h ****   #define CMSIS_UNUSED
 476:DSP/Inc/arm_math.h ****   #define CMSIS_INLINE
 477:DSP/Inc/arm_math.h **** 
 478:DSP/Inc/arm_math.h **** #else
 479:DSP/Inc/arm_math.h ****   #error Unknown compiler
 480:DSP/Inc/arm_math.h **** #endif
 481:DSP/Inc/arm_math.h **** 
 482:DSP/Inc/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
 483:DSP/Inc/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 484:DSP/Inc/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 485:DSP/Inc/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 486:DSP/Inc/arm_math.h **** 
 487:DSP/Inc/arm_math.h **** #if !defined (ARM_MATH_DSP)
 488:DSP/Inc/arm_math.h ****   /**
 489:DSP/Inc/arm_math.h ****    * @brief definition to pack two 16 bit values.
 490:DSP/Inc/arm_math.h ****    */
 491:DSP/Inc/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
 492:DSP/Inc/arm_math.h ****                                     (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 493:DSP/Inc/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
 494:DSP/Inc/arm_math.h ****                                     (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 495:DSP/Inc/arm_math.h **** 
 496:DSP/Inc/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
 497:DSP/Inc/arm_math.h **** 
 498:DSP/Inc/arm_math.h ****    /**
 499:DSP/Inc/arm_math.h ****    * @brief definition to pack four 8 bit values.
 500:DSP/Inc/arm_math.h ****    */
 501:DSP/Inc/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 502:DSP/Inc/arm_math.h **** 
 503:DSP/Inc/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 504:DSP/Inc/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 505:DSP/Inc/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 506:DSP/Inc/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 507:DSP/Inc/arm_math.h **** #else
 508:DSP/Inc/arm_math.h **** 
 509:DSP/Inc/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 510:DSP/Inc/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 511:DSP/Inc/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 512:DSP/Inc/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 513:DSP/Inc/arm_math.h **** 
 514:DSP/Inc/arm_math.h **** #endif
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 13


 515:DSP/Inc/arm_math.h **** 
 516:DSP/Inc/arm_math.h **** 
 517:DSP/Inc/arm_math.h ****   /**
 518:DSP/Inc/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 519:DSP/Inc/arm_math.h ****    */
 520:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
 521:DSP/Inc/arm_math.h ****   q63_t x)
 522:DSP/Inc/arm_math.h ****   {
 523:DSP/Inc/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 524:DSP/Inc/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
 525:DSP/Inc/arm_math.h ****   }
 526:DSP/Inc/arm_math.h **** 
 527:DSP/Inc/arm_math.h ****   /**
 528:DSP/Inc/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 529:DSP/Inc/arm_math.h ****    */
 530:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
 531:DSP/Inc/arm_math.h ****   q63_t x)
 532:DSP/Inc/arm_math.h ****   {
 533:DSP/Inc/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 534:DSP/Inc/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 535:DSP/Inc/arm_math.h ****   }
 536:DSP/Inc/arm_math.h **** 
 537:DSP/Inc/arm_math.h ****   /**
 538:DSP/Inc/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 539:DSP/Inc/arm_math.h ****    */
 540:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
 541:DSP/Inc/arm_math.h ****   q31_t x)
 542:DSP/Inc/arm_math.h ****   {
 543:DSP/Inc/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 544:DSP/Inc/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 545:DSP/Inc/arm_math.h ****   }
 546:DSP/Inc/arm_math.h **** 
 547:DSP/Inc/arm_math.h ****   /**
 548:DSP/Inc/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 549:DSP/Inc/arm_math.h ****    */
 550:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
 551:DSP/Inc/arm_math.h ****   q31_t x)
 552:DSP/Inc/arm_math.h ****   {
 553:DSP/Inc/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 554:DSP/Inc/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 555:DSP/Inc/arm_math.h ****   }
 556:DSP/Inc/arm_math.h **** 
 557:DSP/Inc/arm_math.h ****   /**
 558:DSP/Inc/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 559:DSP/Inc/arm_math.h ****    */
 560:DSP/Inc/arm_math.h **** 
 561:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
 562:DSP/Inc/arm_math.h ****   q63_t x,
 563:DSP/Inc/arm_math.h ****   q31_t y)
 564:DSP/Inc/arm_math.h ****   {
 565:DSP/Inc/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 566:DSP/Inc/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 567:DSP/Inc/arm_math.h ****   }
 568:DSP/Inc/arm_math.h **** 
 569:DSP/Inc/arm_math.h ****   /**
 570:DSP/Inc/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 571:DSP/Inc/arm_math.h ****    */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 14


 572:DSP/Inc/arm_math.h **** 
 573:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
 574:DSP/Inc/arm_math.h ****   q31_t in,
 575:DSP/Inc/arm_math.h ****   q31_t * dst,
 576:DSP/Inc/arm_math.h ****   q31_t * pRecipTable)
 577:DSP/Inc/arm_math.h ****   {
 578:DSP/Inc/arm_math.h ****     q31_t out;
 579:DSP/Inc/arm_math.h ****     uint32_t tempVal;
 580:DSP/Inc/arm_math.h ****     uint32_t index, i;
 581:DSP/Inc/arm_math.h ****     uint32_t signBits;
 582:DSP/Inc/arm_math.h **** 
 583:DSP/Inc/arm_math.h ****     if (in > 0)
 584:DSP/Inc/arm_math.h ****     {
 585:DSP/Inc/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 586:DSP/Inc/arm_math.h ****     }
 587:DSP/Inc/arm_math.h ****     else
 588:DSP/Inc/arm_math.h ****     {
 589:DSP/Inc/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 590:DSP/Inc/arm_math.h ****     }
 591:DSP/Inc/arm_math.h **** 
 592:DSP/Inc/arm_math.h ****     /* Convert input sample to 1.31 format */
 593:DSP/Inc/arm_math.h ****     in = (in << signBits);
 594:DSP/Inc/arm_math.h **** 
 595:DSP/Inc/arm_math.h ****     /* calculation of index for initial approximated Val */
 596:DSP/Inc/arm_math.h ****     index = (uint32_t)(in >> 24);
 597:DSP/Inc/arm_math.h ****     index = (index & INDEX_MASK);
 598:DSP/Inc/arm_math.h **** 
 599:DSP/Inc/arm_math.h ****     /* 1.31 with exp 1 */
 600:DSP/Inc/arm_math.h ****     out = pRecipTable[index];
 601:DSP/Inc/arm_math.h **** 
 602:DSP/Inc/arm_math.h ****     /* calculation of reciprocal value */
 603:DSP/Inc/arm_math.h ****     /* running approximation for two iterations */
 604:DSP/Inc/arm_math.h ****     for (i = 0U; i < 2U; i++)
 605:DSP/Inc/arm_math.h ****     {
 606:DSP/Inc/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 607:DSP/Inc/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 608:DSP/Inc/arm_math.h ****       /*      1.31 with exp 1 */
 609:DSP/Inc/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 610:DSP/Inc/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 611:DSP/Inc/arm_math.h ****     }
 612:DSP/Inc/arm_math.h **** 
 613:DSP/Inc/arm_math.h ****     /* write output */
 614:DSP/Inc/arm_math.h ****     *dst = out;
 615:DSP/Inc/arm_math.h **** 
 616:DSP/Inc/arm_math.h ****     /* return num of signbits of out = 1/in value */
 617:DSP/Inc/arm_math.h ****     return (signBits + 1U);
 618:DSP/Inc/arm_math.h ****   }
 619:DSP/Inc/arm_math.h **** 
 620:DSP/Inc/arm_math.h **** 
 621:DSP/Inc/arm_math.h ****   /**
 622:DSP/Inc/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 623:DSP/Inc/arm_math.h ****    */
 624:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
 625:DSP/Inc/arm_math.h ****   q15_t in,
 626:DSP/Inc/arm_math.h ****   q15_t * dst,
 627:DSP/Inc/arm_math.h ****   q15_t * pRecipTable)
 628:DSP/Inc/arm_math.h ****   {
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 15


 629:DSP/Inc/arm_math.h ****     q15_t out = 0;
 630:DSP/Inc/arm_math.h ****     uint32_t tempVal = 0;
 631:DSP/Inc/arm_math.h ****     uint32_t index = 0, i = 0;
 632:DSP/Inc/arm_math.h ****     uint32_t signBits = 0;
 633:DSP/Inc/arm_math.h **** 
 634:DSP/Inc/arm_math.h ****     if (in > 0)
 635:DSP/Inc/arm_math.h ****     {
 636:DSP/Inc/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 637:DSP/Inc/arm_math.h ****     }
 638:DSP/Inc/arm_math.h ****     else
 639:DSP/Inc/arm_math.h ****     {
 640:DSP/Inc/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 641:DSP/Inc/arm_math.h ****     }
 642:DSP/Inc/arm_math.h **** 
 643:DSP/Inc/arm_math.h ****     /* Convert input sample to 1.15 format */
 644:DSP/Inc/arm_math.h ****     in = (in << signBits);
 645:DSP/Inc/arm_math.h **** 
 646:DSP/Inc/arm_math.h ****     /* calculation of index for initial approximated Val */
 647:DSP/Inc/arm_math.h ****     index = (uint32_t)(in >>  8);
 648:DSP/Inc/arm_math.h ****     index = (index & INDEX_MASK);
 649:DSP/Inc/arm_math.h **** 
 650:DSP/Inc/arm_math.h ****     /*      1.15 with exp 1  */
 651:DSP/Inc/arm_math.h ****     out = pRecipTable[index];
 652:DSP/Inc/arm_math.h **** 
 653:DSP/Inc/arm_math.h ****     /* calculation of reciprocal value */
 654:DSP/Inc/arm_math.h ****     /* running approximation for two iterations */
 655:DSP/Inc/arm_math.h ****     for (i = 0U; i < 2U; i++)
 656:DSP/Inc/arm_math.h ****     {
 657:DSP/Inc/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 658:DSP/Inc/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
 659:DSP/Inc/arm_math.h ****       /*      1.15 with exp 1 */
 660:DSP/Inc/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 661:DSP/Inc/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 662:DSP/Inc/arm_math.h ****     }
 663:DSP/Inc/arm_math.h **** 
 664:DSP/Inc/arm_math.h ****     /* write output */
 665:DSP/Inc/arm_math.h ****     *dst = out;
 666:DSP/Inc/arm_math.h **** 
 667:DSP/Inc/arm_math.h ****     /* return num of signbits of out = 1/in value */
 668:DSP/Inc/arm_math.h ****     return (signBits + 1);
 669:DSP/Inc/arm_math.h ****   }
 670:DSP/Inc/arm_math.h **** 
 671:DSP/Inc/arm_math.h **** 
 672:DSP/Inc/arm_math.h **** /*
 673:DSP/Inc/arm_math.h ****  * @brief C custom defined intrinsic function for M3 and M0 processors
 674:DSP/Inc/arm_math.h ****  */
 675:DSP/Inc/arm_math.h **** #if !defined (ARM_MATH_DSP)
 676:DSP/Inc/arm_math.h **** 
 677:DSP/Inc/arm_math.h ****   /*
 678:DSP/Inc/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 679:DSP/Inc/arm_math.h ****    */
 680:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
 681:DSP/Inc/arm_math.h ****   uint32_t x,
 682:DSP/Inc/arm_math.h ****   uint32_t y)
 683:DSP/Inc/arm_math.h ****   {
 684:DSP/Inc/arm_math.h ****     q31_t r, s, t, u;
 685:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 16


 686:DSP/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 687:DSP/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 688:DSP/Inc/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 689:DSP/Inc/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 690:DSP/Inc/arm_math.h **** 
 691:DSP/Inc/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 692:DSP/Inc/arm_math.h ****   }
 693:DSP/Inc/arm_math.h **** 
 694:DSP/Inc/arm_math.h **** 
 695:DSP/Inc/arm_math.h ****   /*
 696:DSP/Inc/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 697:DSP/Inc/arm_math.h ****    */
 698:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
 699:DSP/Inc/arm_math.h ****   uint32_t x,
 700:DSP/Inc/arm_math.h ****   uint32_t y)
 701:DSP/Inc/arm_math.h ****   {
 702:DSP/Inc/arm_math.h ****     q31_t r, s, t, u;
 703:DSP/Inc/arm_math.h **** 
 704:DSP/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 705:DSP/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 706:DSP/Inc/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 707:DSP/Inc/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 708:DSP/Inc/arm_math.h **** 
 709:DSP/Inc/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 710:DSP/Inc/arm_math.h ****   }
 711:DSP/Inc/arm_math.h **** 
 712:DSP/Inc/arm_math.h **** 
 713:DSP/Inc/arm_math.h ****   /*
 714:DSP/Inc/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 715:DSP/Inc/arm_math.h ****    */
 716:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
 717:DSP/Inc/arm_math.h ****   uint32_t x,
 718:DSP/Inc/arm_math.h ****   uint32_t y)
 719:DSP/Inc/arm_math.h ****   {
 720:DSP/Inc/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
 721:DSP/Inc/arm_math.h ****     q31_t r = 0, s = 0;
 722:DSP/Inc/arm_math.h **** 
 723:DSP/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 724:DSP/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 725:DSP/Inc/arm_math.h **** 
 726:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 727:DSP/Inc/arm_math.h ****   }
 728:DSP/Inc/arm_math.h **** 
 729:DSP/Inc/arm_math.h **** 
 730:DSP/Inc/arm_math.h ****   /*
 731:DSP/Inc/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 732:DSP/Inc/arm_math.h ****    */
 733:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
 734:DSP/Inc/arm_math.h ****   uint32_t x,
 735:DSP/Inc/arm_math.h ****   uint32_t y)
 736:DSP/Inc/arm_math.h ****   {
 737:DSP/Inc/arm_math.h ****     q31_t r, s;
 738:DSP/Inc/arm_math.h **** 
 739:DSP/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 740:DSP/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 741:DSP/Inc/arm_math.h **** 
 742:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 17


 743:DSP/Inc/arm_math.h ****   }
 744:DSP/Inc/arm_math.h **** 
 745:DSP/Inc/arm_math.h **** 
 746:DSP/Inc/arm_math.h ****   /*
 747:DSP/Inc/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
 748:DSP/Inc/arm_math.h ****    */
 749:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
 750:DSP/Inc/arm_math.h ****   uint32_t x,
 751:DSP/Inc/arm_math.h ****   uint32_t y)
 752:DSP/Inc/arm_math.h ****   {
 753:DSP/Inc/arm_math.h ****     q31_t r, s;
 754:DSP/Inc/arm_math.h **** 
 755:DSP/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 756:DSP/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 757:DSP/Inc/arm_math.h **** 
 758:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 759:DSP/Inc/arm_math.h ****   }
 760:DSP/Inc/arm_math.h **** 
 761:DSP/Inc/arm_math.h **** 
 762:DSP/Inc/arm_math.h ****   /*
 763:DSP/Inc/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 764:DSP/Inc/arm_math.h ****    */
 765:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
 766:DSP/Inc/arm_math.h ****   uint32_t x,
 767:DSP/Inc/arm_math.h ****   uint32_t y)
 768:DSP/Inc/arm_math.h ****   {
 769:DSP/Inc/arm_math.h ****     q31_t r, s;
 770:DSP/Inc/arm_math.h **** 
 771:DSP/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 772:DSP/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 773:DSP/Inc/arm_math.h **** 
 774:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 775:DSP/Inc/arm_math.h ****   }
 776:DSP/Inc/arm_math.h **** 
 777:DSP/Inc/arm_math.h **** 
 778:DSP/Inc/arm_math.h ****   /*
 779:DSP/Inc/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 780:DSP/Inc/arm_math.h ****    */
 781:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
 782:DSP/Inc/arm_math.h ****   uint32_t x,
 783:DSP/Inc/arm_math.h ****   uint32_t y)
 784:DSP/Inc/arm_math.h ****   {
 785:DSP/Inc/arm_math.h ****     q31_t r, s;
 786:DSP/Inc/arm_math.h **** 
 787:DSP/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 788:DSP/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 789:DSP/Inc/arm_math.h **** 
 790:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 791:DSP/Inc/arm_math.h ****   }
 792:DSP/Inc/arm_math.h **** 
 793:DSP/Inc/arm_math.h **** 
 794:DSP/Inc/arm_math.h ****   /*
 795:DSP/Inc/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 796:DSP/Inc/arm_math.h ****    */
 797:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
 798:DSP/Inc/arm_math.h ****   uint32_t x,
 799:DSP/Inc/arm_math.h ****   uint32_t y)
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 18


 800:DSP/Inc/arm_math.h ****   {
 801:DSP/Inc/arm_math.h ****     q31_t r, s;
 802:DSP/Inc/arm_math.h **** 
 803:DSP/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 804:DSP/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 805:DSP/Inc/arm_math.h **** 
 806:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 807:DSP/Inc/arm_math.h ****   }
 808:DSP/Inc/arm_math.h **** 
 809:DSP/Inc/arm_math.h **** 
 810:DSP/Inc/arm_math.h ****   /*
 811:DSP/Inc/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 812:DSP/Inc/arm_math.h ****    */
 813:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
 814:DSP/Inc/arm_math.h ****   uint32_t x,
 815:DSP/Inc/arm_math.h ****   uint32_t y)
 816:DSP/Inc/arm_math.h ****   {
 817:DSP/Inc/arm_math.h ****     q31_t r, s;
 818:DSP/Inc/arm_math.h **** 
 819:DSP/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 820:DSP/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 821:DSP/Inc/arm_math.h **** 
 822:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 823:DSP/Inc/arm_math.h ****   }
 824:DSP/Inc/arm_math.h **** 
 825:DSP/Inc/arm_math.h **** 
 826:DSP/Inc/arm_math.h ****   /*
 827:DSP/Inc/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 828:DSP/Inc/arm_math.h ****    */
 829:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
 830:DSP/Inc/arm_math.h ****   uint32_t x,
 831:DSP/Inc/arm_math.h ****   uint32_t y)
 832:DSP/Inc/arm_math.h ****   {
 833:DSP/Inc/arm_math.h ****     q31_t r, s;
 834:DSP/Inc/arm_math.h **** 
 835:DSP/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 836:DSP/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 837:DSP/Inc/arm_math.h **** 
 838:DSP/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 839:DSP/Inc/arm_math.h ****   }
 840:DSP/Inc/arm_math.h **** 
 841:DSP/Inc/arm_math.h **** 
 842:DSP/Inc/arm_math.h ****   /*
 843:DSP/Inc/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 844:DSP/Inc/arm_math.h ****    */
 845:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
 846:DSP/Inc/arm_math.h ****   uint32_t x,
 847:DSP/Inc/arm_math.h ****   uint32_t y)
 848:DSP/Inc/arm_math.h ****   {
 849:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 850:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 851:DSP/Inc/arm_math.h ****   }
 852:DSP/Inc/arm_math.h **** 
 853:DSP/Inc/arm_math.h ****   /*
 854:DSP/Inc/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 855:DSP/Inc/arm_math.h ****    */
 856:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 19


 857:DSP/Inc/arm_math.h ****   uint32_t x,
 858:DSP/Inc/arm_math.h ****   uint32_t y)
 859:DSP/Inc/arm_math.h ****   {
 860:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 861:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 862:DSP/Inc/arm_math.h ****   }
 863:DSP/Inc/arm_math.h **** 
 864:DSP/Inc/arm_math.h **** 
 865:DSP/Inc/arm_math.h ****   /*
 866:DSP/Inc/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 867:DSP/Inc/arm_math.h ****    */
 868:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
 869:DSP/Inc/arm_math.h ****   int32_t x,
 870:DSP/Inc/arm_math.h ****   int32_t y)
 871:DSP/Inc/arm_math.h ****   {
 872:DSP/Inc/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 873:DSP/Inc/arm_math.h ****   }
 874:DSP/Inc/arm_math.h **** 
 875:DSP/Inc/arm_math.h **** 
 876:DSP/Inc/arm_math.h ****   /*
 877:DSP/Inc/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 878:DSP/Inc/arm_math.h ****    */
 879:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
 880:DSP/Inc/arm_math.h ****   int32_t x,
 881:DSP/Inc/arm_math.h ****   int32_t y)
 882:DSP/Inc/arm_math.h ****   {
 883:DSP/Inc/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 884:DSP/Inc/arm_math.h ****   }
 885:DSP/Inc/arm_math.h **** 
 886:DSP/Inc/arm_math.h **** 
 887:DSP/Inc/arm_math.h ****   /*
 888:DSP/Inc/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 889:DSP/Inc/arm_math.h ****    */
 890:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
 891:DSP/Inc/arm_math.h ****   uint32_t x,
 892:DSP/Inc/arm_math.h ****   uint32_t y,
 893:DSP/Inc/arm_math.h ****   uint32_t sum)
 894:DSP/Inc/arm_math.h ****   {
 895:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 896:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 897:DSP/Inc/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 898:DSP/Inc/arm_math.h ****   }
 899:DSP/Inc/arm_math.h **** 
 900:DSP/Inc/arm_math.h **** 
 901:DSP/Inc/arm_math.h ****   /*
 902:DSP/Inc/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 903:DSP/Inc/arm_math.h ****    */
 904:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
 905:DSP/Inc/arm_math.h ****   uint32_t x,
 906:DSP/Inc/arm_math.h ****   uint32_t y,
 907:DSP/Inc/arm_math.h ****   uint32_t sum)
 908:DSP/Inc/arm_math.h ****   {
 909:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 910:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 911:DSP/Inc/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 912:DSP/Inc/arm_math.h ****   }
 913:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 20


 914:DSP/Inc/arm_math.h **** 
 915:DSP/Inc/arm_math.h ****   /*
 916:DSP/Inc/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 917:DSP/Inc/arm_math.h ****    */
 918:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
 919:DSP/Inc/arm_math.h ****   uint32_t x,
 920:DSP/Inc/arm_math.h ****   uint32_t y,
 921:DSP/Inc/arm_math.h ****   uint32_t sum)
 922:DSP/Inc/arm_math.h ****   {
 923:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 924:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 925:DSP/Inc/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 926:DSP/Inc/arm_math.h ****   }
 927:DSP/Inc/arm_math.h **** 
 928:DSP/Inc/arm_math.h **** 
 929:DSP/Inc/arm_math.h ****   /*
 930:DSP/Inc/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 931:DSP/Inc/arm_math.h ****    */
 932:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
 933:DSP/Inc/arm_math.h ****   uint32_t x,
 934:DSP/Inc/arm_math.h ****   uint32_t y,
 935:DSP/Inc/arm_math.h ****   uint64_t sum)
 936:DSP/Inc/arm_math.h ****   {
 937:DSP/Inc/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 938:DSP/Inc/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 939:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 940:DSP/Inc/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 941:DSP/Inc/arm_math.h ****   }
 942:DSP/Inc/arm_math.h **** 
 943:DSP/Inc/arm_math.h **** 
 944:DSP/Inc/arm_math.h ****   /*
 945:DSP/Inc/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
 946:DSP/Inc/arm_math.h ****    */
 947:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
 948:DSP/Inc/arm_math.h ****   uint32_t x,
 949:DSP/Inc/arm_math.h ****   uint32_t y,
 950:DSP/Inc/arm_math.h ****   uint64_t sum)
 951:DSP/Inc/arm_math.h ****   {
 952:DSP/Inc/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
 953:DSP/Inc/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 954:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 955:DSP/Inc/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 956:DSP/Inc/arm_math.h ****   }
 957:DSP/Inc/arm_math.h **** 
 958:DSP/Inc/arm_math.h **** 
 959:DSP/Inc/arm_math.h ****   /*
 960:DSP/Inc/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
 961:DSP/Inc/arm_math.h ****    */
 962:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
 963:DSP/Inc/arm_math.h ****   uint32_t x,
 964:DSP/Inc/arm_math.h ****   uint32_t y)
 965:DSP/Inc/arm_math.h ****   {
 966:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 967:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
 968:DSP/Inc/arm_math.h ****   }
 969:DSP/Inc/arm_math.h **** 
 970:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 21


 971:DSP/Inc/arm_math.h ****   /*
 972:DSP/Inc/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
 973:DSP/Inc/arm_math.h ****    */
 974:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
 975:DSP/Inc/arm_math.h ****   uint32_t x,
 976:DSP/Inc/arm_math.h ****   uint32_t y)
 977:DSP/Inc/arm_math.h ****   {
 978:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
 979:DSP/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
 980:DSP/Inc/arm_math.h ****   }
 981:DSP/Inc/arm_math.h **** 
 982:DSP/Inc/arm_math.h **** 
 983:DSP/Inc/arm_math.h ****   /*
 984:DSP/Inc/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
 985:DSP/Inc/arm_math.h ****    */
 986:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
 987:DSP/Inc/arm_math.h ****   uint32_t x)
 988:DSP/Inc/arm_math.h ****   {
 989:DSP/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
 990:DSP/Inc/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
 991:DSP/Inc/arm_math.h ****   }
 992:DSP/Inc/arm_math.h **** 
 993:DSP/Inc/arm_math.h ****   /*
 994:DSP/Inc/arm_math.h ****    * @brief C custom defined SMMLA for M3 and M0 processors
 995:DSP/Inc/arm_math.h ****    */
 996:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
 997:DSP/Inc/arm_math.h ****   int32_t x,
 998:DSP/Inc/arm_math.h ****   int32_t y,
 999:DSP/Inc/arm_math.h ****   int32_t sum)
1000:DSP/Inc/arm_math.h ****   {
1001:DSP/Inc/arm_math.h ****     return (sum + (int32_t) (((int64_t) x * y) >> 32));
1002:DSP/Inc/arm_math.h ****   }
1003:DSP/Inc/arm_math.h **** 
1004:DSP/Inc/arm_math.h **** #endif /* !defined (ARM_MATH_DSP) */
1005:DSP/Inc/arm_math.h **** 
1006:DSP/Inc/arm_math.h **** 
1007:DSP/Inc/arm_math.h ****   /**
1008:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1009:DSP/Inc/arm_math.h ****    */
1010:DSP/Inc/arm_math.h ****   typedef struct
1011:DSP/Inc/arm_math.h ****   {
1012:DSP/Inc/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1013:DSP/Inc/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
1014:DSP/Inc/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1015:DSP/Inc/arm_math.h ****   } arm_fir_instance_q7;
1016:DSP/Inc/arm_math.h **** 
1017:DSP/Inc/arm_math.h ****   /**
1018:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
1019:DSP/Inc/arm_math.h ****    */
1020:DSP/Inc/arm_math.h ****   typedef struct
1021:DSP/Inc/arm_math.h ****   {
1022:DSP/Inc/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1023:DSP/Inc/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1024:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1025:DSP/Inc/arm_math.h ****   } arm_fir_instance_q15;
1026:DSP/Inc/arm_math.h **** 
1027:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 22


1028:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1029:DSP/Inc/arm_math.h ****    */
1030:DSP/Inc/arm_math.h ****   typedef struct
1031:DSP/Inc/arm_math.h ****   {
1032:DSP/Inc/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1033:DSP/Inc/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1034:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1035:DSP/Inc/arm_math.h ****   } arm_fir_instance_q31;
1036:DSP/Inc/arm_math.h **** 
1037:DSP/Inc/arm_math.h ****   /**
1038:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1039:DSP/Inc/arm_math.h ****    */
1040:DSP/Inc/arm_math.h ****   typedef struct
1041:DSP/Inc/arm_math.h ****   {
1042:DSP/Inc/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1043:DSP/Inc/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1044:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1045:DSP/Inc/arm_math.h ****   } arm_fir_instance_f32;
1046:DSP/Inc/arm_math.h **** 
1047:DSP/Inc/arm_math.h **** 
1048:DSP/Inc/arm_math.h ****   /**
1049:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1050:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1051:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1052:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1053:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1054:DSP/Inc/arm_math.h ****    */
1055:DSP/Inc/arm_math.h ****   void arm_fir_q7(
1056:DSP/Inc/arm_math.h ****   const arm_fir_instance_q7 * S,
1057:DSP/Inc/arm_math.h ****   q7_t * pSrc,
1058:DSP/Inc/arm_math.h ****   q7_t * pDst,
1059:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1060:DSP/Inc/arm_math.h **** 
1061:DSP/Inc/arm_math.h **** 
1062:DSP/Inc/arm_math.h ****   /**
1063:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
1064:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1065:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1066:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1067:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1068:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1069:DSP/Inc/arm_math.h ****    */
1070:DSP/Inc/arm_math.h ****   void arm_fir_init_q7(
1071:DSP/Inc/arm_math.h ****   arm_fir_instance_q7 * S,
1072:DSP/Inc/arm_math.h ****   uint16_t numTaps,
1073:DSP/Inc/arm_math.h ****   q7_t * pCoeffs,
1074:DSP/Inc/arm_math.h ****   q7_t * pState,
1075:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1076:DSP/Inc/arm_math.h **** 
1077:DSP/Inc/arm_math.h **** 
1078:DSP/Inc/arm_math.h ****   /**
1079:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1080:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1081:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1082:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1083:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1084:DSP/Inc/arm_math.h ****    */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 23


1085:DSP/Inc/arm_math.h ****   void arm_fir_q15(
1086:DSP/Inc/arm_math.h ****   const arm_fir_instance_q15 * S,
1087:DSP/Inc/arm_math.h ****   q15_t * pSrc,
1088:DSP/Inc/arm_math.h ****   q15_t * pDst,
1089:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1090:DSP/Inc/arm_math.h **** 
1091:DSP/Inc/arm_math.h **** 
1092:DSP/Inc/arm_math.h ****   /**
1093:DSP/Inc/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1094:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1095:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1096:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1097:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1098:DSP/Inc/arm_math.h ****    */
1099:DSP/Inc/arm_math.h ****   void arm_fir_fast_q15(
1100:DSP/Inc/arm_math.h ****   const arm_fir_instance_q15 * S,
1101:DSP/Inc/arm_math.h ****   q15_t * pSrc,
1102:DSP/Inc/arm_math.h ****   q15_t * pDst,
1103:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1104:DSP/Inc/arm_math.h **** 
1105:DSP/Inc/arm_math.h **** 
1106:DSP/Inc/arm_math.h ****   /**
1107:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1108:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1109:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1110:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1111:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1112:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1113:DSP/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1114:DSP/Inc/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1115:DSP/Inc/arm_math.h ****    */
1116:DSP/Inc/arm_math.h ****   arm_status arm_fir_init_q15(
1117:DSP/Inc/arm_math.h ****   arm_fir_instance_q15 * S,
1118:DSP/Inc/arm_math.h ****   uint16_t numTaps,
1119:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
1120:DSP/Inc/arm_math.h ****   q15_t * pState,
1121:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1122:DSP/Inc/arm_math.h **** 
1123:DSP/Inc/arm_math.h **** 
1124:DSP/Inc/arm_math.h ****   /**
1125:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1126:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1127:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1128:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1129:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1130:DSP/Inc/arm_math.h ****    */
1131:DSP/Inc/arm_math.h ****   void arm_fir_q31(
1132:DSP/Inc/arm_math.h ****   const arm_fir_instance_q31 * S,
1133:DSP/Inc/arm_math.h ****   q31_t * pSrc,
1134:DSP/Inc/arm_math.h ****   q31_t * pDst,
1135:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1136:DSP/Inc/arm_math.h **** 
1137:DSP/Inc/arm_math.h **** 
1138:DSP/Inc/arm_math.h ****   /**
1139:DSP/Inc/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1140:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1141:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 24


1142:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1143:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1144:DSP/Inc/arm_math.h ****    */
1145:DSP/Inc/arm_math.h ****   void arm_fir_fast_q31(
1146:DSP/Inc/arm_math.h ****   const arm_fir_instance_q31 * S,
1147:DSP/Inc/arm_math.h ****   q31_t * pSrc,
1148:DSP/Inc/arm_math.h ****   q31_t * pDst,
1149:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1150:DSP/Inc/arm_math.h **** 
1151:DSP/Inc/arm_math.h **** 
1152:DSP/Inc/arm_math.h ****   /**
1153:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1154:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1155:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1156:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1157:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1158:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1159:DSP/Inc/arm_math.h ****    */
1160:DSP/Inc/arm_math.h ****   void arm_fir_init_q31(
1161:DSP/Inc/arm_math.h ****   arm_fir_instance_q31 * S,
1162:DSP/Inc/arm_math.h ****   uint16_t numTaps,
1163:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
1164:DSP/Inc/arm_math.h ****   q31_t * pState,
1165:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1166:DSP/Inc/arm_math.h **** 
1167:DSP/Inc/arm_math.h **** 
1168:DSP/Inc/arm_math.h ****   /**
1169:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1170:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1171:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1172:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1173:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1174:DSP/Inc/arm_math.h ****    */
1175:DSP/Inc/arm_math.h ****   void arm_fir_f32(
1176:DSP/Inc/arm_math.h ****   const arm_fir_instance_f32 * S,
1177:DSP/Inc/arm_math.h ****   float32_t * pSrc,
1178:DSP/Inc/arm_math.h ****   float32_t * pDst,
1179:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1180:DSP/Inc/arm_math.h **** 
1181:DSP/Inc/arm_math.h **** 
1182:DSP/Inc/arm_math.h ****   /**
1183:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1184:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
1185:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1186:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1187:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1188:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1189:DSP/Inc/arm_math.h ****    */
1190:DSP/Inc/arm_math.h ****   void arm_fir_init_f32(
1191:DSP/Inc/arm_math.h ****   arm_fir_instance_f32 * S,
1192:DSP/Inc/arm_math.h ****   uint16_t numTaps,
1193:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
1194:DSP/Inc/arm_math.h ****   float32_t * pState,
1195:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1196:DSP/Inc/arm_math.h **** 
1197:DSP/Inc/arm_math.h **** 
1198:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 25


1199:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1200:DSP/Inc/arm_math.h ****    */
1201:DSP/Inc/arm_math.h ****   typedef struct
1202:DSP/Inc/arm_math.h ****   {
1203:DSP/Inc/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1204:DSP/Inc/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1205:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1206:DSP/Inc/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
1207:DSP/Inc/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1208:DSP/Inc/arm_math.h **** 
1209:DSP/Inc/arm_math.h ****   /**
1210:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1211:DSP/Inc/arm_math.h ****    */
1212:DSP/Inc/arm_math.h ****   typedef struct
1213:DSP/Inc/arm_math.h ****   {
1214:DSP/Inc/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1215:DSP/Inc/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1216:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1217:DSP/Inc/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1218:DSP/Inc/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1219:DSP/Inc/arm_math.h **** 
1220:DSP/Inc/arm_math.h ****   /**
1221:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1222:DSP/Inc/arm_math.h ****    */
1223:DSP/Inc/arm_math.h ****   typedef struct
1224:DSP/Inc/arm_math.h ****   {
1225:DSP/Inc/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1226:DSP/Inc/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1227:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1228:DSP/Inc/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1229:DSP/Inc/arm_math.h **** 
1230:DSP/Inc/arm_math.h **** 
1231:DSP/Inc/arm_math.h ****   /**
1232:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1233:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1234:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1235:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1236:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1237:DSP/Inc/arm_math.h ****    */
1238:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1239:DSP/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1240:DSP/Inc/arm_math.h ****   q15_t * pSrc,
1241:DSP/Inc/arm_math.h ****   q15_t * pDst,
1242:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1243:DSP/Inc/arm_math.h **** 
1244:DSP/Inc/arm_math.h **** 
1245:DSP/Inc/arm_math.h ****   /**
1246:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
1247:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1248:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1249:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1250:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1251:DSP/Inc/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1252:DSP/Inc/arm_math.h ****    */
1253:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1254:DSP/Inc/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1255:DSP/Inc/arm_math.h ****   uint8_t numStages,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 26


1256:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
1257:DSP/Inc/arm_math.h ****   q15_t * pState,
1258:DSP/Inc/arm_math.h ****   int8_t postShift);
1259:DSP/Inc/arm_math.h **** 
1260:DSP/Inc/arm_math.h **** 
1261:DSP/Inc/arm_math.h ****   /**
1262:DSP/Inc/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
1263:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1264:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1265:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1266:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1267:DSP/Inc/arm_math.h ****    */
1268:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1269:DSP/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1270:DSP/Inc/arm_math.h ****   q15_t * pSrc,
1271:DSP/Inc/arm_math.h ****   q15_t * pDst,
1272:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1273:DSP/Inc/arm_math.h **** 
1274:DSP/Inc/arm_math.h **** 
1275:DSP/Inc/arm_math.h ****   /**
1276:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1277:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1278:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1279:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1280:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1281:DSP/Inc/arm_math.h ****    */
1282:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1283:DSP/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1284:DSP/Inc/arm_math.h ****   q31_t * pSrc,
1285:DSP/Inc/arm_math.h ****   q31_t * pDst,
1286:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1287:DSP/Inc/arm_math.h **** 
1288:DSP/Inc/arm_math.h **** 
1289:DSP/Inc/arm_math.h ****   /**
1290:DSP/Inc/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
1291:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1292:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1293:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1294:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1295:DSP/Inc/arm_math.h ****    */
1296:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1297:DSP/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1298:DSP/Inc/arm_math.h ****   q31_t * pSrc,
1299:DSP/Inc/arm_math.h ****   q31_t * pDst,
1300:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1301:DSP/Inc/arm_math.h **** 
1302:DSP/Inc/arm_math.h **** 
1303:DSP/Inc/arm_math.h ****   /**
1304:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1305:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1306:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1307:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1308:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1309:DSP/Inc/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1310:DSP/Inc/arm_math.h ****    */
1311:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1312:DSP/Inc/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 27


1313:DSP/Inc/arm_math.h ****   uint8_t numStages,
1314:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
1315:DSP/Inc/arm_math.h ****   q31_t * pState,
1316:DSP/Inc/arm_math.h ****   int8_t postShift);
1317:DSP/Inc/arm_math.h **** 
1318:DSP/Inc/arm_math.h **** 
1319:DSP/Inc/arm_math.h ****   /**
1320:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
1321:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1322:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1323:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1324:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1325:DSP/Inc/arm_math.h ****    */
1326:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1327:DSP/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1328:DSP/Inc/arm_math.h ****   float32_t * pSrc,
1329:DSP/Inc/arm_math.h ****   float32_t * pDst,
1330:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1331:DSP/Inc/arm_math.h **** 
1332:DSP/Inc/arm_math.h **** 
1333:DSP/Inc/arm_math.h ****   /**
1334:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1335:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1336:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1337:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1338:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1339:DSP/Inc/arm_math.h ****    */
1340:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1341:DSP/Inc/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1342:DSP/Inc/arm_math.h ****   uint8_t numStages,
1343:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
1344:DSP/Inc/arm_math.h ****   float32_t * pState);
1345:DSP/Inc/arm_math.h **** 
1346:DSP/Inc/arm_math.h **** 
1347:DSP/Inc/arm_math.h ****   /**
1348:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1349:DSP/Inc/arm_math.h ****    */
1350:DSP/Inc/arm_math.h ****   typedef struct
1351:DSP/Inc/arm_math.h ****   {
1352:DSP/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1353:DSP/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1354:DSP/Inc/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1355:DSP/Inc/arm_math.h ****   } arm_matrix_instance_f32;
1356:DSP/Inc/arm_math.h **** 
1357:DSP/Inc/arm_math.h **** 
1358:DSP/Inc/arm_math.h ****   /**
1359:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1360:DSP/Inc/arm_math.h ****    */
1361:DSP/Inc/arm_math.h ****   typedef struct
1362:DSP/Inc/arm_math.h ****   {
1363:DSP/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1364:DSP/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1365:DSP/Inc/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1366:DSP/Inc/arm_math.h ****   } arm_matrix_instance_f64;
1367:DSP/Inc/arm_math.h **** 
1368:DSP/Inc/arm_math.h ****   /**
1369:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 28


1370:DSP/Inc/arm_math.h ****    */
1371:DSP/Inc/arm_math.h ****   typedef struct
1372:DSP/Inc/arm_math.h ****   {
1373:DSP/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1374:DSP/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1375:DSP/Inc/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1376:DSP/Inc/arm_math.h ****   } arm_matrix_instance_q15;
1377:DSP/Inc/arm_math.h **** 
1378:DSP/Inc/arm_math.h ****   /**
1379:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1380:DSP/Inc/arm_math.h ****    */
1381:DSP/Inc/arm_math.h ****   typedef struct
1382:DSP/Inc/arm_math.h ****   {
1383:DSP/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1384:DSP/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1385:DSP/Inc/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1386:DSP/Inc/arm_math.h ****   } arm_matrix_instance_q31;
1387:DSP/Inc/arm_math.h **** 
1388:DSP/Inc/arm_math.h **** 
1389:DSP/Inc/arm_math.h ****   /**
1390:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix addition.
1391:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1392:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1393:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1394:DSP/Inc/arm_math.h ****    * @return     The function returns either
1395:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1396:DSP/Inc/arm_math.h ****    */
1397:DSP/Inc/arm_math.h ****   arm_status arm_mat_add_f32(
1398:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1399:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1400:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1401:DSP/Inc/arm_math.h **** 
1402:DSP/Inc/arm_math.h **** 
1403:DSP/Inc/arm_math.h ****   /**
1404:DSP/Inc/arm_math.h ****    * @brief Q15 matrix addition.
1405:DSP/Inc/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
1406:DSP/Inc/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1407:DSP/Inc/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1408:DSP/Inc/arm_math.h ****    * @return     The function returns either
1409:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1410:DSP/Inc/arm_math.h ****    */
1411:DSP/Inc/arm_math.h ****   arm_status arm_mat_add_q15(
1412:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1413:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1414:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1415:DSP/Inc/arm_math.h **** 
1416:DSP/Inc/arm_math.h **** 
1417:DSP/Inc/arm_math.h ****   /**
1418:DSP/Inc/arm_math.h ****    * @brief Q31 matrix addition.
1419:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1420:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1421:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1422:DSP/Inc/arm_math.h ****    * @return     The function returns either
1423:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1424:DSP/Inc/arm_math.h ****    */
1425:DSP/Inc/arm_math.h ****   arm_status arm_mat_add_q31(
1426:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 29


1427:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1428:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1429:DSP/Inc/arm_math.h **** 
1430:DSP/Inc/arm_math.h **** 
1431:DSP/Inc/arm_math.h ****   /**
1432:DSP/Inc/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1433:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1434:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1435:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1436:DSP/Inc/arm_math.h ****    * @return     The function returns either
1437:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1438:DSP/Inc/arm_math.h ****    */
1439:DSP/Inc/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1440:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1441:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1442:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1443:DSP/Inc/arm_math.h **** 
1444:DSP/Inc/arm_math.h **** 
1445:DSP/Inc/arm_math.h ****   /**
1446:DSP/Inc/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1447:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1448:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1449:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1450:DSP/Inc/arm_math.h ****    * @return     The function returns either
1451:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1452:DSP/Inc/arm_math.h ****    */
1453:DSP/Inc/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1454:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1455:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1456:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1457:DSP/Inc/arm_math.h ****   q15_t * pScratch);
1458:DSP/Inc/arm_math.h **** 
1459:DSP/Inc/arm_math.h **** 
1460:DSP/Inc/arm_math.h ****   /**
1461:DSP/Inc/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
1462:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1463:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1464:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1465:DSP/Inc/arm_math.h ****    * @return     The function returns either
1466:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1467:DSP/Inc/arm_math.h ****    */
1468:DSP/Inc/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1469:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1470:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1471:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1472:DSP/Inc/arm_math.h **** 
1473:DSP/Inc/arm_math.h **** 
1474:DSP/Inc/arm_math.h ****   /**
1475:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix transpose.
1476:DSP/Inc/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1477:DSP/Inc/arm_math.h ****    * @param[out] pDst  points to the output matrix
1478:DSP/Inc/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1479:DSP/Inc/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1480:DSP/Inc/arm_math.h ****    */
1481:DSP/Inc/arm_math.h ****   arm_status arm_mat_trans_f32(
1482:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1483:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 30


1484:DSP/Inc/arm_math.h **** 
1485:DSP/Inc/arm_math.h **** 
1486:DSP/Inc/arm_math.h ****   /**
1487:DSP/Inc/arm_math.h ****    * @brief Q15 matrix transpose.
1488:DSP/Inc/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1489:DSP/Inc/arm_math.h ****    * @param[out] pDst  points to the output matrix
1490:DSP/Inc/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1491:DSP/Inc/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1492:DSP/Inc/arm_math.h ****    */
1493:DSP/Inc/arm_math.h ****   arm_status arm_mat_trans_q15(
1494:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1495:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1496:DSP/Inc/arm_math.h **** 
1497:DSP/Inc/arm_math.h **** 
1498:DSP/Inc/arm_math.h ****   /**
1499:DSP/Inc/arm_math.h ****    * @brief Q31 matrix transpose.
1500:DSP/Inc/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1501:DSP/Inc/arm_math.h ****    * @param[out] pDst  points to the output matrix
1502:DSP/Inc/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1503:DSP/Inc/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1504:DSP/Inc/arm_math.h ****    */
1505:DSP/Inc/arm_math.h ****   arm_status arm_mat_trans_q31(
1506:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1507:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1508:DSP/Inc/arm_math.h **** 
1509:DSP/Inc/arm_math.h **** 
1510:DSP/Inc/arm_math.h ****   /**
1511:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix multiplication
1512:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1513:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1514:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1515:DSP/Inc/arm_math.h ****    * @return     The function returns either
1516:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1517:DSP/Inc/arm_math.h ****    */
1518:DSP/Inc/arm_math.h ****   arm_status arm_mat_mult_f32(
1519:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1520:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1521:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1522:DSP/Inc/arm_math.h **** 
1523:DSP/Inc/arm_math.h **** 
1524:DSP/Inc/arm_math.h ****   /**
1525:DSP/Inc/arm_math.h ****    * @brief Q15 matrix multiplication
1526:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1527:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1528:DSP/Inc/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1529:DSP/Inc/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1530:DSP/Inc/arm_math.h ****    * @return     The function returns either
1531:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1532:DSP/Inc/arm_math.h ****    */
1533:DSP/Inc/arm_math.h ****   arm_status arm_mat_mult_q15(
1534:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1535:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1536:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1537:DSP/Inc/arm_math.h ****   q15_t * pState);
1538:DSP/Inc/arm_math.h **** 
1539:DSP/Inc/arm_math.h **** 
1540:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 31


1541:DSP/Inc/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1542:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1543:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1544:DSP/Inc/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1545:DSP/Inc/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1546:DSP/Inc/arm_math.h ****    * @return     The function returns either
1547:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1548:DSP/Inc/arm_math.h ****    */
1549:DSP/Inc/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1550:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1551:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1552:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1553:DSP/Inc/arm_math.h ****   q15_t * pState);
1554:DSP/Inc/arm_math.h **** 
1555:DSP/Inc/arm_math.h **** 
1556:DSP/Inc/arm_math.h ****   /**
1557:DSP/Inc/arm_math.h ****    * @brief Q31 matrix multiplication
1558:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1559:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1560:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1561:DSP/Inc/arm_math.h ****    * @return     The function returns either
1562:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1563:DSP/Inc/arm_math.h ****    */
1564:DSP/Inc/arm_math.h ****   arm_status arm_mat_mult_q31(
1565:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1566:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1567:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1568:DSP/Inc/arm_math.h **** 
1569:DSP/Inc/arm_math.h **** 
1570:DSP/Inc/arm_math.h ****   /**
1571:DSP/Inc/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1572:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1573:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1574:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1575:DSP/Inc/arm_math.h ****    * @return     The function returns either
1576:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1577:DSP/Inc/arm_math.h ****    */
1578:DSP/Inc/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1579:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1580:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1581:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1582:DSP/Inc/arm_math.h **** 
1583:DSP/Inc/arm_math.h **** 
1584:DSP/Inc/arm_math.h ****   /**
1585:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix subtraction
1586:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1587:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1588:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1589:DSP/Inc/arm_math.h ****    * @return     The function returns either
1590:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1591:DSP/Inc/arm_math.h ****    */
1592:DSP/Inc/arm_math.h ****   arm_status arm_mat_sub_f32(
1593:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1594:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1595:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1596:DSP/Inc/arm_math.h **** 
1597:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 32


1598:DSP/Inc/arm_math.h ****   /**
1599:DSP/Inc/arm_math.h ****    * @brief Q15 matrix subtraction
1600:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1601:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1602:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1603:DSP/Inc/arm_math.h ****    * @return     The function returns either
1604:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1605:DSP/Inc/arm_math.h ****    */
1606:DSP/Inc/arm_math.h ****   arm_status arm_mat_sub_q15(
1607:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1608:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1609:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1610:DSP/Inc/arm_math.h **** 
1611:DSP/Inc/arm_math.h **** 
1612:DSP/Inc/arm_math.h ****   /**
1613:DSP/Inc/arm_math.h ****    * @brief Q31 matrix subtraction
1614:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1615:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1616:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1617:DSP/Inc/arm_math.h ****    * @return     The function returns either
1618:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1619:DSP/Inc/arm_math.h ****    */
1620:DSP/Inc/arm_math.h ****   arm_status arm_mat_sub_q31(
1621:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1622:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1623:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1624:DSP/Inc/arm_math.h **** 
1625:DSP/Inc/arm_math.h **** 
1626:DSP/Inc/arm_math.h ****   /**
1627:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix scaling.
1628:DSP/Inc/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1629:DSP/Inc/arm_math.h ****    * @param[in]  scale  scale factor
1630:DSP/Inc/arm_math.h ****    * @param[out] pDst   points to the output matrix
1631:DSP/Inc/arm_math.h ****    * @return     The function returns either
1632:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1633:DSP/Inc/arm_math.h ****    */
1634:DSP/Inc/arm_math.h ****   arm_status arm_mat_scale_f32(
1635:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1636:DSP/Inc/arm_math.h ****   float32_t scale,
1637:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1638:DSP/Inc/arm_math.h **** 
1639:DSP/Inc/arm_math.h **** 
1640:DSP/Inc/arm_math.h ****   /**
1641:DSP/Inc/arm_math.h ****    * @brief Q15 matrix scaling.
1642:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1643:DSP/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1644:DSP/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1645:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to output matrix
1646:DSP/Inc/arm_math.h ****    * @return     The function returns either
1647:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1648:DSP/Inc/arm_math.h ****    */
1649:DSP/Inc/arm_math.h ****   arm_status arm_mat_scale_q15(
1650:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1651:DSP/Inc/arm_math.h ****   q15_t scaleFract,
1652:DSP/Inc/arm_math.h ****   int32_t shift,
1653:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1654:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 33


1655:DSP/Inc/arm_math.h **** 
1656:DSP/Inc/arm_math.h ****   /**
1657:DSP/Inc/arm_math.h ****    * @brief Q31 matrix scaling.
1658:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1659:DSP/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1660:DSP/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1661:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to output matrix structure
1662:DSP/Inc/arm_math.h ****    * @return     The function returns either
1663:DSP/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1664:DSP/Inc/arm_math.h ****    */
1665:DSP/Inc/arm_math.h ****   arm_status arm_mat_scale_q31(
1666:DSP/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1667:DSP/Inc/arm_math.h ****   q31_t scaleFract,
1668:DSP/Inc/arm_math.h ****   int32_t shift,
1669:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1670:DSP/Inc/arm_math.h **** 
1671:DSP/Inc/arm_math.h **** 
1672:DSP/Inc/arm_math.h ****   /**
1673:DSP/Inc/arm_math.h ****    * @brief  Q31 matrix initialization.
1674:DSP/Inc/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1675:DSP/Inc/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1676:DSP/Inc/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1677:DSP/Inc/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1678:DSP/Inc/arm_math.h ****    */
1679:DSP/Inc/arm_math.h ****   void arm_mat_init_q31(
1680:DSP/Inc/arm_math.h ****   arm_matrix_instance_q31 * S,
1681:DSP/Inc/arm_math.h ****   uint16_t nRows,
1682:DSP/Inc/arm_math.h ****   uint16_t nColumns,
1683:DSP/Inc/arm_math.h ****   q31_t * pData);
1684:DSP/Inc/arm_math.h **** 
1685:DSP/Inc/arm_math.h **** 
1686:DSP/Inc/arm_math.h ****   /**
1687:DSP/Inc/arm_math.h ****    * @brief  Q15 matrix initialization.
1688:DSP/Inc/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1689:DSP/Inc/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1690:DSP/Inc/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1691:DSP/Inc/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1692:DSP/Inc/arm_math.h ****    */
1693:DSP/Inc/arm_math.h ****   void arm_mat_init_q15(
1694:DSP/Inc/arm_math.h ****   arm_matrix_instance_q15 * S,
1695:DSP/Inc/arm_math.h ****   uint16_t nRows,
1696:DSP/Inc/arm_math.h ****   uint16_t nColumns,
1697:DSP/Inc/arm_math.h ****   q15_t * pData);
1698:DSP/Inc/arm_math.h **** 
1699:DSP/Inc/arm_math.h **** 
1700:DSP/Inc/arm_math.h ****   /**
1701:DSP/Inc/arm_math.h ****    * @brief  Floating-point matrix initialization.
1702:DSP/Inc/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1703:DSP/Inc/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1704:DSP/Inc/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1705:DSP/Inc/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1706:DSP/Inc/arm_math.h ****    */
1707:DSP/Inc/arm_math.h ****   void arm_mat_init_f32(
1708:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * S,
1709:DSP/Inc/arm_math.h ****   uint16_t nRows,
1710:DSP/Inc/arm_math.h ****   uint16_t nColumns,
1711:DSP/Inc/arm_math.h ****   float32_t * pData);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 34


1712:DSP/Inc/arm_math.h **** 
1713:DSP/Inc/arm_math.h **** 
1714:DSP/Inc/arm_math.h **** 
1715:DSP/Inc/arm_math.h ****   /**
1716:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1717:DSP/Inc/arm_math.h ****    */
1718:DSP/Inc/arm_math.h ****   typedef struct
1719:DSP/Inc/arm_math.h ****   {
1720:DSP/Inc/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1721:DSP/Inc/arm_math.h **** #if !defined (ARM_MATH_DSP)
1722:DSP/Inc/arm_math.h ****     q15_t A1;
1723:DSP/Inc/arm_math.h ****     q15_t A2;
1724:DSP/Inc/arm_math.h **** #else
1725:DSP/Inc/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1726:DSP/Inc/arm_math.h **** #endif
1727:DSP/Inc/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1728:DSP/Inc/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1729:DSP/Inc/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1730:DSP/Inc/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1731:DSP/Inc/arm_math.h ****   } arm_pid_instance_q15;
1732:DSP/Inc/arm_math.h **** 
1733:DSP/Inc/arm_math.h ****   /**
1734:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1735:DSP/Inc/arm_math.h ****    */
1736:DSP/Inc/arm_math.h ****   typedef struct
1737:DSP/Inc/arm_math.h ****   {
1738:DSP/Inc/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1739:DSP/Inc/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1740:DSP/Inc/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1741:DSP/Inc/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1742:DSP/Inc/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1743:DSP/Inc/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1744:DSP/Inc/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1745:DSP/Inc/arm_math.h ****   } arm_pid_instance_q31;
1746:DSP/Inc/arm_math.h **** 
1747:DSP/Inc/arm_math.h ****   /**
1748:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1749:DSP/Inc/arm_math.h ****    */
1750:DSP/Inc/arm_math.h ****   typedef struct
1751:DSP/Inc/arm_math.h ****   {
1752:DSP/Inc/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1753:DSP/Inc/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1754:DSP/Inc/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
1755:DSP/Inc/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1756:DSP/Inc/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1757:DSP/Inc/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1758:DSP/Inc/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1759:DSP/Inc/arm_math.h ****   } arm_pid_instance_f32;
1760:DSP/Inc/arm_math.h **** 
1761:DSP/Inc/arm_math.h **** 
1762:DSP/Inc/arm_math.h **** 
1763:DSP/Inc/arm_math.h ****   /**
1764:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1765:DSP/Inc/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1766:DSP/Inc/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1767:DSP/Inc/arm_math.h ****    */
1768:DSP/Inc/arm_math.h ****   void arm_pid_init_f32(
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 35


1769:DSP/Inc/arm_math.h ****   arm_pid_instance_f32 * S,
1770:DSP/Inc/arm_math.h ****   int32_t resetStateFlag);
1771:DSP/Inc/arm_math.h **** 
1772:DSP/Inc/arm_math.h **** 
1773:DSP/Inc/arm_math.h ****   /**
1774:DSP/Inc/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1775:DSP/Inc/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
1776:DSP/Inc/arm_math.h ****    */
1777:DSP/Inc/arm_math.h ****   void arm_pid_reset_f32(
1778:DSP/Inc/arm_math.h ****   arm_pid_instance_f32 * S);
1779:DSP/Inc/arm_math.h **** 
1780:DSP/Inc/arm_math.h **** 
1781:DSP/Inc/arm_math.h ****   /**
1782:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1783:DSP/Inc/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1784:DSP/Inc/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1785:DSP/Inc/arm_math.h ****    */
1786:DSP/Inc/arm_math.h ****   void arm_pid_init_q31(
1787:DSP/Inc/arm_math.h ****   arm_pid_instance_q31 * S,
1788:DSP/Inc/arm_math.h ****   int32_t resetStateFlag);
1789:DSP/Inc/arm_math.h **** 
1790:DSP/Inc/arm_math.h **** 
1791:DSP/Inc/arm_math.h ****   /**
1792:DSP/Inc/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1793:DSP/Inc/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1794:DSP/Inc/arm_math.h ****    */
1795:DSP/Inc/arm_math.h **** 
1796:DSP/Inc/arm_math.h ****   void arm_pid_reset_q31(
1797:DSP/Inc/arm_math.h ****   arm_pid_instance_q31 * S);
1798:DSP/Inc/arm_math.h **** 
1799:DSP/Inc/arm_math.h **** 
1800:DSP/Inc/arm_math.h ****   /**
1801:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1802:DSP/Inc/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1803:DSP/Inc/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1804:DSP/Inc/arm_math.h ****    */
1805:DSP/Inc/arm_math.h ****   void arm_pid_init_q15(
1806:DSP/Inc/arm_math.h ****   arm_pid_instance_q15 * S,
1807:DSP/Inc/arm_math.h ****   int32_t resetStateFlag);
1808:DSP/Inc/arm_math.h **** 
1809:DSP/Inc/arm_math.h **** 
1810:DSP/Inc/arm_math.h ****   /**
1811:DSP/Inc/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
1812:DSP/Inc/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1813:DSP/Inc/arm_math.h ****    */
1814:DSP/Inc/arm_math.h ****   void arm_pid_reset_q15(
1815:DSP/Inc/arm_math.h ****   arm_pid_instance_q15 * S);
1816:DSP/Inc/arm_math.h **** 
1817:DSP/Inc/arm_math.h **** 
1818:DSP/Inc/arm_math.h ****   /**
1819:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1820:DSP/Inc/arm_math.h ****    */
1821:DSP/Inc/arm_math.h ****   typedef struct
1822:DSP/Inc/arm_math.h ****   {
1823:DSP/Inc/arm_math.h ****     uint32_t nValues;           /**< nValues */
1824:DSP/Inc/arm_math.h ****     float32_t x1;               /**< x1 */
1825:DSP/Inc/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 36


1826:DSP/Inc/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1827:DSP/Inc/arm_math.h ****   } arm_linear_interp_instance_f32;
1828:DSP/Inc/arm_math.h **** 
1829:DSP/Inc/arm_math.h ****   /**
1830:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1831:DSP/Inc/arm_math.h ****    */
1832:DSP/Inc/arm_math.h ****   typedef struct
1833:DSP/Inc/arm_math.h ****   {
1834:DSP/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1835:DSP/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1836:DSP/Inc/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1837:DSP/Inc/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1838:DSP/Inc/arm_math.h **** 
1839:DSP/Inc/arm_math.h ****    /**
1840:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1841:DSP/Inc/arm_math.h ****    */
1842:DSP/Inc/arm_math.h ****   typedef struct
1843:DSP/Inc/arm_math.h ****   {
1844:DSP/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1845:DSP/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1846:DSP/Inc/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1847:DSP/Inc/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1848:DSP/Inc/arm_math.h **** 
1849:DSP/Inc/arm_math.h ****    /**
1850:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1851:DSP/Inc/arm_math.h ****    */
1852:DSP/Inc/arm_math.h ****   typedef struct
1853:DSP/Inc/arm_math.h ****   {
1854:DSP/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1855:DSP/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1856:DSP/Inc/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1857:DSP/Inc/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1858:DSP/Inc/arm_math.h **** 
1859:DSP/Inc/arm_math.h ****    /**
1860:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1861:DSP/Inc/arm_math.h ****    */
1862:DSP/Inc/arm_math.h ****   typedef struct
1863:DSP/Inc/arm_math.h ****   {
1864:DSP/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1865:DSP/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1866:DSP/Inc/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1867:DSP/Inc/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1868:DSP/Inc/arm_math.h **** 
1869:DSP/Inc/arm_math.h **** 
1870:DSP/Inc/arm_math.h ****   /**
1871:DSP/Inc/arm_math.h ****    * @brief Q7 vector multiplication.
1872:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1873:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1874:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1875:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1876:DSP/Inc/arm_math.h ****    */
1877:DSP/Inc/arm_math.h ****   void arm_mult_q7(
1878:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
1879:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
1880:DSP/Inc/arm_math.h ****   q7_t * pDst,
1881:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1882:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 37


1883:DSP/Inc/arm_math.h **** 
1884:DSP/Inc/arm_math.h ****   /**
1885:DSP/Inc/arm_math.h ****    * @brief Q15 vector multiplication.
1886:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1887:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1888:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1889:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1890:DSP/Inc/arm_math.h ****    */
1891:DSP/Inc/arm_math.h ****   void arm_mult_q15(
1892:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
1893:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
1894:DSP/Inc/arm_math.h ****   q15_t * pDst,
1895:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1896:DSP/Inc/arm_math.h **** 
1897:DSP/Inc/arm_math.h **** 
1898:DSP/Inc/arm_math.h ****   /**
1899:DSP/Inc/arm_math.h ****    * @brief Q31 vector multiplication.
1900:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1901:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1902:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1903:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1904:DSP/Inc/arm_math.h ****    */
1905:DSP/Inc/arm_math.h ****   void arm_mult_q31(
1906:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
1907:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
1908:DSP/Inc/arm_math.h ****   q31_t * pDst,
1909:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1910:DSP/Inc/arm_math.h **** 
1911:DSP/Inc/arm_math.h **** 
1912:DSP/Inc/arm_math.h ****   /**
1913:DSP/Inc/arm_math.h ****    * @brief Floating-point vector multiplication.
1914:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1915:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1916:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1917:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1918:DSP/Inc/arm_math.h ****    */
1919:DSP/Inc/arm_math.h ****   void arm_mult_f32(
1920:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
1921:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
1922:DSP/Inc/arm_math.h ****   float32_t * pDst,
1923:DSP/Inc/arm_math.h ****   uint32_t blockSize);
1924:DSP/Inc/arm_math.h **** 
1925:DSP/Inc/arm_math.h **** 
1926:DSP/Inc/arm_math.h ****   /**
1927:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
1928:DSP/Inc/arm_math.h ****    */
1929:DSP/Inc/arm_math.h ****   typedef struct
1930:DSP/Inc/arm_math.h ****   {
1931:DSP/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
1932:DSP/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
1933:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
1934:DSP/Inc/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
1935:DSP/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
1936:DSP/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
1937:DSP/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
1938:DSP/Inc/arm_math.h ****   } arm_cfft_radix2_instance_q15;
1939:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 38


1940:DSP/Inc/arm_math.h **** /* Deprecated */
1941:DSP/Inc/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
1942:DSP/Inc/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
1943:DSP/Inc/arm_math.h ****   uint16_t fftLen,
1944:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
1945:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
1946:DSP/Inc/arm_math.h **** 
1947:DSP/Inc/arm_math.h **** /* Deprecated */
1948:DSP/Inc/arm_math.h ****   void arm_cfft_radix2_q15(
1949:DSP/Inc/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
1950:DSP/Inc/arm_math.h ****   q15_t * pSrc);
1951:DSP/Inc/arm_math.h **** 
1952:DSP/Inc/arm_math.h **** 
1953:DSP/Inc/arm_math.h ****   /**
1954:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
1955:DSP/Inc/arm_math.h ****    */
1956:DSP/Inc/arm_math.h ****   typedef struct
1957:DSP/Inc/arm_math.h ****   {
1958:DSP/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
1959:DSP/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
1960:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
1961:DSP/Inc/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
1962:DSP/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
1963:DSP/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
1964:DSP/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
1965:DSP/Inc/arm_math.h ****   } arm_cfft_radix4_instance_q15;
1966:DSP/Inc/arm_math.h **** 
1967:DSP/Inc/arm_math.h **** /* Deprecated */
1968:DSP/Inc/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
1969:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
1970:DSP/Inc/arm_math.h ****   uint16_t fftLen,
1971:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
1972:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
1973:DSP/Inc/arm_math.h **** 
1974:DSP/Inc/arm_math.h **** /* Deprecated */
1975:DSP/Inc/arm_math.h ****   void arm_cfft_radix4_q15(
1976:DSP/Inc/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
1977:DSP/Inc/arm_math.h ****   q15_t * pSrc);
1978:DSP/Inc/arm_math.h **** 
1979:DSP/Inc/arm_math.h ****   /**
1980:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
1981:DSP/Inc/arm_math.h ****    */
1982:DSP/Inc/arm_math.h ****   typedef struct
1983:DSP/Inc/arm_math.h ****   {
1984:DSP/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
1985:DSP/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
1986:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
1987:DSP/Inc/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
1988:DSP/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
1989:DSP/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
1990:DSP/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
1991:DSP/Inc/arm_math.h ****   } arm_cfft_radix2_instance_q31;
1992:DSP/Inc/arm_math.h **** 
1993:DSP/Inc/arm_math.h **** /* Deprecated */
1994:DSP/Inc/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
1995:DSP/Inc/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
1996:DSP/Inc/arm_math.h ****   uint16_t fftLen,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 39


1997:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
1998:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
1999:DSP/Inc/arm_math.h **** 
2000:DSP/Inc/arm_math.h **** /* Deprecated */
2001:DSP/Inc/arm_math.h ****   void arm_cfft_radix2_q31(
2002:DSP/Inc/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2003:DSP/Inc/arm_math.h ****   q31_t * pSrc);
2004:DSP/Inc/arm_math.h **** 
2005:DSP/Inc/arm_math.h ****   /**
2006:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2007:DSP/Inc/arm_math.h ****    */
2008:DSP/Inc/arm_math.h ****   typedef struct
2009:DSP/Inc/arm_math.h ****   {
2010:DSP/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2011:DSP/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2012:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2013:DSP/Inc/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2014:DSP/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2015:DSP/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2016:DSP/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2017:DSP/Inc/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2018:DSP/Inc/arm_math.h **** 
2019:DSP/Inc/arm_math.h **** /* Deprecated */
2020:DSP/Inc/arm_math.h ****   void arm_cfft_radix4_q31(
2021:DSP/Inc/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2022:DSP/Inc/arm_math.h ****   q31_t * pSrc);
2023:DSP/Inc/arm_math.h **** 
2024:DSP/Inc/arm_math.h **** /* Deprecated */
2025:DSP/Inc/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2026:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2027:DSP/Inc/arm_math.h ****   uint16_t fftLen,
2028:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
2029:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2030:DSP/Inc/arm_math.h **** 
2031:DSP/Inc/arm_math.h ****   /**
2032:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2033:DSP/Inc/arm_math.h ****    */
2034:DSP/Inc/arm_math.h ****   typedef struct
2035:DSP/Inc/arm_math.h ****   {
2036:DSP/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2037:DSP/Inc/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2038:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2039:DSP/Inc/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2040:DSP/Inc/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2041:DSP/Inc/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2042:DSP/Inc/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2043:DSP/Inc/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2044:DSP/Inc/arm_math.h ****   } arm_cfft_radix2_instance_f32;
2045:DSP/Inc/arm_math.h **** 
2046:DSP/Inc/arm_math.h **** /* Deprecated */
2047:DSP/Inc/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2048:DSP/Inc/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2049:DSP/Inc/arm_math.h ****   uint16_t fftLen,
2050:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
2051:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2052:DSP/Inc/arm_math.h **** 
2053:DSP/Inc/arm_math.h **** /* Deprecated */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 40


2054:DSP/Inc/arm_math.h ****   void arm_cfft_radix2_f32(
2055:DSP/Inc/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2056:DSP/Inc/arm_math.h ****   float32_t * pSrc);
2057:DSP/Inc/arm_math.h **** 
2058:DSP/Inc/arm_math.h ****   /**
2059:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2060:DSP/Inc/arm_math.h ****    */
2061:DSP/Inc/arm_math.h ****   typedef struct
2062:DSP/Inc/arm_math.h ****   {
2063:DSP/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2064:DSP/Inc/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2065:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2066:DSP/Inc/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2067:DSP/Inc/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2068:DSP/Inc/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2069:DSP/Inc/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2070:DSP/Inc/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2071:DSP/Inc/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2072:DSP/Inc/arm_math.h **** 
2073:DSP/Inc/arm_math.h **** /* Deprecated */
2074:DSP/Inc/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2075:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2076:DSP/Inc/arm_math.h ****   uint16_t fftLen,
2077:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
2078:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2079:DSP/Inc/arm_math.h **** 
2080:DSP/Inc/arm_math.h **** /* Deprecated */
2081:DSP/Inc/arm_math.h ****   void arm_cfft_radix4_f32(
2082:DSP/Inc/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2083:DSP/Inc/arm_math.h ****   float32_t * pSrc);
2084:DSP/Inc/arm_math.h **** 
2085:DSP/Inc/arm_math.h ****   /**
2086:DSP/Inc/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2087:DSP/Inc/arm_math.h ****    */
2088:DSP/Inc/arm_math.h ****   typedef struct
2089:DSP/Inc/arm_math.h ****   {
2090:DSP/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2091:DSP/Inc/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2092:DSP/Inc/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2093:DSP/Inc/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2094:DSP/Inc/arm_math.h ****   } arm_cfft_instance_q15;
2095:DSP/Inc/arm_math.h **** 
2096:DSP/Inc/arm_math.h **** void arm_cfft_q15(
2097:DSP/Inc/arm_math.h ****     const arm_cfft_instance_q15 * S,
2098:DSP/Inc/arm_math.h ****     q15_t * p1,
2099:DSP/Inc/arm_math.h ****     uint8_t ifftFlag,
2100:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag);
2101:DSP/Inc/arm_math.h **** 
2102:DSP/Inc/arm_math.h ****   /**
2103:DSP/Inc/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2104:DSP/Inc/arm_math.h ****    */
2105:DSP/Inc/arm_math.h ****   typedef struct
2106:DSP/Inc/arm_math.h ****   {
2107:DSP/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2108:DSP/Inc/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2109:DSP/Inc/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2110:DSP/Inc/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 41


2111:DSP/Inc/arm_math.h ****   } arm_cfft_instance_q31;
2112:DSP/Inc/arm_math.h **** 
2113:DSP/Inc/arm_math.h **** void arm_cfft_q31(
2114:DSP/Inc/arm_math.h ****     const arm_cfft_instance_q31 * S,
2115:DSP/Inc/arm_math.h ****     q31_t * p1,
2116:DSP/Inc/arm_math.h ****     uint8_t ifftFlag,
2117:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlag);
2118:DSP/Inc/arm_math.h **** 
2119:DSP/Inc/arm_math.h ****   /**
2120:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2121:DSP/Inc/arm_math.h ****    */
2122:DSP/Inc/arm_math.h ****   typedef struct
2123:DSP/Inc/arm_math.h ****   {
2124:DSP/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2125:DSP/Inc/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2126:DSP/Inc/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2127:DSP/Inc/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2128:DSP/Inc/arm_math.h ****   } arm_cfft_instance_f32;
2129:DSP/Inc/arm_math.h **** 
2130:DSP/Inc/arm_math.h ****   void arm_cfft_f32(
2131:DSP/Inc/arm_math.h ****   const arm_cfft_instance_f32 * S,
2132:DSP/Inc/arm_math.h ****   float32_t * p1,
2133:DSP/Inc/arm_math.h ****   uint8_t ifftFlag,
2134:DSP/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2135:DSP/Inc/arm_math.h **** 
2136:DSP/Inc/arm_math.h ****   /**
2137:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2138:DSP/Inc/arm_math.h ****    */
2139:DSP/Inc/arm_math.h ****   typedef struct
2140:DSP/Inc/arm_math.h ****   {
2141:DSP/Inc/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2142:DSP/Inc/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2143:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2144:DSP/Inc/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2145:DSP/Inc/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
2146:DSP/Inc/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
2147:DSP/Inc/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2148:DSP/Inc/arm_math.h ****   } arm_rfft_instance_q15;
2149:DSP/Inc/arm_math.h **** 
2150:DSP/Inc/arm_math.h ****   arm_status arm_rfft_init_q15(
2151:DSP/Inc/arm_math.h ****   arm_rfft_instance_q15 * S,
2152:DSP/Inc/arm_math.h ****   uint32_t fftLenReal,
2153:DSP/Inc/arm_math.h ****   uint32_t ifftFlagR,
2154:DSP/Inc/arm_math.h ****   uint32_t bitReverseFlag);
2155:DSP/Inc/arm_math.h **** 
2156:DSP/Inc/arm_math.h ****   void arm_rfft_q15(
2157:DSP/Inc/arm_math.h ****   const arm_rfft_instance_q15 * S,
2158:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2159:DSP/Inc/arm_math.h ****   q15_t * pDst);
2160:DSP/Inc/arm_math.h **** 
2161:DSP/Inc/arm_math.h ****   /**
2162:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2163:DSP/Inc/arm_math.h ****    */
2164:DSP/Inc/arm_math.h ****   typedef struct
2165:DSP/Inc/arm_math.h ****   {
2166:DSP/Inc/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2167:DSP/Inc/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 42


2168:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2169:DSP/Inc/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2170:DSP/Inc/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2171:DSP/Inc/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2172:DSP/Inc/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2173:DSP/Inc/arm_math.h ****   } arm_rfft_instance_q31;
2174:DSP/Inc/arm_math.h **** 
2175:DSP/Inc/arm_math.h ****   arm_status arm_rfft_init_q31(
2176:DSP/Inc/arm_math.h ****   arm_rfft_instance_q31 * S,
2177:DSP/Inc/arm_math.h ****   uint32_t fftLenReal,
2178:DSP/Inc/arm_math.h ****   uint32_t ifftFlagR,
2179:DSP/Inc/arm_math.h ****   uint32_t bitReverseFlag);
2180:DSP/Inc/arm_math.h **** 
2181:DSP/Inc/arm_math.h ****   void arm_rfft_q31(
2182:DSP/Inc/arm_math.h ****   const arm_rfft_instance_q31 * S,
2183:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2184:DSP/Inc/arm_math.h ****   q31_t * pDst);
2185:DSP/Inc/arm_math.h **** 
2186:DSP/Inc/arm_math.h ****   /**
2187:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2188:DSP/Inc/arm_math.h ****    */
2189:DSP/Inc/arm_math.h ****   typedef struct
2190:DSP/Inc/arm_math.h ****   {
2191:DSP/Inc/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2192:DSP/Inc/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2193:DSP/Inc/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2194:DSP/Inc/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2195:DSP/Inc/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2196:DSP/Inc/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2197:DSP/Inc/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2198:DSP/Inc/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2199:DSP/Inc/arm_math.h ****   } arm_rfft_instance_f32;
2200:DSP/Inc/arm_math.h **** 
2201:DSP/Inc/arm_math.h ****   arm_status arm_rfft_init_f32(
2202:DSP/Inc/arm_math.h ****   arm_rfft_instance_f32 * S,
2203:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2204:DSP/Inc/arm_math.h ****   uint32_t fftLenReal,
2205:DSP/Inc/arm_math.h ****   uint32_t ifftFlagR,
2206:DSP/Inc/arm_math.h ****   uint32_t bitReverseFlag);
2207:DSP/Inc/arm_math.h **** 
2208:DSP/Inc/arm_math.h ****   void arm_rfft_f32(
2209:DSP/Inc/arm_math.h ****   const arm_rfft_instance_f32 * S,
2210:DSP/Inc/arm_math.h ****   float32_t * pSrc,
2211:DSP/Inc/arm_math.h ****   float32_t * pDst);
2212:DSP/Inc/arm_math.h **** 
2213:DSP/Inc/arm_math.h ****   /**
2214:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2215:DSP/Inc/arm_math.h ****    */
2216:DSP/Inc/arm_math.h **** typedef struct
2217:DSP/Inc/arm_math.h ****   {
2218:DSP/Inc/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2219:DSP/Inc/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2220:DSP/Inc/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2221:DSP/Inc/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2222:DSP/Inc/arm_math.h **** 
2223:DSP/Inc/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2224:DSP/Inc/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 43


2225:DSP/Inc/arm_math.h ****    uint16_t fftLen);
2226:DSP/Inc/arm_math.h **** 
2227:DSP/Inc/arm_math.h **** void arm_rfft_fast_f32(
2228:DSP/Inc/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2229:DSP/Inc/arm_math.h ****   float32_t * p, float32_t * pOut,
2230:DSP/Inc/arm_math.h ****   uint8_t ifftFlag);
2231:DSP/Inc/arm_math.h **** 
2232:DSP/Inc/arm_math.h ****   /**
2233:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2234:DSP/Inc/arm_math.h ****    */
2235:DSP/Inc/arm_math.h ****   typedef struct
2236:DSP/Inc/arm_math.h ****   {
2237:DSP/Inc/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2238:DSP/Inc/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2239:DSP/Inc/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2240:DSP/Inc/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2241:DSP/Inc/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2242:DSP/Inc/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2243:DSP/Inc/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2244:DSP/Inc/arm_math.h ****   } arm_dct4_instance_f32;
2245:DSP/Inc/arm_math.h **** 
2246:DSP/Inc/arm_math.h **** 
2247:DSP/Inc/arm_math.h ****   /**
2248:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2249:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2250:DSP/Inc/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2251:DSP/Inc/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2252:DSP/Inc/arm_math.h ****    * @param[in]     N          length of the DCT4.
2253:DSP/Inc/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2254:DSP/Inc/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2255:DSP/Inc/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2256:DSP/Inc/arm_math.h ****    */
2257:DSP/Inc/arm_math.h ****   arm_status arm_dct4_init_f32(
2258:DSP/Inc/arm_math.h ****   arm_dct4_instance_f32 * S,
2259:DSP/Inc/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
2260:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2261:DSP/Inc/arm_math.h ****   uint16_t N,
2262:DSP/Inc/arm_math.h ****   uint16_t Nby2,
2263:DSP/Inc/arm_math.h ****   float32_t normalize);
2264:DSP/Inc/arm_math.h **** 
2265:DSP/Inc/arm_math.h **** 
2266:DSP/Inc/arm_math.h ****   /**
2267:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
2268:DSP/Inc/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2269:DSP/Inc/arm_math.h ****    * @param[in]     pState         points to state buffer.
2270:DSP/Inc/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2271:DSP/Inc/arm_math.h ****    */
2272:DSP/Inc/arm_math.h ****   void arm_dct4_f32(
2273:DSP/Inc/arm_math.h ****   const arm_dct4_instance_f32 * S,
2274:DSP/Inc/arm_math.h ****   float32_t * pState,
2275:DSP/Inc/arm_math.h ****   float32_t * pInlineBuffer);
2276:DSP/Inc/arm_math.h **** 
2277:DSP/Inc/arm_math.h **** 
2278:DSP/Inc/arm_math.h ****   /**
2279:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2280:DSP/Inc/arm_math.h ****    */
2281:DSP/Inc/arm_math.h ****   typedef struct
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 44


2282:DSP/Inc/arm_math.h ****   {
2283:DSP/Inc/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2284:DSP/Inc/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2285:DSP/Inc/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2286:DSP/Inc/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2287:DSP/Inc/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2288:DSP/Inc/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
2289:DSP/Inc/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
2290:DSP/Inc/arm_math.h ****   } arm_dct4_instance_q31;
2291:DSP/Inc/arm_math.h **** 
2292:DSP/Inc/arm_math.h **** 
2293:DSP/Inc/arm_math.h ****   /**
2294:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2295:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2296:DSP/Inc/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2297:DSP/Inc/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2298:DSP/Inc/arm_math.h ****    * @param[in]     N          length of the DCT4.
2299:DSP/Inc/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2300:DSP/Inc/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2301:DSP/Inc/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2302:DSP/Inc/arm_math.h ****    */
2303:DSP/Inc/arm_math.h ****   arm_status arm_dct4_init_q31(
2304:DSP/Inc/arm_math.h ****   arm_dct4_instance_q31 * S,
2305:DSP/Inc/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2306:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2307:DSP/Inc/arm_math.h ****   uint16_t N,
2308:DSP/Inc/arm_math.h ****   uint16_t Nby2,
2309:DSP/Inc/arm_math.h ****   q31_t normalize);
2310:DSP/Inc/arm_math.h **** 
2311:DSP/Inc/arm_math.h **** 
2312:DSP/Inc/arm_math.h ****   /**
2313:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2314:DSP/Inc/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2315:DSP/Inc/arm_math.h ****    * @param[in]     pState         points to state buffer.
2316:DSP/Inc/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2317:DSP/Inc/arm_math.h ****    */
2318:DSP/Inc/arm_math.h ****   void arm_dct4_q31(
2319:DSP/Inc/arm_math.h ****   const arm_dct4_instance_q31 * S,
2320:DSP/Inc/arm_math.h ****   q31_t * pState,
2321:DSP/Inc/arm_math.h ****   q31_t * pInlineBuffer);
2322:DSP/Inc/arm_math.h **** 
2323:DSP/Inc/arm_math.h **** 
2324:DSP/Inc/arm_math.h ****   /**
2325:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2326:DSP/Inc/arm_math.h ****    */
2327:DSP/Inc/arm_math.h ****   typedef struct
2328:DSP/Inc/arm_math.h ****   {
2329:DSP/Inc/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2330:DSP/Inc/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2331:DSP/Inc/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2332:DSP/Inc/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2333:DSP/Inc/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2334:DSP/Inc/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2335:DSP/Inc/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2336:DSP/Inc/arm_math.h ****   } arm_dct4_instance_q15;
2337:DSP/Inc/arm_math.h **** 
2338:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 45


2339:DSP/Inc/arm_math.h ****   /**
2340:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2341:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2342:DSP/Inc/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2343:DSP/Inc/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2344:DSP/Inc/arm_math.h ****    * @param[in]     N          length of the DCT4.
2345:DSP/Inc/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2346:DSP/Inc/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2347:DSP/Inc/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2348:DSP/Inc/arm_math.h ****    */
2349:DSP/Inc/arm_math.h ****   arm_status arm_dct4_init_q15(
2350:DSP/Inc/arm_math.h ****   arm_dct4_instance_q15 * S,
2351:DSP/Inc/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2352:DSP/Inc/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2353:DSP/Inc/arm_math.h ****   uint16_t N,
2354:DSP/Inc/arm_math.h ****   uint16_t Nby2,
2355:DSP/Inc/arm_math.h ****   q15_t normalize);
2356:DSP/Inc/arm_math.h **** 
2357:DSP/Inc/arm_math.h **** 
2358:DSP/Inc/arm_math.h ****   /**
2359:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2360:DSP/Inc/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2361:DSP/Inc/arm_math.h ****    * @param[in]     pState         points to state buffer.
2362:DSP/Inc/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2363:DSP/Inc/arm_math.h ****    */
2364:DSP/Inc/arm_math.h ****   void arm_dct4_q15(
2365:DSP/Inc/arm_math.h ****   const arm_dct4_instance_q15 * S,
2366:DSP/Inc/arm_math.h ****   q15_t * pState,
2367:DSP/Inc/arm_math.h ****   q15_t * pInlineBuffer);
2368:DSP/Inc/arm_math.h **** 
2369:DSP/Inc/arm_math.h **** 
2370:DSP/Inc/arm_math.h ****   /**
2371:DSP/Inc/arm_math.h ****    * @brief Floating-point vector addition.
2372:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2373:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2374:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2375:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2376:DSP/Inc/arm_math.h ****    */
2377:DSP/Inc/arm_math.h ****   void arm_add_f32(
2378:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
2379:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
2380:DSP/Inc/arm_math.h ****   float32_t * pDst,
2381:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2382:DSP/Inc/arm_math.h **** 
2383:DSP/Inc/arm_math.h **** 
2384:DSP/Inc/arm_math.h ****   /**
2385:DSP/Inc/arm_math.h ****    * @brief Q7 vector addition.
2386:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2387:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2388:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2389:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2390:DSP/Inc/arm_math.h ****    */
2391:DSP/Inc/arm_math.h ****   void arm_add_q7(
2392:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
2393:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
2394:DSP/Inc/arm_math.h ****   q7_t * pDst,
2395:DSP/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 46


2396:DSP/Inc/arm_math.h **** 
2397:DSP/Inc/arm_math.h **** 
2398:DSP/Inc/arm_math.h ****   /**
2399:DSP/Inc/arm_math.h ****    * @brief Q15 vector addition.
2400:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2401:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2402:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2403:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2404:DSP/Inc/arm_math.h ****    */
2405:DSP/Inc/arm_math.h ****   void arm_add_q15(
2406:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
2407:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
2408:DSP/Inc/arm_math.h ****   q15_t * pDst,
2409:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2410:DSP/Inc/arm_math.h **** 
2411:DSP/Inc/arm_math.h **** 
2412:DSP/Inc/arm_math.h ****   /**
2413:DSP/Inc/arm_math.h ****    * @brief Q31 vector addition.
2414:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2415:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2416:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2417:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2418:DSP/Inc/arm_math.h ****    */
2419:DSP/Inc/arm_math.h ****   void arm_add_q31(
2420:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
2421:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
2422:DSP/Inc/arm_math.h ****   q31_t * pDst,
2423:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2424:DSP/Inc/arm_math.h **** 
2425:DSP/Inc/arm_math.h **** 
2426:DSP/Inc/arm_math.h ****   /**
2427:DSP/Inc/arm_math.h ****    * @brief Floating-point vector subtraction.
2428:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2429:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2430:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2431:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2432:DSP/Inc/arm_math.h ****    */
2433:DSP/Inc/arm_math.h ****   void arm_sub_f32(
2434:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
2435:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
2436:DSP/Inc/arm_math.h ****   float32_t * pDst,
2437:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2438:DSP/Inc/arm_math.h **** 
2439:DSP/Inc/arm_math.h **** 
2440:DSP/Inc/arm_math.h ****   /**
2441:DSP/Inc/arm_math.h ****    * @brief Q7 vector subtraction.
2442:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2443:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2444:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2445:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2446:DSP/Inc/arm_math.h ****    */
2447:DSP/Inc/arm_math.h ****   void arm_sub_q7(
2448:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
2449:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
2450:DSP/Inc/arm_math.h ****   q7_t * pDst,
2451:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2452:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 47


2453:DSP/Inc/arm_math.h **** 
2454:DSP/Inc/arm_math.h ****   /**
2455:DSP/Inc/arm_math.h ****    * @brief Q15 vector subtraction.
2456:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2457:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2458:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2459:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2460:DSP/Inc/arm_math.h ****    */
2461:DSP/Inc/arm_math.h ****   void arm_sub_q15(
2462:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
2463:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
2464:DSP/Inc/arm_math.h ****   q15_t * pDst,
2465:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2466:DSP/Inc/arm_math.h **** 
2467:DSP/Inc/arm_math.h **** 
2468:DSP/Inc/arm_math.h ****   /**
2469:DSP/Inc/arm_math.h ****    * @brief Q31 vector subtraction.
2470:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2471:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2472:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2473:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2474:DSP/Inc/arm_math.h ****    */
2475:DSP/Inc/arm_math.h ****   void arm_sub_q31(
2476:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
2477:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
2478:DSP/Inc/arm_math.h ****   q31_t * pDst,
2479:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2480:DSP/Inc/arm_math.h **** 
2481:DSP/Inc/arm_math.h **** 
2482:DSP/Inc/arm_math.h ****   /**
2483:DSP/Inc/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2484:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2485:DSP/Inc/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2486:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2487:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2488:DSP/Inc/arm_math.h ****    */
2489:DSP/Inc/arm_math.h ****   void arm_scale_f32(
2490:DSP/Inc/arm_math.h ****   float32_t * pSrc,
2491:DSP/Inc/arm_math.h ****   float32_t scale,
2492:DSP/Inc/arm_math.h ****   float32_t * pDst,
2493:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2494:DSP/Inc/arm_math.h **** 
2495:DSP/Inc/arm_math.h **** 
2496:DSP/Inc/arm_math.h ****   /**
2497:DSP/Inc/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2498:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2499:DSP/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2500:DSP/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2501:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
2502:DSP/Inc/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2503:DSP/Inc/arm_math.h ****    */
2504:DSP/Inc/arm_math.h ****   void arm_scale_q7(
2505:DSP/Inc/arm_math.h ****   q7_t * pSrc,
2506:DSP/Inc/arm_math.h ****   q7_t scaleFract,
2507:DSP/Inc/arm_math.h ****   int8_t shift,
2508:DSP/Inc/arm_math.h ****   q7_t * pDst,
2509:DSP/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 48


2510:DSP/Inc/arm_math.h **** 
2511:DSP/Inc/arm_math.h **** 
2512:DSP/Inc/arm_math.h ****   /**
2513:DSP/Inc/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2514:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2515:DSP/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2516:DSP/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2517:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
2518:DSP/Inc/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2519:DSP/Inc/arm_math.h ****    */
2520:DSP/Inc/arm_math.h ****   void arm_scale_q15(
2521:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2522:DSP/Inc/arm_math.h ****   q15_t scaleFract,
2523:DSP/Inc/arm_math.h ****   int8_t shift,
2524:DSP/Inc/arm_math.h ****   q15_t * pDst,
2525:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2526:DSP/Inc/arm_math.h **** 
2527:DSP/Inc/arm_math.h **** 
2528:DSP/Inc/arm_math.h ****   /**
2529:DSP/Inc/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2530:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2531:DSP/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2532:DSP/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2533:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
2534:DSP/Inc/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2535:DSP/Inc/arm_math.h ****    */
2536:DSP/Inc/arm_math.h ****   void arm_scale_q31(
2537:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2538:DSP/Inc/arm_math.h ****   q31_t scaleFract,
2539:DSP/Inc/arm_math.h ****   int8_t shift,
2540:DSP/Inc/arm_math.h ****   q31_t * pDst,
2541:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2542:DSP/Inc/arm_math.h **** 
2543:DSP/Inc/arm_math.h **** 
2544:DSP/Inc/arm_math.h ****   /**
2545:DSP/Inc/arm_math.h ****    * @brief Q7 vector absolute value.
2546:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2547:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2548:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2549:DSP/Inc/arm_math.h ****    */
2550:DSP/Inc/arm_math.h ****   void arm_abs_q7(
2551:DSP/Inc/arm_math.h ****   q7_t * pSrc,
2552:DSP/Inc/arm_math.h ****   q7_t * pDst,
2553:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2554:DSP/Inc/arm_math.h **** 
2555:DSP/Inc/arm_math.h **** 
2556:DSP/Inc/arm_math.h ****   /**
2557:DSP/Inc/arm_math.h ****    * @brief Floating-point vector absolute value.
2558:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2559:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2560:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2561:DSP/Inc/arm_math.h ****    */
2562:DSP/Inc/arm_math.h ****   void arm_abs_f32(
2563:DSP/Inc/arm_math.h ****   float32_t * pSrc,
2564:DSP/Inc/arm_math.h ****   float32_t * pDst,
2565:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2566:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 49


2567:DSP/Inc/arm_math.h **** 
2568:DSP/Inc/arm_math.h ****   /**
2569:DSP/Inc/arm_math.h ****    * @brief Q15 vector absolute value.
2570:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2571:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2572:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2573:DSP/Inc/arm_math.h ****    */
2574:DSP/Inc/arm_math.h ****   void arm_abs_q15(
2575:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2576:DSP/Inc/arm_math.h ****   q15_t * pDst,
2577:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2578:DSP/Inc/arm_math.h **** 
2579:DSP/Inc/arm_math.h **** 
2580:DSP/Inc/arm_math.h ****   /**
2581:DSP/Inc/arm_math.h ****    * @brief Q31 vector absolute value.
2582:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2583:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2584:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2585:DSP/Inc/arm_math.h ****    */
2586:DSP/Inc/arm_math.h ****   void arm_abs_q31(
2587:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2588:DSP/Inc/arm_math.h ****   q31_t * pDst,
2589:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2590:DSP/Inc/arm_math.h **** 
2591:DSP/Inc/arm_math.h **** 
2592:DSP/Inc/arm_math.h ****   /**
2593:DSP/Inc/arm_math.h ****    * @brief Dot product of floating-point vectors.
2594:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2595:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2596:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2597:DSP/Inc/arm_math.h ****    * @param[out] result     output result returned here
2598:DSP/Inc/arm_math.h ****    */
2599:DSP/Inc/arm_math.h ****   void arm_dot_prod_f32(
2600:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
2601:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
2602:DSP/Inc/arm_math.h ****   uint32_t blockSize,
2603:DSP/Inc/arm_math.h ****   float32_t * result);
2604:DSP/Inc/arm_math.h **** 
2605:DSP/Inc/arm_math.h **** 
2606:DSP/Inc/arm_math.h ****   /**
2607:DSP/Inc/arm_math.h ****    * @brief Dot product of Q7 vectors.
2608:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2609:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2610:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2611:DSP/Inc/arm_math.h ****    * @param[out] result     output result returned here
2612:DSP/Inc/arm_math.h ****    */
2613:DSP/Inc/arm_math.h ****   void arm_dot_prod_q7(
2614:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
2615:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
2616:DSP/Inc/arm_math.h ****   uint32_t blockSize,
2617:DSP/Inc/arm_math.h ****   q31_t * result);
2618:DSP/Inc/arm_math.h **** 
2619:DSP/Inc/arm_math.h **** 
2620:DSP/Inc/arm_math.h ****   /**
2621:DSP/Inc/arm_math.h ****    * @brief Dot product of Q15 vectors.
2622:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2623:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 50


2624:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2625:DSP/Inc/arm_math.h ****    * @param[out] result     output result returned here
2626:DSP/Inc/arm_math.h ****    */
2627:DSP/Inc/arm_math.h ****   void arm_dot_prod_q15(
2628:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
2629:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
2630:DSP/Inc/arm_math.h ****   uint32_t blockSize,
2631:DSP/Inc/arm_math.h ****   q63_t * result);
2632:DSP/Inc/arm_math.h **** 
2633:DSP/Inc/arm_math.h **** 
2634:DSP/Inc/arm_math.h ****   /**
2635:DSP/Inc/arm_math.h ****    * @brief Dot product of Q31 vectors.
2636:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2637:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2638:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2639:DSP/Inc/arm_math.h ****    * @param[out] result     output result returned here
2640:DSP/Inc/arm_math.h ****    */
2641:DSP/Inc/arm_math.h ****   void arm_dot_prod_q31(
2642:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
2643:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
2644:DSP/Inc/arm_math.h ****   uint32_t blockSize,
2645:DSP/Inc/arm_math.h ****   q63_t * result);
2646:DSP/Inc/arm_math.h **** 
2647:DSP/Inc/arm_math.h **** 
2648:DSP/Inc/arm_math.h ****   /**
2649:DSP/Inc/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2650:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2651:DSP/Inc/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2652:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2653:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2654:DSP/Inc/arm_math.h ****    */
2655:DSP/Inc/arm_math.h ****   void arm_shift_q7(
2656:DSP/Inc/arm_math.h ****   q7_t * pSrc,
2657:DSP/Inc/arm_math.h ****   int8_t shiftBits,
2658:DSP/Inc/arm_math.h ****   q7_t * pDst,
2659:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2660:DSP/Inc/arm_math.h **** 
2661:DSP/Inc/arm_math.h **** 
2662:DSP/Inc/arm_math.h ****   /**
2663:DSP/Inc/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2664:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2665:DSP/Inc/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2666:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2667:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2668:DSP/Inc/arm_math.h ****    */
2669:DSP/Inc/arm_math.h ****   void arm_shift_q15(
2670:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2671:DSP/Inc/arm_math.h ****   int8_t shiftBits,
2672:DSP/Inc/arm_math.h ****   q15_t * pDst,
2673:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2674:DSP/Inc/arm_math.h **** 
2675:DSP/Inc/arm_math.h **** 
2676:DSP/Inc/arm_math.h ****   /**
2677:DSP/Inc/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2678:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2679:DSP/Inc/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2680:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 51


2681:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2682:DSP/Inc/arm_math.h ****    */
2683:DSP/Inc/arm_math.h ****   void arm_shift_q31(
2684:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2685:DSP/Inc/arm_math.h ****   int8_t shiftBits,
2686:DSP/Inc/arm_math.h ****   q31_t * pDst,
2687:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2688:DSP/Inc/arm_math.h **** 
2689:DSP/Inc/arm_math.h **** 
2690:DSP/Inc/arm_math.h ****   /**
2691:DSP/Inc/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2692:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2693:DSP/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2694:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2695:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2696:DSP/Inc/arm_math.h ****    */
2697:DSP/Inc/arm_math.h ****   void arm_offset_f32(
2698:DSP/Inc/arm_math.h ****   float32_t * pSrc,
2699:DSP/Inc/arm_math.h ****   float32_t offset,
2700:DSP/Inc/arm_math.h ****   float32_t * pDst,
2701:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2702:DSP/Inc/arm_math.h **** 
2703:DSP/Inc/arm_math.h **** 
2704:DSP/Inc/arm_math.h ****   /**
2705:DSP/Inc/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2706:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2707:DSP/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2708:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2709:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2710:DSP/Inc/arm_math.h ****    */
2711:DSP/Inc/arm_math.h ****   void arm_offset_q7(
2712:DSP/Inc/arm_math.h ****   q7_t * pSrc,
2713:DSP/Inc/arm_math.h ****   q7_t offset,
2714:DSP/Inc/arm_math.h ****   q7_t * pDst,
2715:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2716:DSP/Inc/arm_math.h **** 
2717:DSP/Inc/arm_math.h **** 
2718:DSP/Inc/arm_math.h ****   /**
2719:DSP/Inc/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2720:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2721:DSP/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2722:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2723:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2724:DSP/Inc/arm_math.h ****    */
2725:DSP/Inc/arm_math.h ****   void arm_offset_q15(
2726:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2727:DSP/Inc/arm_math.h ****   q15_t offset,
2728:DSP/Inc/arm_math.h ****   q15_t * pDst,
2729:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2730:DSP/Inc/arm_math.h **** 
2731:DSP/Inc/arm_math.h **** 
2732:DSP/Inc/arm_math.h ****   /**
2733:DSP/Inc/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2734:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2735:DSP/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2736:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2737:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 52


2738:DSP/Inc/arm_math.h ****    */
2739:DSP/Inc/arm_math.h ****   void arm_offset_q31(
2740:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2741:DSP/Inc/arm_math.h ****   q31_t offset,
2742:DSP/Inc/arm_math.h ****   q31_t * pDst,
2743:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2744:DSP/Inc/arm_math.h **** 
2745:DSP/Inc/arm_math.h **** 
2746:DSP/Inc/arm_math.h ****   /**
2747:DSP/Inc/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2748:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2749:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2750:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2751:DSP/Inc/arm_math.h ****    */
2752:DSP/Inc/arm_math.h ****   void arm_negate_f32(
2753:DSP/Inc/arm_math.h ****   float32_t * pSrc,
2754:DSP/Inc/arm_math.h ****   float32_t * pDst,
2755:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2756:DSP/Inc/arm_math.h **** 
2757:DSP/Inc/arm_math.h **** 
2758:DSP/Inc/arm_math.h ****   /**
2759:DSP/Inc/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2760:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2761:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2762:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2763:DSP/Inc/arm_math.h ****    */
2764:DSP/Inc/arm_math.h ****   void arm_negate_q7(
2765:DSP/Inc/arm_math.h ****   q7_t * pSrc,
2766:DSP/Inc/arm_math.h ****   q7_t * pDst,
2767:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2768:DSP/Inc/arm_math.h **** 
2769:DSP/Inc/arm_math.h **** 
2770:DSP/Inc/arm_math.h ****   /**
2771:DSP/Inc/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2772:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2773:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2774:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2775:DSP/Inc/arm_math.h ****    */
2776:DSP/Inc/arm_math.h ****   void arm_negate_q15(
2777:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2778:DSP/Inc/arm_math.h ****   q15_t * pDst,
2779:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2780:DSP/Inc/arm_math.h **** 
2781:DSP/Inc/arm_math.h **** 
2782:DSP/Inc/arm_math.h ****   /**
2783:DSP/Inc/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2784:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2785:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2786:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2787:DSP/Inc/arm_math.h ****    */
2788:DSP/Inc/arm_math.h ****   void arm_negate_q31(
2789:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2790:DSP/Inc/arm_math.h ****   q31_t * pDst,
2791:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2792:DSP/Inc/arm_math.h **** 
2793:DSP/Inc/arm_math.h **** 
2794:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 53


2795:DSP/Inc/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2796:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2797:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2798:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2799:DSP/Inc/arm_math.h ****    */
2800:DSP/Inc/arm_math.h ****   void arm_copy_f32(
2801:DSP/Inc/arm_math.h ****   float32_t * pSrc,
2802:DSP/Inc/arm_math.h ****   float32_t * pDst,
2803:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2804:DSP/Inc/arm_math.h **** 
2805:DSP/Inc/arm_math.h **** 
2806:DSP/Inc/arm_math.h ****   /**
2807:DSP/Inc/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2808:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2809:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2810:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2811:DSP/Inc/arm_math.h ****    */
2812:DSP/Inc/arm_math.h ****   void arm_copy_q7(
2813:DSP/Inc/arm_math.h ****   q7_t * pSrc,
2814:DSP/Inc/arm_math.h ****   q7_t * pDst,
2815:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2816:DSP/Inc/arm_math.h **** 
2817:DSP/Inc/arm_math.h **** 
2818:DSP/Inc/arm_math.h ****   /**
2819:DSP/Inc/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2820:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2821:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2822:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2823:DSP/Inc/arm_math.h ****    */
2824:DSP/Inc/arm_math.h ****   void arm_copy_q15(
2825:DSP/Inc/arm_math.h ****   q15_t * pSrc,
2826:DSP/Inc/arm_math.h ****   q15_t * pDst,
2827:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2828:DSP/Inc/arm_math.h **** 
2829:DSP/Inc/arm_math.h **** 
2830:DSP/Inc/arm_math.h ****   /**
2831:DSP/Inc/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2832:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2833:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2834:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2835:DSP/Inc/arm_math.h ****    */
2836:DSP/Inc/arm_math.h ****   void arm_copy_q31(
2837:DSP/Inc/arm_math.h ****   q31_t * pSrc,
2838:DSP/Inc/arm_math.h ****   q31_t * pDst,
2839:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2840:DSP/Inc/arm_math.h **** 
2841:DSP/Inc/arm_math.h **** 
2842:DSP/Inc/arm_math.h ****   /**
2843:DSP/Inc/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2844:DSP/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2845:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2846:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2847:DSP/Inc/arm_math.h ****    */
2848:DSP/Inc/arm_math.h ****   void arm_fill_f32(
2849:DSP/Inc/arm_math.h ****   float32_t value,
2850:DSP/Inc/arm_math.h ****   float32_t * pDst,
2851:DSP/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 54


2852:DSP/Inc/arm_math.h **** 
2853:DSP/Inc/arm_math.h **** 
2854:DSP/Inc/arm_math.h ****   /**
2855:DSP/Inc/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2856:DSP/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2857:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2858:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2859:DSP/Inc/arm_math.h ****    */
2860:DSP/Inc/arm_math.h ****   void arm_fill_q7(
2861:DSP/Inc/arm_math.h ****   q7_t value,
2862:DSP/Inc/arm_math.h ****   q7_t * pDst,
2863:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2864:DSP/Inc/arm_math.h **** 
2865:DSP/Inc/arm_math.h **** 
2866:DSP/Inc/arm_math.h ****   /**
2867:DSP/Inc/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2868:DSP/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2869:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2870:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2871:DSP/Inc/arm_math.h ****    */
2872:DSP/Inc/arm_math.h ****   void arm_fill_q15(
2873:DSP/Inc/arm_math.h ****   q15_t value,
2874:DSP/Inc/arm_math.h ****   q15_t * pDst,
2875:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2876:DSP/Inc/arm_math.h **** 
2877:DSP/Inc/arm_math.h **** 
2878:DSP/Inc/arm_math.h ****   /**
2879:DSP/Inc/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2880:DSP/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2881:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2882:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2883:DSP/Inc/arm_math.h ****    */
2884:DSP/Inc/arm_math.h ****   void arm_fill_q31(
2885:DSP/Inc/arm_math.h ****   q31_t value,
2886:DSP/Inc/arm_math.h ****   q31_t * pDst,
2887:DSP/Inc/arm_math.h ****   uint32_t blockSize);
2888:DSP/Inc/arm_math.h **** 
2889:DSP/Inc/arm_math.h **** 
2890:DSP/Inc/arm_math.h **** /**
2891:DSP/Inc/arm_math.h ****  * @brief Convolution of floating-point sequences.
2892:DSP/Inc/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2893:DSP/Inc/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2894:DSP/Inc/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2895:DSP/Inc/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2896:DSP/Inc/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2897:DSP/Inc/arm_math.h ****  */
2898:DSP/Inc/arm_math.h ****   void arm_conv_f32(
2899:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
2900:DSP/Inc/arm_math.h ****   uint32_t srcALen,
2901:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
2902:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
2903:DSP/Inc/arm_math.h ****   float32_t * pDst);
2904:DSP/Inc/arm_math.h **** 
2905:DSP/Inc/arm_math.h **** 
2906:DSP/Inc/arm_math.h ****   /**
2907:DSP/Inc/arm_math.h ****    * @brief Convolution of Q15 sequences.
2908:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 55


2909:DSP/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2910:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2911:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2912:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2913:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2914:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2915:DSP/Inc/arm_math.h ****    */
2916:DSP/Inc/arm_math.h ****   void arm_conv_opt_q15(
2917:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
2918:DSP/Inc/arm_math.h ****   uint32_t srcALen,
2919:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
2920:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
2921:DSP/Inc/arm_math.h ****   q15_t * pDst,
2922:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
2923:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
2924:DSP/Inc/arm_math.h **** 
2925:DSP/Inc/arm_math.h **** 
2926:DSP/Inc/arm_math.h **** /**
2927:DSP/Inc/arm_math.h ****  * @brief Convolution of Q15 sequences.
2928:DSP/Inc/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2929:DSP/Inc/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2930:DSP/Inc/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2931:DSP/Inc/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2932:DSP/Inc/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2933:DSP/Inc/arm_math.h ****  */
2934:DSP/Inc/arm_math.h ****   void arm_conv_q15(
2935:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
2936:DSP/Inc/arm_math.h ****   uint32_t srcALen,
2937:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
2938:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
2939:DSP/Inc/arm_math.h ****   q15_t * pDst);
2940:DSP/Inc/arm_math.h **** 
2941:DSP/Inc/arm_math.h **** 
2942:DSP/Inc/arm_math.h ****   /**
2943:DSP/Inc/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
2944:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
2945:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
2946:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
2947:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
2948:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
2949:DSP/Inc/arm_math.h ****    */
2950:DSP/Inc/arm_math.h ****   void arm_conv_fast_q15(
2951:DSP/Inc/arm_math.h ****           q15_t * pSrcA,
2952:DSP/Inc/arm_math.h ****           uint32_t srcALen,
2953:DSP/Inc/arm_math.h ****           q15_t * pSrcB,
2954:DSP/Inc/arm_math.h ****           uint32_t srcBLen,
2955:DSP/Inc/arm_math.h ****           q15_t * pDst);
2956:DSP/Inc/arm_math.h **** 
2957:DSP/Inc/arm_math.h **** 
2958:DSP/Inc/arm_math.h ****   /**
2959:DSP/Inc/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
2960:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2961:DSP/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2962:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2963:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2964:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2965:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 56


2966:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2967:DSP/Inc/arm_math.h ****    */
2968:DSP/Inc/arm_math.h ****   void arm_conv_fast_opt_q15(
2969:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
2970:DSP/Inc/arm_math.h ****   uint32_t srcALen,
2971:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
2972:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
2973:DSP/Inc/arm_math.h ****   q15_t * pDst,
2974:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
2975:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
2976:DSP/Inc/arm_math.h **** 
2977:DSP/Inc/arm_math.h **** 
2978:DSP/Inc/arm_math.h ****   /**
2979:DSP/Inc/arm_math.h ****    * @brief Convolution of Q31 sequences.
2980:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
2981:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
2982:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
2983:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
2984:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
2985:DSP/Inc/arm_math.h ****    */
2986:DSP/Inc/arm_math.h ****   void arm_conv_q31(
2987:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
2988:DSP/Inc/arm_math.h ****   uint32_t srcALen,
2989:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
2990:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
2991:DSP/Inc/arm_math.h ****   q31_t * pDst);
2992:DSP/Inc/arm_math.h **** 
2993:DSP/Inc/arm_math.h **** 
2994:DSP/Inc/arm_math.h ****   /**
2995:DSP/Inc/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
2996:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
2997:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
2998:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
2999:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3000:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3001:DSP/Inc/arm_math.h ****    */
3002:DSP/Inc/arm_math.h ****   void arm_conv_fast_q31(
3003:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
3004:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3005:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
3006:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3007:DSP/Inc/arm_math.h ****   q31_t * pDst);
3008:DSP/Inc/arm_math.h **** 
3009:DSP/Inc/arm_math.h **** 
3010:DSP/Inc/arm_math.h ****     /**
3011:DSP/Inc/arm_math.h ****    * @brief Convolution of Q7 sequences.
3012:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3013:DSP/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3014:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3015:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3016:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3017:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3018:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3019:DSP/Inc/arm_math.h ****    */
3020:DSP/Inc/arm_math.h ****   void arm_conv_opt_q7(
3021:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
3022:DSP/Inc/arm_math.h ****   uint32_t srcALen,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 57


3023:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
3024:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3025:DSP/Inc/arm_math.h ****   q7_t * pDst,
3026:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
3027:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
3028:DSP/Inc/arm_math.h **** 
3029:DSP/Inc/arm_math.h **** 
3030:DSP/Inc/arm_math.h ****   /**
3031:DSP/Inc/arm_math.h ****    * @brief Convolution of Q7 sequences.
3032:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3033:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3034:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3035:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3036:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3037:DSP/Inc/arm_math.h ****    */
3038:DSP/Inc/arm_math.h ****   void arm_conv_q7(
3039:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
3040:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3041:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
3042:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3043:DSP/Inc/arm_math.h ****   q7_t * pDst);
3044:DSP/Inc/arm_math.h **** 
3045:DSP/Inc/arm_math.h **** 
3046:DSP/Inc/arm_math.h ****   /**
3047:DSP/Inc/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3048:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3049:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3050:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3051:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3052:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3053:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3054:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3055:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3056:DSP/Inc/arm_math.h ****    */
3057:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_f32(
3058:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
3059:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3060:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
3061:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3062:DSP/Inc/arm_math.h ****   float32_t * pDst,
3063:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3064:DSP/Inc/arm_math.h ****   uint32_t numPoints);
3065:DSP/Inc/arm_math.h **** 
3066:DSP/Inc/arm_math.h **** 
3067:DSP/Inc/arm_math.h ****   /**
3068:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3069:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3070:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3071:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3072:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3073:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3074:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3075:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3076:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3077:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3078:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3079:DSP/Inc/arm_math.h ****    */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 58


3080:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3081:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
3082:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3083:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
3084:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3085:DSP/Inc/arm_math.h ****   q15_t * pDst,
3086:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3087:DSP/Inc/arm_math.h ****   uint32_t numPoints,
3088:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
3089:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
3090:DSP/Inc/arm_math.h **** 
3091:DSP/Inc/arm_math.h **** 
3092:DSP/Inc/arm_math.h ****   /**
3093:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3094:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3095:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3096:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3097:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3098:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3099:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3100:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3101:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3102:DSP/Inc/arm_math.h ****    */
3103:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_q15(
3104:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
3105:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3106:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
3107:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3108:DSP/Inc/arm_math.h ****   q15_t * pDst,
3109:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3110:DSP/Inc/arm_math.h ****   uint32_t numPoints);
3111:DSP/Inc/arm_math.h **** 
3112:DSP/Inc/arm_math.h **** 
3113:DSP/Inc/arm_math.h ****   /**
3114:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3115:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3116:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3117:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3118:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3119:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3120:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3121:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3122:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3123:DSP/Inc/arm_math.h ****    */
3124:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3125:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
3126:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3127:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
3128:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3129:DSP/Inc/arm_math.h ****   q15_t * pDst,
3130:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3131:DSP/Inc/arm_math.h ****   uint32_t numPoints);
3132:DSP/Inc/arm_math.h **** 
3133:DSP/Inc/arm_math.h **** 
3134:DSP/Inc/arm_math.h ****   /**
3135:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3136:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 59


3137:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3138:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3139:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3140:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3141:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3142:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3143:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3144:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3145:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3146:DSP/Inc/arm_math.h ****    */
3147:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3148:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
3149:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3150:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
3151:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3152:DSP/Inc/arm_math.h ****   q15_t * pDst,
3153:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3154:DSP/Inc/arm_math.h ****   uint32_t numPoints,
3155:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
3156:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
3157:DSP/Inc/arm_math.h **** 
3158:DSP/Inc/arm_math.h **** 
3159:DSP/Inc/arm_math.h ****   /**
3160:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3161:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3162:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3163:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3164:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3165:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3166:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3167:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3168:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3169:DSP/Inc/arm_math.h ****    */
3170:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_q31(
3171:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
3172:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3173:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
3174:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3175:DSP/Inc/arm_math.h ****   q31_t * pDst,
3176:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3177:DSP/Inc/arm_math.h ****   uint32_t numPoints);
3178:DSP/Inc/arm_math.h **** 
3179:DSP/Inc/arm_math.h **** 
3180:DSP/Inc/arm_math.h ****   /**
3181:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3182:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3183:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3184:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3185:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3186:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3187:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3188:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3189:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3190:DSP/Inc/arm_math.h ****    */
3191:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3192:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
3193:DSP/Inc/arm_math.h ****   uint32_t srcALen,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 60


3194:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
3195:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3196:DSP/Inc/arm_math.h ****   q31_t * pDst,
3197:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3198:DSP/Inc/arm_math.h ****   uint32_t numPoints);
3199:DSP/Inc/arm_math.h **** 
3200:DSP/Inc/arm_math.h **** 
3201:DSP/Inc/arm_math.h ****   /**
3202:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3203:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3204:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3205:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3206:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3207:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3208:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3209:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3210:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3211:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3212:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3213:DSP/Inc/arm_math.h ****    */
3214:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3215:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
3216:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3217:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
3218:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3219:DSP/Inc/arm_math.h ****   q7_t * pDst,
3220:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3221:DSP/Inc/arm_math.h ****   uint32_t numPoints,
3222:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
3223:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
3224:DSP/Inc/arm_math.h **** 
3225:DSP/Inc/arm_math.h **** 
3226:DSP/Inc/arm_math.h **** /**
3227:DSP/Inc/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3228:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3229:DSP/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3230:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3231:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3232:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3233:DSP/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3234:DSP/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3235:DSP/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3236:DSP/Inc/arm_math.h ****    */
3237:DSP/Inc/arm_math.h ****   arm_status arm_conv_partial_q7(
3238:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
3239:DSP/Inc/arm_math.h ****   uint32_t srcALen,
3240:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
3241:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
3242:DSP/Inc/arm_math.h ****   q7_t * pDst,
3243:DSP/Inc/arm_math.h ****   uint32_t firstIndex,
3244:DSP/Inc/arm_math.h ****   uint32_t numPoints);
3245:DSP/Inc/arm_math.h **** 
3246:DSP/Inc/arm_math.h **** 
3247:DSP/Inc/arm_math.h ****   /**
3248:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3249:DSP/Inc/arm_math.h ****    */
3250:DSP/Inc/arm_math.h ****   typedef struct
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 61


3251:DSP/Inc/arm_math.h ****   {
3252:DSP/Inc/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3253:DSP/Inc/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3254:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3255:DSP/Inc/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3256:DSP/Inc/arm_math.h ****   } arm_fir_decimate_instance_q15;
3257:DSP/Inc/arm_math.h **** 
3258:DSP/Inc/arm_math.h ****   /**
3259:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3260:DSP/Inc/arm_math.h ****    */
3261:DSP/Inc/arm_math.h ****   typedef struct
3262:DSP/Inc/arm_math.h ****   {
3263:DSP/Inc/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3264:DSP/Inc/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3265:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3266:DSP/Inc/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3267:DSP/Inc/arm_math.h ****   } arm_fir_decimate_instance_q31;
3268:DSP/Inc/arm_math.h **** 
3269:DSP/Inc/arm_math.h ****   /**
3270:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3271:DSP/Inc/arm_math.h ****    */
3272:DSP/Inc/arm_math.h ****   typedef struct
3273:DSP/Inc/arm_math.h ****   {
3274:DSP/Inc/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3275:DSP/Inc/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3276:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3277:DSP/Inc/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3278:DSP/Inc/arm_math.h ****   } arm_fir_decimate_instance_f32;
3279:DSP/Inc/arm_math.h **** 
3280:DSP/Inc/arm_math.h **** 
3281:DSP/Inc/arm_math.h ****   /**
3282:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3283:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3284:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3285:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3286:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3287:DSP/Inc/arm_math.h ****    */
3288:DSP/Inc/arm_math.h ****   void arm_fir_decimate_f32(
3289:DSP/Inc/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3290:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3291:DSP/Inc/arm_math.h ****   float32_t * pDst,
3292:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3293:DSP/Inc/arm_math.h **** 
3294:DSP/Inc/arm_math.h **** 
3295:DSP/Inc/arm_math.h ****   /**
3296:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3297:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3298:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3299:DSP/Inc/arm_math.h ****    * @param[in]     M          decimation factor.
3300:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3301:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3302:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3303:DSP/Inc/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3304:DSP/Inc/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3305:DSP/Inc/arm_math.h ****    */
3306:DSP/Inc/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3307:DSP/Inc/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 62


3308:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3309:DSP/Inc/arm_math.h ****   uint8_t M,
3310:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
3311:DSP/Inc/arm_math.h ****   float32_t * pState,
3312:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3313:DSP/Inc/arm_math.h **** 
3314:DSP/Inc/arm_math.h **** 
3315:DSP/Inc/arm_math.h ****   /**
3316:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3317:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3318:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3319:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3320:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3321:DSP/Inc/arm_math.h ****    */
3322:DSP/Inc/arm_math.h ****   void arm_fir_decimate_q15(
3323:DSP/Inc/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3324:DSP/Inc/arm_math.h ****   q15_t * pSrc,
3325:DSP/Inc/arm_math.h ****   q15_t * pDst,
3326:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3327:DSP/Inc/arm_math.h **** 
3328:DSP/Inc/arm_math.h **** 
3329:DSP/Inc/arm_math.h ****   /**
3330:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3331:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3332:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3333:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3334:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3335:DSP/Inc/arm_math.h ****    */
3336:DSP/Inc/arm_math.h ****   void arm_fir_decimate_fast_q15(
3337:DSP/Inc/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3338:DSP/Inc/arm_math.h ****   q15_t * pSrc,
3339:DSP/Inc/arm_math.h ****   q15_t * pDst,
3340:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3341:DSP/Inc/arm_math.h **** 
3342:DSP/Inc/arm_math.h **** 
3343:DSP/Inc/arm_math.h ****   /**
3344:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3345:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3346:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3347:DSP/Inc/arm_math.h ****    * @param[in]     M          decimation factor.
3348:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3349:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3350:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3351:DSP/Inc/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3352:DSP/Inc/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3353:DSP/Inc/arm_math.h ****    */
3354:DSP/Inc/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3355:DSP/Inc/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
3356:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3357:DSP/Inc/arm_math.h ****   uint8_t M,
3358:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
3359:DSP/Inc/arm_math.h ****   q15_t * pState,
3360:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3361:DSP/Inc/arm_math.h **** 
3362:DSP/Inc/arm_math.h **** 
3363:DSP/Inc/arm_math.h ****   /**
3364:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 63


3365:DSP/Inc/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3366:DSP/Inc/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3367:DSP/Inc/arm_math.h ****    * @param[out] pDst  points to the block of output data
3368:DSP/Inc/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3369:DSP/Inc/arm_math.h ****    */
3370:DSP/Inc/arm_math.h ****   void arm_fir_decimate_q31(
3371:DSP/Inc/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
3372:DSP/Inc/arm_math.h ****   q31_t * pSrc,
3373:DSP/Inc/arm_math.h ****   q31_t * pDst,
3374:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3375:DSP/Inc/arm_math.h **** 
3376:DSP/Inc/arm_math.h ****   /**
3377:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3378:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3379:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3380:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3381:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3382:DSP/Inc/arm_math.h ****    */
3383:DSP/Inc/arm_math.h ****   void arm_fir_decimate_fast_q31(
3384:DSP/Inc/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3385:DSP/Inc/arm_math.h ****   q31_t * pSrc,
3386:DSP/Inc/arm_math.h ****   q31_t * pDst,
3387:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3388:DSP/Inc/arm_math.h **** 
3389:DSP/Inc/arm_math.h **** 
3390:DSP/Inc/arm_math.h ****   /**
3391:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3392:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3393:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3394:DSP/Inc/arm_math.h ****    * @param[in]     M          decimation factor.
3395:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3396:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3397:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3398:DSP/Inc/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3399:DSP/Inc/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3400:DSP/Inc/arm_math.h ****    */
3401:DSP/Inc/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3402:DSP/Inc/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3403:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3404:DSP/Inc/arm_math.h ****   uint8_t M,
3405:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
3406:DSP/Inc/arm_math.h ****   q31_t * pState,
3407:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3408:DSP/Inc/arm_math.h **** 
3409:DSP/Inc/arm_math.h **** 
3410:DSP/Inc/arm_math.h ****   /**
3411:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3412:DSP/Inc/arm_math.h ****    */
3413:DSP/Inc/arm_math.h ****   typedef struct
3414:DSP/Inc/arm_math.h ****   {
3415:DSP/Inc/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3416:DSP/Inc/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3417:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3418:DSP/Inc/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3419:DSP/Inc/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3420:DSP/Inc/arm_math.h **** 
3421:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 64


3422:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3423:DSP/Inc/arm_math.h ****    */
3424:DSP/Inc/arm_math.h ****   typedef struct
3425:DSP/Inc/arm_math.h ****   {
3426:DSP/Inc/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3427:DSP/Inc/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3428:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3429:DSP/Inc/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
3430:DSP/Inc/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3431:DSP/Inc/arm_math.h **** 
3432:DSP/Inc/arm_math.h ****   /**
3433:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3434:DSP/Inc/arm_math.h ****    */
3435:DSP/Inc/arm_math.h ****   typedef struct
3436:DSP/Inc/arm_math.h ****   {
3437:DSP/Inc/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3438:DSP/Inc/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3439:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3440:DSP/Inc/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3441:DSP/Inc/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3442:DSP/Inc/arm_math.h **** 
3443:DSP/Inc/arm_math.h **** 
3444:DSP/Inc/arm_math.h ****   /**
3445:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3446:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3447:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3448:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3449:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3450:DSP/Inc/arm_math.h ****    */
3451:DSP/Inc/arm_math.h ****   void arm_fir_interpolate_q15(
3452:DSP/Inc/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3453:DSP/Inc/arm_math.h ****   q15_t * pSrc,
3454:DSP/Inc/arm_math.h ****   q15_t * pDst,
3455:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3456:DSP/Inc/arm_math.h **** 
3457:DSP/Inc/arm_math.h **** 
3458:DSP/Inc/arm_math.h ****   /**
3459:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3460:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3461:DSP/Inc/arm_math.h ****    * @param[in]     L          upsample factor.
3462:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3463:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3464:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3465:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3466:DSP/Inc/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3467:DSP/Inc/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3468:DSP/Inc/arm_math.h ****    */
3469:DSP/Inc/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
3470:DSP/Inc/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3471:DSP/Inc/arm_math.h ****   uint8_t L,
3472:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3473:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
3474:DSP/Inc/arm_math.h ****   q15_t * pState,
3475:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3476:DSP/Inc/arm_math.h **** 
3477:DSP/Inc/arm_math.h **** 
3478:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 65


3479:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3480:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3481:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3482:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3483:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3484:DSP/Inc/arm_math.h ****    */
3485:DSP/Inc/arm_math.h ****   void arm_fir_interpolate_q31(
3486:DSP/Inc/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
3487:DSP/Inc/arm_math.h ****   q31_t * pSrc,
3488:DSP/Inc/arm_math.h ****   q31_t * pDst,
3489:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3490:DSP/Inc/arm_math.h **** 
3491:DSP/Inc/arm_math.h **** 
3492:DSP/Inc/arm_math.h ****   /**
3493:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3494:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3495:DSP/Inc/arm_math.h ****    * @param[in]     L          upsample factor.
3496:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3497:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3498:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3499:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3500:DSP/Inc/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3501:DSP/Inc/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3502:DSP/Inc/arm_math.h ****    */
3503:DSP/Inc/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3504:DSP/Inc/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3505:DSP/Inc/arm_math.h ****   uint8_t L,
3506:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3507:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
3508:DSP/Inc/arm_math.h ****   q31_t * pState,
3509:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3510:DSP/Inc/arm_math.h **** 
3511:DSP/Inc/arm_math.h **** 
3512:DSP/Inc/arm_math.h ****   /**
3513:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
3514:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
3515:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3516:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3517:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3518:DSP/Inc/arm_math.h ****    */
3519:DSP/Inc/arm_math.h ****   void arm_fir_interpolate_f32(
3520:DSP/Inc/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3521:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3522:DSP/Inc/arm_math.h ****   float32_t * pDst,
3523:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3524:DSP/Inc/arm_math.h **** 
3525:DSP/Inc/arm_math.h **** 
3526:DSP/Inc/arm_math.h ****   /**
3527:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3528:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3529:DSP/Inc/arm_math.h ****    * @param[in]     L          upsample factor.
3530:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3531:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3532:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3533:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3534:DSP/Inc/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3535:DSP/Inc/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 66


3536:DSP/Inc/arm_math.h ****    */
3537:DSP/Inc/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3538:DSP/Inc/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3539:DSP/Inc/arm_math.h ****   uint8_t L,
3540:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3541:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
3542:DSP/Inc/arm_math.h ****   float32_t * pState,
3543:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3544:DSP/Inc/arm_math.h **** 
3545:DSP/Inc/arm_math.h **** 
3546:DSP/Inc/arm_math.h ****   /**
3547:DSP/Inc/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3548:DSP/Inc/arm_math.h ****    */
3549:DSP/Inc/arm_math.h ****   typedef struct
3550:DSP/Inc/arm_math.h ****   {
3551:DSP/Inc/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3552:DSP/Inc/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3553:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3554:DSP/Inc/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3555:DSP/Inc/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3556:DSP/Inc/arm_math.h **** 
3557:DSP/Inc/arm_math.h **** 
3558:DSP/Inc/arm_math.h ****   /**
3559:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3560:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3561:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3562:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3563:DSP/Inc/arm_math.h ****    */
3564:DSP/Inc/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3565:DSP/Inc/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3566:DSP/Inc/arm_math.h ****   q31_t * pSrc,
3567:DSP/Inc/arm_math.h ****   q31_t * pDst,
3568:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3569:DSP/Inc/arm_math.h **** 
3570:DSP/Inc/arm_math.h **** 
3571:DSP/Inc/arm_math.h ****   /**
3572:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3573:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3574:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3575:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3576:DSP/Inc/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3577:DSP/Inc/arm_math.h ****    */
3578:DSP/Inc/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
3579:DSP/Inc/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3580:DSP/Inc/arm_math.h ****   uint8_t numStages,
3581:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
3582:DSP/Inc/arm_math.h ****   q63_t * pState,
3583:DSP/Inc/arm_math.h ****   uint8_t postShift);
3584:DSP/Inc/arm_math.h **** 
3585:DSP/Inc/arm_math.h **** 
3586:DSP/Inc/arm_math.h ****   /**
3587:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3588:DSP/Inc/arm_math.h ****    */
3589:DSP/Inc/arm_math.h ****   typedef struct
3590:DSP/Inc/arm_math.h ****   {
3591:DSP/Inc/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3592:DSP/Inc/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 67


3593:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3594:DSP/Inc/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3595:DSP/Inc/arm_math.h **** 
3596:DSP/Inc/arm_math.h ****   /**
3597:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3598:DSP/Inc/arm_math.h ****    */
3599:DSP/Inc/arm_math.h ****   typedef struct
3600:DSP/Inc/arm_math.h ****   {
3601:DSP/Inc/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3602:DSP/Inc/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3603:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3604:DSP/Inc/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3605:DSP/Inc/arm_math.h **** 
3606:DSP/Inc/arm_math.h ****   /**
3607:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3608:DSP/Inc/arm_math.h ****    */
3609:DSP/Inc/arm_math.h ****   typedef struct
3610:DSP/Inc/arm_math.h ****   {
3611:DSP/Inc/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3612:DSP/Inc/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3613:DSP/Inc/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3614:DSP/Inc/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3615:DSP/Inc/arm_math.h **** 
3616:DSP/Inc/arm_math.h **** 
3617:DSP/Inc/arm_math.h ****   /**
3618:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3619:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3620:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3621:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3622:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3623:DSP/Inc/arm_math.h ****    */
3624:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3625:DSP/Inc/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3626:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3627:DSP/Inc/arm_math.h ****   float32_t * pDst,
3628:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3629:DSP/Inc/arm_math.h **** 
3630:DSP/Inc/arm_math.h **** 
3631:DSP/Inc/arm_math.h ****   /**
3632:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3633:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3634:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3635:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3636:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3637:DSP/Inc/arm_math.h ****    */
3638:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3639:DSP/Inc/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3640:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3641:DSP/Inc/arm_math.h ****   float32_t * pDst,
3642:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3643:DSP/Inc/arm_math.h **** 
3644:DSP/Inc/arm_math.h **** 
3645:DSP/Inc/arm_math.h ****   /**
3646:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3647:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3648:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3649:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 68


3650:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3651:DSP/Inc/arm_math.h ****    */
3652:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3653:DSP/Inc/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3654:DSP/Inc/arm_math.h ****   float64_t * pSrc,
3655:DSP/Inc/arm_math.h ****   float64_t * pDst,
3656:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3657:DSP/Inc/arm_math.h **** 
3658:DSP/Inc/arm_math.h **** 
3659:DSP/Inc/arm_math.h ****   /**
3660:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3661:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3662:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3663:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3664:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3665:DSP/Inc/arm_math.h ****    */
3666:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3667:DSP/Inc/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3668:DSP/Inc/arm_math.h ****   uint8_t numStages,
3669:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
3670:DSP/Inc/arm_math.h ****   float32_t * pState);
3671:DSP/Inc/arm_math.h **** 
3672:DSP/Inc/arm_math.h **** 
3673:DSP/Inc/arm_math.h ****   /**
3674:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3675:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3676:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3677:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3678:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3679:DSP/Inc/arm_math.h ****    */
3680:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3681:DSP/Inc/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3682:DSP/Inc/arm_math.h ****   uint8_t numStages,
3683:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
3684:DSP/Inc/arm_math.h ****   float32_t * pState);
3685:DSP/Inc/arm_math.h **** 
3686:DSP/Inc/arm_math.h **** 
3687:DSP/Inc/arm_math.h ****   /**
3688:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3689:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3690:DSP/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3691:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3692:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3693:DSP/Inc/arm_math.h ****    */
3694:DSP/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3695:DSP/Inc/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3696:DSP/Inc/arm_math.h ****   uint8_t numStages,
3697:DSP/Inc/arm_math.h ****   float64_t * pCoeffs,
3698:DSP/Inc/arm_math.h ****   float64_t * pState);
3699:DSP/Inc/arm_math.h **** 
3700:DSP/Inc/arm_math.h **** 
3701:DSP/Inc/arm_math.h ****   /**
3702:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3703:DSP/Inc/arm_math.h ****    */
3704:DSP/Inc/arm_math.h ****   typedef struct
3705:DSP/Inc/arm_math.h ****   {
3706:DSP/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 69


3707:DSP/Inc/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3708:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3709:DSP/Inc/arm_math.h ****   } arm_fir_lattice_instance_q15;
3710:DSP/Inc/arm_math.h **** 
3711:DSP/Inc/arm_math.h ****   /**
3712:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3713:DSP/Inc/arm_math.h ****    */
3714:DSP/Inc/arm_math.h ****   typedef struct
3715:DSP/Inc/arm_math.h ****   {
3716:DSP/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3717:DSP/Inc/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3718:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3719:DSP/Inc/arm_math.h ****   } arm_fir_lattice_instance_q31;
3720:DSP/Inc/arm_math.h **** 
3721:DSP/Inc/arm_math.h ****   /**
3722:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3723:DSP/Inc/arm_math.h ****    */
3724:DSP/Inc/arm_math.h ****   typedef struct
3725:DSP/Inc/arm_math.h ****   {
3726:DSP/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3727:DSP/Inc/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3728:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3729:DSP/Inc/arm_math.h ****   } arm_fir_lattice_instance_f32;
3730:DSP/Inc/arm_math.h **** 
3731:DSP/Inc/arm_math.h **** 
3732:DSP/Inc/arm_math.h ****   /**
3733:DSP/Inc/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3734:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3735:DSP/Inc/arm_math.h ****    * @param[in] numStages  number of filter stages.
3736:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3737:DSP/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3738:DSP/Inc/arm_math.h ****    */
3739:DSP/Inc/arm_math.h ****   void arm_fir_lattice_init_q15(
3740:DSP/Inc/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3741:DSP/Inc/arm_math.h ****   uint16_t numStages,
3742:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
3743:DSP/Inc/arm_math.h ****   q15_t * pState);
3744:DSP/Inc/arm_math.h **** 
3745:DSP/Inc/arm_math.h **** 
3746:DSP/Inc/arm_math.h ****   /**
3747:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3748:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3749:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3750:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3751:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3752:DSP/Inc/arm_math.h ****    */
3753:DSP/Inc/arm_math.h ****   void arm_fir_lattice_q15(
3754:DSP/Inc/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
3755:DSP/Inc/arm_math.h ****   q15_t * pSrc,
3756:DSP/Inc/arm_math.h ****   q15_t * pDst,
3757:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3758:DSP/Inc/arm_math.h **** 
3759:DSP/Inc/arm_math.h **** 
3760:DSP/Inc/arm_math.h ****   /**
3761:DSP/Inc/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3762:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3763:DSP/Inc/arm_math.h ****    * @param[in] numStages  number of filter stages.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 70


3764:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3765:DSP/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3766:DSP/Inc/arm_math.h ****    */
3767:DSP/Inc/arm_math.h ****   void arm_fir_lattice_init_q31(
3768:DSP/Inc/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3769:DSP/Inc/arm_math.h ****   uint16_t numStages,
3770:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
3771:DSP/Inc/arm_math.h ****   q31_t * pState);
3772:DSP/Inc/arm_math.h **** 
3773:DSP/Inc/arm_math.h **** 
3774:DSP/Inc/arm_math.h ****   /**
3775:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3776:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3777:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3778:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3779:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3780:DSP/Inc/arm_math.h ****    */
3781:DSP/Inc/arm_math.h ****   void arm_fir_lattice_q31(
3782:DSP/Inc/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3783:DSP/Inc/arm_math.h ****   q31_t * pSrc,
3784:DSP/Inc/arm_math.h ****   q31_t * pDst,
3785:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3786:DSP/Inc/arm_math.h **** 
3787:DSP/Inc/arm_math.h **** 
3788:DSP/Inc/arm_math.h **** /**
3789:DSP/Inc/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3790:DSP/Inc/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3791:DSP/Inc/arm_math.h ****  * @param[in] numStages  number of filter stages.
3792:DSP/Inc/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3793:DSP/Inc/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3794:DSP/Inc/arm_math.h ****  */
3795:DSP/Inc/arm_math.h ****   void arm_fir_lattice_init_f32(
3796:DSP/Inc/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3797:DSP/Inc/arm_math.h ****   uint16_t numStages,
3798:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
3799:DSP/Inc/arm_math.h ****   float32_t * pState);
3800:DSP/Inc/arm_math.h **** 
3801:DSP/Inc/arm_math.h **** 
3802:DSP/Inc/arm_math.h ****   /**
3803:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3804:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3805:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3806:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3807:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3808:DSP/Inc/arm_math.h ****    */
3809:DSP/Inc/arm_math.h ****   void arm_fir_lattice_f32(
3810:DSP/Inc/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3811:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3812:DSP/Inc/arm_math.h ****   float32_t * pDst,
3813:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3814:DSP/Inc/arm_math.h **** 
3815:DSP/Inc/arm_math.h **** 
3816:DSP/Inc/arm_math.h ****   /**
3817:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3818:DSP/Inc/arm_math.h ****    */
3819:DSP/Inc/arm_math.h ****   typedef struct
3820:DSP/Inc/arm_math.h ****   {
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 71


3821:DSP/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3822:DSP/Inc/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3823:DSP/Inc/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3824:DSP/Inc/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3825:DSP/Inc/arm_math.h ****   } arm_iir_lattice_instance_q15;
3826:DSP/Inc/arm_math.h **** 
3827:DSP/Inc/arm_math.h ****   /**
3828:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
3829:DSP/Inc/arm_math.h ****    */
3830:DSP/Inc/arm_math.h ****   typedef struct
3831:DSP/Inc/arm_math.h ****   {
3832:DSP/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3833:DSP/Inc/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3834:DSP/Inc/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3835:DSP/Inc/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3836:DSP/Inc/arm_math.h ****   } arm_iir_lattice_instance_q31;
3837:DSP/Inc/arm_math.h **** 
3838:DSP/Inc/arm_math.h ****   /**
3839:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3840:DSP/Inc/arm_math.h ****    */
3841:DSP/Inc/arm_math.h ****   typedef struct
3842:DSP/Inc/arm_math.h ****   {
3843:DSP/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3844:DSP/Inc/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3845:DSP/Inc/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3846:DSP/Inc/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3847:DSP/Inc/arm_math.h ****   } arm_iir_lattice_instance_f32;
3848:DSP/Inc/arm_math.h **** 
3849:DSP/Inc/arm_math.h **** 
3850:DSP/Inc/arm_math.h ****   /**
3851:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3852:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3853:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3854:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3855:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3856:DSP/Inc/arm_math.h ****    */
3857:DSP/Inc/arm_math.h ****   void arm_iir_lattice_f32(
3858:DSP/Inc/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3859:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3860:DSP/Inc/arm_math.h ****   float32_t * pDst,
3861:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3862:DSP/Inc/arm_math.h **** 
3863:DSP/Inc/arm_math.h **** 
3864:DSP/Inc/arm_math.h ****   /**
3865:DSP/Inc/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3866:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3867:DSP/Inc/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3868:DSP/Inc/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3869:DSP/Inc/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3870:DSP/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3871:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3872:DSP/Inc/arm_math.h ****    */
3873:DSP/Inc/arm_math.h ****   void arm_iir_lattice_init_f32(
3874:DSP/Inc/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3875:DSP/Inc/arm_math.h ****   uint16_t numStages,
3876:DSP/Inc/arm_math.h ****   float32_t * pkCoeffs,
3877:DSP/Inc/arm_math.h ****   float32_t * pvCoeffs,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 72


3878:DSP/Inc/arm_math.h ****   float32_t * pState,
3879:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3880:DSP/Inc/arm_math.h **** 
3881:DSP/Inc/arm_math.h **** 
3882:DSP/Inc/arm_math.h ****   /**
3883:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3884:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
3885:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3886:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3887:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3888:DSP/Inc/arm_math.h ****    */
3889:DSP/Inc/arm_math.h ****   void arm_iir_lattice_q31(
3890:DSP/Inc/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3891:DSP/Inc/arm_math.h ****   q31_t * pSrc,
3892:DSP/Inc/arm_math.h ****   q31_t * pDst,
3893:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3894:DSP/Inc/arm_math.h **** 
3895:DSP/Inc/arm_math.h **** 
3896:DSP/Inc/arm_math.h ****   /**
3897:DSP/Inc/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3898:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3899:DSP/Inc/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3900:DSP/Inc/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3901:DSP/Inc/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3902:DSP/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3903:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3904:DSP/Inc/arm_math.h ****    */
3905:DSP/Inc/arm_math.h ****   void arm_iir_lattice_init_q31(
3906:DSP/Inc/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3907:DSP/Inc/arm_math.h ****   uint16_t numStages,
3908:DSP/Inc/arm_math.h ****   q31_t * pkCoeffs,
3909:DSP/Inc/arm_math.h ****   q31_t * pvCoeffs,
3910:DSP/Inc/arm_math.h ****   q31_t * pState,
3911:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3912:DSP/Inc/arm_math.h **** 
3913:DSP/Inc/arm_math.h **** 
3914:DSP/Inc/arm_math.h ****   /**
3915:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
3916:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
3917:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3918:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3919:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3920:DSP/Inc/arm_math.h ****    */
3921:DSP/Inc/arm_math.h ****   void arm_iir_lattice_q15(
3922:DSP/Inc/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
3923:DSP/Inc/arm_math.h ****   q15_t * pSrc,
3924:DSP/Inc/arm_math.h ****   q15_t * pDst,
3925:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3926:DSP/Inc/arm_math.h **** 
3927:DSP/Inc/arm_math.h **** 
3928:DSP/Inc/arm_math.h **** /**
3929:DSP/Inc/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
3930:DSP/Inc/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
3931:DSP/Inc/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
3932:DSP/Inc/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
3933:DSP/Inc/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
3934:DSP/Inc/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 73


3935:DSP/Inc/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
3936:DSP/Inc/arm_math.h ****  */
3937:DSP/Inc/arm_math.h ****   void arm_iir_lattice_init_q15(
3938:DSP/Inc/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
3939:DSP/Inc/arm_math.h ****   uint16_t numStages,
3940:DSP/Inc/arm_math.h ****   q15_t * pkCoeffs,
3941:DSP/Inc/arm_math.h ****   q15_t * pvCoeffs,
3942:DSP/Inc/arm_math.h ****   q15_t * pState,
3943:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3944:DSP/Inc/arm_math.h **** 
3945:DSP/Inc/arm_math.h **** 
3946:DSP/Inc/arm_math.h ****   /**
3947:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
3948:DSP/Inc/arm_math.h ****    */
3949:DSP/Inc/arm_math.h ****   typedef struct
3950:DSP/Inc/arm_math.h ****   {
3951:DSP/Inc/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
3952:DSP/Inc/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
3953:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
3954:DSP/Inc/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
3955:DSP/Inc/arm_math.h ****   } arm_lms_instance_f32;
3956:DSP/Inc/arm_math.h **** 
3957:DSP/Inc/arm_math.h **** 
3958:DSP/Inc/arm_math.h ****   /**
3959:DSP/Inc/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
3960:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
3961:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3962:DSP/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
3963:DSP/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
3964:DSP/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
3965:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3966:DSP/Inc/arm_math.h ****    */
3967:DSP/Inc/arm_math.h ****   void arm_lms_f32(
3968:DSP/Inc/arm_math.h ****   const arm_lms_instance_f32 * S,
3969:DSP/Inc/arm_math.h ****   float32_t * pSrc,
3970:DSP/Inc/arm_math.h ****   float32_t * pRef,
3971:DSP/Inc/arm_math.h ****   float32_t * pOut,
3972:DSP/Inc/arm_math.h ****   float32_t * pErr,
3973:DSP/Inc/arm_math.h ****   uint32_t blockSize);
3974:DSP/Inc/arm_math.h **** 
3975:DSP/Inc/arm_math.h **** 
3976:DSP/Inc/arm_math.h ****   /**
3977:DSP/Inc/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
3978:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
3979:DSP/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
3980:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
3981:DSP/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
3982:DSP/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
3983:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3984:DSP/Inc/arm_math.h ****    */
3985:DSP/Inc/arm_math.h ****   void arm_lms_init_f32(
3986:DSP/Inc/arm_math.h ****   arm_lms_instance_f32 * S,
3987:DSP/Inc/arm_math.h ****   uint16_t numTaps,
3988:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
3989:DSP/Inc/arm_math.h ****   float32_t * pState,
3990:DSP/Inc/arm_math.h ****   float32_t mu,
3991:DSP/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 74


3992:DSP/Inc/arm_math.h **** 
3993:DSP/Inc/arm_math.h **** 
3994:DSP/Inc/arm_math.h ****   /**
3995:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
3996:DSP/Inc/arm_math.h ****    */
3997:DSP/Inc/arm_math.h ****   typedef struct
3998:DSP/Inc/arm_math.h ****   {
3999:DSP/Inc/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4000:DSP/Inc/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4001:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4002:DSP/Inc/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4003:DSP/Inc/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4004:DSP/Inc/arm_math.h ****   } arm_lms_instance_q15;
4005:DSP/Inc/arm_math.h **** 
4006:DSP/Inc/arm_math.h **** 
4007:DSP/Inc/arm_math.h ****   /**
4008:DSP/Inc/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4009:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4010:DSP/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4011:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4012:DSP/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.
4013:DSP/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4014:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4015:DSP/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4016:DSP/Inc/arm_math.h ****    */
4017:DSP/Inc/arm_math.h ****   void arm_lms_init_q15(
4018:DSP/Inc/arm_math.h ****   arm_lms_instance_q15 * S,
4019:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4020:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
4021:DSP/Inc/arm_math.h ****   q15_t * pState,
4022:DSP/Inc/arm_math.h ****   q15_t mu,
4023:DSP/Inc/arm_math.h ****   uint32_t blockSize,
4024:DSP/Inc/arm_math.h ****   uint32_t postShift);
4025:DSP/Inc/arm_math.h **** 
4026:DSP/Inc/arm_math.h **** 
4027:DSP/Inc/arm_math.h ****   /**
4028:DSP/Inc/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4029:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4030:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4031:DSP/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4032:DSP/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4033:DSP/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4034:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4035:DSP/Inc/arm_math.h ****    */
4036:DSP/Inc/arm_math.h ****   void arm_lms_q15(
4037:DSP/Inc/arm_math.h ****   const arm_lms_instance_q15 * S,
4038:DSP/Inc/arm_math.h ****   q15_t * pSrc,
4039:DSP/Inc/arm_math.h ****   q15_t * pRef,
4040:DSP/Inc/arm_math.h ****   q15_t * pOut,
4041:DSP/Inc/arm_math.h ****   q15_t * pErr,
4042:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4043:DSP/Inc/arm_math.h **** 
4044:DSP/Inc/arm_math.h **** 
4045:DSP/Inc/arm_math.h ****   /**
4046:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4047:DSP/Inc/arm_math.h ****    */
4048:DSP/Inc/arm_math.h ****   typedef struct
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 75


4049:DSP/Inc/arm_math.h ****   {
4050:DSP/Inc/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4051:DSP/Inc/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4052:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4053:DSP/Inc/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4054:DSP/Inc/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4055:DSP/Inc/arm_math.h ****   } arm_lms_instance_q31;
4056:DSP/Inc/arm_math.h **** 
4057:DSP/Inc/arm_math.h **** 
4058:DSP/Inc/arm_math.h ****   /**
4059:DSP/Inc/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4060:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4061:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4062:DSP/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4063:DSP/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4064:DSP/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4065:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4066:DSP/Inc/arm_math.h ****    */
4067:DSP/Inc/arm_math.h ****   void arm_lms_q31(
4068:DSP/Inc/arm_math.h ****   const arm_lms_instance_q31 * S,
4069:DSP/Inc/arm_math.h ****   q31_t * pSrc,
4070:DSP/Inc/arm_math.h ****   q31_t * pRef,
4071:DSP/Inc/arm_math.h ****   q31_t * pOut,
4072:DSP/Inc/arm_math.h ****   q31_t * pErr,
4073:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4074:DSP/Inc/arm_math.h **** 
4075:DSP/Inc/arm_math.h **** 
4076:DSP/Inc/arm_math.h ****   /**
4077:DSP/Inc/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4078:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4079:DSP/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4080:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4081:DSP/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4082:DSP/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4083:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4084:DSP/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4085:DSP/Inc/arm_math.h ****    */
4086:DSP/Inc/arm_math.h ****   void arm_lms_init_q31(
4087:DSP/Inc/arm_math.h ****   arm_lms_instance_q31 * S,
4088:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4089:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
4090:DSP/Inc/arm_math.h ****   q31_t * pState,
4091:DSP/Inc/arm_math.h ****   q31_t mu,
4092:DSP/Inc/arm_math.h ****   uint32_t blockSize,
4093:DSP/Inc/arm_math.h ****   uint32_t postShift);
4094:DSP/Inc/arm_math.h **** 
4095:DSP/Inc/arm_math.h **** 
4096:DSP/Inc/arm_math.h ****   /**
4097:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4098:DSP/Inc/arm_math.h ****    */
4099:DSP/Inc/arm_math.h ****   typedef struct
4100:DSP/Inc/arm_math.h ****   {
4101:DSP/Inc/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4102:DSP/Inc/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4103:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4104:DSP/Inc/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4105:DSP/Inc/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 76


4106:DSP/Inc/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4107:DSP/Inc/arm_math.h ****   } arm_lms_norm_instance_f32;
4108:DSP/Inc/arm_math.h **** 
4109:DSP/Inc/arm_math.h **** 
4110:DSP/Inc/arm_math.h ****   /**
4111:DSP/Inc/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4112:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
4113:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4114:DSP/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4115:DSP/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4116:DSP/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4117:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4118:DSP/Inc/arm_math.h ****    */
4119:DSP/Inc/arm_math.h ****   void arm_lms_norm_f32(
4120:DSP/Inc/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4121:DSP/Inc/arm_math.h ****   float32_t * pSrc,
4122:DSP/Inc/arm_math.h ****   float32_t * pRef,
4123:DSP/Inc/arm_math.h ****   float32_t * pOut,
4124:DSP/Inc/arm_math.h ****   float32_t * pErr,
4125:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4126:DSP/Inc/arm_math.h **** 
4127:DSP/Inc/arm_math.h **** 
4128:DSP/Inc/arm_math.h ****   /**
4129:DSP/Inc/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4130:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4131:DSP/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4132:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4133:DSP/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4134:DSP/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4135:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4136:DSP/Inc/arm_math.h ****    */
4137:DSP/Inc/arm_math.h ****   void arm_lms_norm_init_f32(
4138:DSP/Inc/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4139:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4140:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
4141:DSP/Inc/arm_math.h ****   float32_t * pState,
4142:DSP/Inc/arm_math.h ****   float32_t mu,
4143:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4144:DSP/Inc/arm_math.h **** 
4145:DSP/Inc/arm_math.h **** 
4146:DSP/Inc/arm_math.h ****   /**
4147:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4148:DSP/Inc/arm_math.h ****    */
4149:DSP/Inc/arm_math.h ****   typedef struct
4150:DSP/Inc/arm_math.h ****   {
4151:DSP/Inc/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4152:DSP/Inc/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4153:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4154:DSP/Inc/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4155:DSP/Inc/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4156:DSP/Inc/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4157:DSP/Inc/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4158:DSP/Inc/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4159:DSP/Inc/arm_math.h ****   } arm_lms_norm_instance_q31;
4160:DSP/Inc/arm_math.h **** 
4161:DSP/Inc/arm_math.h **** 
4162:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 77


4163:DSP/Inc/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4164:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4165:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4166:DSP/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4167:DSP/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4168:DSP/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4169:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4170:DSP/Inc/arm_math.h ****    */
4171:DSP/Inc/arm_math.h ****   void arm_lms_norm_q31(
4172:DSP/Inc/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4173:DSP/Inc/arm_math.h ****   q31_t * pSrc,
4174:DSP/Inc/arm_math.h ****   q31_t * pRef,
4175:DSP/Inc/arm_math.h ****   q31_t * pOut,
4176:DSP/Inc/arm_math.h ****   q31_t * pErr,
4177:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4178:DSP/Inc/arm_math.h **** 
4179:DSP/Inc/arm_math.h **** 
4180:DSP/Inc/arm_math.h ****   /**
4181:DSP/Inc/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4182:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4183:DSP/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4184:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4185:DSP/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4186:DSP/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4187:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4188:DSP/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4189:DSP/Inc/arm_math.h ****    */
4190:DSP/Inc/arm_math.h ****   void arm_lms_norm_init_q31(
4191:DSP/Inc/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4192:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4193:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
4194:DSP/Inc/arm_math.h ****   q31_t * pState,
4195:DSP/Inc/arm_math.h ****   q31_t mu,
4196:DSP/Inc/arm_math.h ****   uint32_t blockSize,
4197:DSP/Inc/arm_math.h ****   uint8_t postShift);
4198:DSP/Inc/arm_math.h **** 
4199:DSP/Inc/arm_math.h **** 
4200:DSP/Inc/arm_math.h ****   /**
4201:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4202:DSP/Inc/arm_math.h ****    */
4203:DSP/Inc/arm_math.h ****   typedef struct
4204:DSP/Inc/arm_math.h ****   {
4205:DSP/Inc/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
4206:DSP/Inc/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4207:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4208:DSP/Inc/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4209:DSP/Inc/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4210:DSP/Inc/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
4211:DSP/Inc/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4212:DSP/Inc/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4213:DSP/Inc/arm_math.h ****   } arm_lms_norm_instance_q15;
4214:DSP/Inc/arm_math.h **** 
4215:DSP/Inc/arm_math.h **** 
4216:DSP/Inc/arm_math.h ****   /**
4217:DSP/Inc/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4218:DSP/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4219:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 78


4220:DSP/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4221:DSP/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4222:DSP/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4223:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4224:DSP/Inc/arm_math.h ****    */
4225:DSP/Inc/arm_math.h ****   void arm_lms_norm_q15(
4226:DSP/Inc/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4227:DSP/Inc/arm_math.h ****   q15_t * pSrc,
4228:DSP/Inc/arm_math.h ****   q15_t * pRef,
4229:DSP/Inc/arm_math.h ****   q15_t * pOut,
4230:DSP/Inc/arm_math.h ****   q15_t * pErr,
4231:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4232:DSP/Inc/arm_math.h **** 
4233:DSP/Inc/arm_math.h **** 
4234:DSP/Inc/arm_math.h ****   /**
4235:DSP/Inc/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4236:DSP/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4237:DSP/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4238:DSP/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4239:DSP/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4240:DSP/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4241:DSP/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4242:DSP/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4243:DSP/Inc/arm_math.h ****    */
4244:DSP/Inc/arm_math.h ****   void arm_lms_norm_init_q15(
4245:DSP/Inc/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4246:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4247:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
4248:DSP/Inc/arm_math.h ****   q15_t * pState,
4249:DSP/Inc/arm_math.h ****   q15_t mu,
4250:DSP/Inc/arm_math.h ****   uint32_t blockSize,
4251:DSP/Inc/arm_math.h ****   uint8_t postShift);
4252:DSP/Inc/arm_math.h **** 
4253:DSP/Inc/arm_math.h **** 
4254:DSP/Inc/arm_math.h ****   /**
4255:DSP/Inc/arm_math.h ****    * @brief Correlation of floating-point sequences.
4256:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4257:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4258:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4259:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4260:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4261:DSP/Inc/arm_math.h ****    */
4262:DSP/Inc/arm_math.h ****   void arm_correlate_f32(
4263:DSP/Inc/arm_math.h ****   float32_t * pSrcA,
4264:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4265:DSP/Inc/arm_math.h ****   float32_t * pSrcB,
4266:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4267:DSP/Inc/arm_math.h ****   float32_t * pDst);
4268:DSP/Inc/arm_math.h **** 
4269:DSP/Inc/arm_math.h **** 
4270:DSP/Inc/arm_math.h ****    /**
4271:DSP/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences
4272:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4273:DSP/Inc/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4274:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4275:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4276:DSP/Inc/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 79


4277:DSP/Inc/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4278:DSP/Inc/arm_math.h ****    */
4279:DSP/Inc/arm_math.h ****   void arm_correlate_opt_q15(
4280:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
4281:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4282:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
4283:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4284:DSP/Inc/arm_math.h ****   q15_t * pDst,
4285:DSP/Inc/arm_math.h ****   q15_t * pScratch);
4286:DSP/Inc/arm_math.h **** 
4287:DSP/Inc/arm_math.h **** 
4288:DSP/Inc/arm_math.h ****   /**
4289:DSP/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences.
4290:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4291:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4292:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4293:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4294:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4295:DSP/Inc/arm_math.h ****    */
4296:DSP/Inc/arm_math.h **** 
4297:DSP/Inc/arm_math.h ****   void arm_correlate_q15(
4298:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
4299:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4300:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
4301:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4302:DSP/Inc/arm_math.h ****   q15_t * pDst);
4303:DSP/Inc/arm_math.h **** 
4304:DSP/Inc/arm_math.h **** 
4305:DSP/Inc/arm_math.h ****   /**
4306:DSP/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4307:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4308:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4309:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4310:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4311:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4312:DSP/Inc/arm_math.h ****    */
4313:DSP/Inc/arm_math.h **** 
4314:DSP/Inc/arm_math.h ****   void arm_correlate_fast_q15(
4315:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
4316:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4317:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
4318:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4319:DSP/Inc/arm_math.h ****   q15_t * pDst);
4320:DSP/Inc/arm_math.h **** 
4321:DSP/Inc/arm_math.h **** 
4322:DSP/Inc/arm_math.h ****   /**
4323:DSP/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4324:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4325:DSP/Inc/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4326:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4327:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4328:DSP/Inc/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4329:DSP/Inc/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4330:DSP/Inc/arm_math.h ****    */
4331:DSP/Inc/arm_math.h ****   void arm_correlate_fast_opt_q15(
4332:DSP/Inc/arm_math.h ****   q15_t * pSrcA,
4333:DSP/Inc/arm_math.h ****   uint32_t srcALen,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 80


4334:DSP/Inc/arm_math.h ****   q15_t * pSrcB,
4335:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4336:DSP/Inc/arm_math.h ****   q15_t * pDst,
4337:DSP/Inc/arm_math.h ****   q15_t * pScratch);
4338:DSP/Inc/arm_math.h **** 
4339:DSP/Inc/arm_math.h **** 
4340:DSP/Inc/arm_math.h ****   /**
4341:DSP/Inc/arm_math.h ****    * @brief Correlation of Q31 sequences.
4342:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4343:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4344:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4345:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4346:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4347:DSP/Inc/arm_math.h ****    */
4348:DSP/Inc/arm_math.h ****   void arm_correlate_q31(
4349:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
4350:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4351:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
4352:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4353:DSP/Inc/arm_math.h ****   q31_t * pDst);
4354:DSP/Inc/arm_math.h **** 
4355:DSP/Inc/arm_math.h **** 
4356:DSP/Inc/arm_math.h ****   /**
4357:DSP/Inc/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4358:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4359:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4360:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4361:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4362:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4363:DSP/Inc/arm_math.h ****    */
4364:DSP/Inc/arm_math.h ****   void arm_correlate_fast_q31(
4365:DSP/Inc/arm_math.h ****   q31_t * pSrcA,
4366:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4367:DSP/Inc/arm_math.h ****   q31_t * pSrcB,
4368:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4369:DSP/Inc/arm_math.h ****   q31_t * pDst);
4370:DSP/Inc/arm_math.h **** 
4371:DSP/Inc/arm_math.h **** 
4372:DSP/Inc/arm_math.h ****  /**
4373:DSP/Inc/arm_math.h ****    * @brief Correlation of Q7 sequences.
4374:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4375:DSP/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4376:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
4377:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4378:DSP/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4379:DSP/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4380:DSP/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4381:DSP/Inc/arm_math.h ****    */
4382:DSP/Inc/arm_math.h ****   void arm_correlate_opt_q7(
4383:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
4384:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4385:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
4386:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4387:DSP/Inc/arm_math.h ****   q7_t * pDst,
4388:DSP/Inc/arm_math.h ****   q15_t * pScratch1,
4389:DSP/Inc/arm_math.h ****   q15_t * pScratch2);
4390:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 81


4391:DSP/Inc/arm_math.h **** 
4392:DSP/Inc/arm_math.h ****   /**
4393:DSP/Inc/arm_math.h ****    * @brief Correlation of Q7 sequences.
4394:DSP/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4395:DSP/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4396:DSP/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4397:DSP/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4398:DSP/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4399:DSP/Inc/arm_math.h ****    */
4400:DSP/Inc/arm_math.h ****   void arm_correlate_q7(
4401:DSP/Inc/arm_math.h ****   q7_t * pSrcA,
4402:DSP/Inc/arm_math.h ****   uint32_t srcALen,
4403:DSP/Inc/arm_math.h ****   q7_t * pSrcB,
4404:DSP/Inc/arm_math.h ****   uint32_t srcBLen,
4405:DSP/Inc/arm_math.h ****   q7_t * pDst);
4406:DSP/Inc/arm_math.h **** 
4407:DSP/Inc/arm_math.h **** 
4408:DSP/Inc/arm_math.h ****   /**
4409:DSP/Inc/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4410:DSP/Inc/arm_math.h ****    */
4411:DSP/Inc/arm_math.h ****   typedef struct
4412:DSP/Inc/arm_math.h ****   {
4413:DSP/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4414:DSP/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4415:DSP/Inc/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4416:DSP/Inc/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4417:DSP/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4418:DSP/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4419:DSP/Inc/arm_math.h ****   } arm_fir_sparse_instance_f32;
4420:DSP/Inc/arm_math.h **** 
4421:DSP/Inc/arm_math.h ****   /**
4422:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4423:DSP/Inc/arm_math.h ****    */
4424:DSP/Inc/arm_math.h ****   typedef struct
4425:DSP/Inc/arm_math.h ****   {
4426:DSP/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4427:DSP/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4428:DSP/Inc/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4429:DSP/Inc/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4430:DSP/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4431:DSP/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4432:DSP/Inc/arm_math.h ****   } arm_fir_sparse_instance_q31;
4433:DSP/Inc/arm_math.h **** 
4434:DSP/Inc/arm_math.h ****   /**
4435:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4436:DSP/Inc/arm_math.h ****    */
4437:DSP/Inc/arm_math.h ****   typedef struct
4438:DSP/Inc/arm_math.h ****   {
4439:DSP/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4440:DSP/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4441:DSP/Inc/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4442:DSP/Inc/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4443:DSP/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4444:DSP/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4445:DSP/Inc/arm_math.h ****   } arm_fir_sparse_instance_q15;
4446:DSP/Inc/arm_math.h **** 
4447:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 82


4448:DSP/Inc/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4449:DSP/Inc/arm_math.h ****    */
4450:DSP/Inc/arm_math.h ****   typedef struct
4451:DSP/Inc/arm_math.h ****   {
4452:DSP/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4453:DSP/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4454:DSP/Inc/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
4455:DSP/Inc/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
4456:DSP/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4457:DSP/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4458:DSP/Inc/arm_math.h ****   } arm_fir_sparse_instance_q7;
4459:DSP/Inc/arm_math.h **** 
4460:DSP/Inc/arm_math.h **** 
4461:DSP/Inc/arm_math.h ****   /**
4462:DSP/Inc/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4463:DSP/Inc/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4464:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4465:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
4466:DSP/Inc/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4467:DSP/Inc/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4468:DSP/Inc/arm_math.h ****    */
4469:DSP/Inc/arm_math.h ****   void arm_fir_sparse_f32(
4470:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4471:DSP/Inc/arm_math.h ****   float32_t * pSrc,
4472:DSP/Inc/arm_math.h ****   float32_t * pDst,
4473:DSP/Inc/arm_math.h ****   float32_t * pScratchIn,
4474:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4475:DSP/Inc/arm_math.h **** 
4476:DSP/Inc/arm_math.h **** 
4477:DSP/Inc/arm_math.h ****   /**
4478:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4479:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4480:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4481:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4482:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4483:DSP/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4484:DSP/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4485:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4486:DSP/Inc/arm_math.h ****    */
4487:DSP/Inc/arm_math.h ****   void arm_fir_sparse_init_f32(
4488:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4489:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4490:DSP/Inc/arm_math.h ****   float32_t * pCoeffs,
4491:DSP/Inc/arm_math.h ****   float32_t * pState,
4492:DSP/Inc/arm_math.h ****   int32_t * pTapDelay,
4493:DSP/Inc/arm_math.h ****   uint16_t maxDelay,
4494:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4495:DSP/Inc/arm_math.h **** 
4496:DSP/Inc/arm_math.h **** 
4497:DSP/Inc/arm_math.h ****   /**
4498:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4499:DSP/Inc/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4500:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4501:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
4502:DSP/Inc/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4503:DSP/Inc/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4504:DSP/Inc/arm_math.h ****    */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 83


4505:DSP/Inc/arm_math.h ****   void arm_fir_sparse_q31(
4506:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4507:DSP/Inc/arm_math.h ****   q31_t * pSrc,
4508:DSP/Inc/arm_math.h ****   q31_t * pDst,
4509:DSP/Inc/arm_math.h ****   q31_t * pScratchIn,
4510:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4511:DSP/Inc/arm_math.h **** 
4512:DSP/Inc/arm_math.h **** 
4513:DSP/Inc/arm_math.h ****   /**
4514:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4515:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4516:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4517:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4518:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4519:DSP/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4520:DSP/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4521:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4522:DSP/Inc/arm_math.h ****    */
4523:DSP/Inc/arm_math.h ****   void arm_fir_sparse_init_q31(
4524:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4525:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4526:DSP/Inc/arm_math.h ****   q31_t * pCoeffs,
4527:DSP/Inc/arm_math.h ****   q31_t * pState,
4528:DSP/Inc/arm_math.h ****   int32_t * pTapDelay,
4529:DSP/Inc/arm_math.h ****   uint16_t maxDelay,
4530:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4531:DSP/Inc/arm_math.h **** 
4532:DSP/Inc/arm_math.h **** 
4533:DSP/Inc/arm_math.h ****   /**
4534:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4535:DSP/Inc/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4536:DSP/Inc/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4537:DSP/Inc/arm_math.h ****    * @param[out] pDst         points to the block of output data
4538:DSP/Inc/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4539:DSP/Inc/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4540:DSP/Inc/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4541:DSP/Inc/arm_math.h ****    */
4542:DSP/Inc/arm_math.h ****   void arm_fir_sparse_q15(
4543:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4544:DSP/Inc/arm_math.h ****   q15_t * pSrc,
4545:DSP/Inc/arm_math.h ****   q15_t * pDst,
4546:DSP/Inc/arm_math.h ****   q15_t * pScratchIn,
4547:DSP/Inc/arm_math.h ****   q31_t * pScratchOut,
4548:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4549:DSP/Inc/arm_math.h **** 
4550:DSP/Inc/arm_math.h **** 
4551:DSP/Inc/arm_math.h ****   /**
4552:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
4553:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4554:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4555:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4556:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4557:DSP/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4558:DSP/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4559:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4560:DSP/Inc/arm_math.h ****    */
4561:DSP/Inc/arm_math.h ****   void arm_fir_sparse_init_q15(
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 84


4562:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4563:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4564:DSP/Inc/arm_math.h ****   q15_t * pCoeffs,
4565:DSP/Inc/arm_math.h ****   q15_t * pState,
4566:DSP/Inc/arm_math.h ****   int32_t * pTapDelay,
4567:DSP/Inc/arm_math.h ****   uint16_t maxDelay,
4568:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4569:DSP/Inc/arm_math.h **** 
4570:DSP/Inc/arm_math.h **** 
4571:DSP/Inc/arm_math.h ****   /**
4572:DSP/Inc/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4573:DSP/Inc/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4574:DSP/Inc/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4575:DSP/Inc/arm_math.h ****    * @param[out] pDst         points to the block of output data
4576:DSP/Inc/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4577:DSP/Inc/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4578:DSP/Inc/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4579:DSP/Inc/arm_math.h ****    */
4580:DSP/Inc/arm_math.h ****   void arm_fir_sparse_q7(
4581:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4582:DSP/Inc/arm_math.h ****   q7_t * pSrc,
4583:DSP/Inc/arm_math.h ****   q7_t * pDst,
4584:DSP/Inc/arm_math.h ****   q7_t * pScratchIn,
4585:DSP/Inc/arm_math.h ****   q31_t * pScratchOut,
4586:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4587:DSP/Inc/arm_math.h **** 
4588:DSP/Inc/arm_math.h **** 
4589:DSP/Inc/arm_math.h ****   /**
4590:DSP/Inc/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4591:DSP/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4592:DSP/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4593:DSP/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4594:DSP/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4595:DSP/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4596:DSP/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4597:DSP/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4598:DSP/Inc/arm_math.h ****    */
4599:DSP/Inc/arm_math.h ****   void arm_fir_sparse_init_q7(
4600:DSP/Inc/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4601:DSP/Inc/arm_math.h ****   uint16_t numTaps,
4602:DSP/Inc/arm_math.h ****   q7_t * pCoeffs,
4603:DSP/Inc/arm_math.h ****   q7_t * pState,
4604:DSP/Inc/arm_math.h ****   int32_t * pTapDelay,
4605:DSP/Inc/arm_math.h ****   uint16_t maxDelay,
4606:DSP/Inc/arm_math.h ****   uint32_t blockSize);
4607:DSP/Inc/arm_math.h **** 
4608:DSP/Inc/arm_math.h **** 
4609:DSP/Inc/arm_math.h ****   /**
4610:DSP/Inc/arm_math.h ****    * @brief  Floating-point sin_cos function.
4611:DSP/Inc/arm_math.h ****    * @param[in]  theta   input value in degrees
4612:DSP/Inc/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4613:DSP/Inc/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4614:DSP/Inc/arm_math.h ****    */
4615:DSP/Inc/arm_math.h ****   void arm_sin_cos_f32(
4616:DSP/Inc/arm_math.h ****   float32_t theta,
4617:DSP/Inc/arm_math.h ****   float32_t * pSinVal,
4618:DSP/Inc/arm_math.h ****   float32_t * pCosVal);
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 85


4619:DSP/Inc/arm_math.h **** 
4620:DSP/Inc/arm_math.h **** 
4621:DSP/Inc/arm_math.h ****   /**
4622:DSP/Inc/arm_math.h ****    * @brief  Q31 sin_cos function.
4623:DSP/Inc/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4624:DSP/Inc/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4625:DSP/Inc/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
4626:DSP/Inc/arm_math.h ****    */
4627:DSP/Inc/arm_math.h ****   void arm_sin_cos_q31(
4628:DSP/Inc/arm_math.h ****   q31_t theta,
4629:DSP/Inc/arm_math.h ****   q31_t * pSinVal,
4630:DSP/Inc/arm_math.h ****   q31_t * pCosVal);
4631:DSP/Inc/arm_math.h **** 
4632:DSP/Inc/arm_math.h **** 
4633:DSP/Inc/arm_math.h ****   /**
4634:DSP/Inc/arm_math.h ****    * @brief  Floating-point complex conjugate.
4635:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4636:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
4637:DSP/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4638:DSP/Inc/arm_math.h ****    */
4639:DSP/Inc/arm_math.h ****   void arm_cmplx_conj_f32(
4640:DSP/Inc/arm_math.h ****   float32_t * pSrc,
4641:DSP/Inc/arm_math.h ****   float32_t * pDst,
4642:DSP/Inc/arm_math.h ****   uint32_t numSamples);
4643:DSP/Inc/arm_math.h **** 
4644:DSP/Inc/arm_math.h ****   /**
4645:DSP/Inc/arm_math.h ****    * @brief  Q31 complex conjugate.
4646:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4647:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
4648:DSP/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4649:DSP/Inc/arm_math.h ****    */
4650:DSP/Inc/arm_math.h ****   void arm_cmplx_conj_q31(
4651:DSP/Inc/arm_math.h ****   q31_t * pSrc,
4652:DSP/Inc/arm_math.h ****   q31_t * pDst,
4653:DSP/Inc/arm_math.h ****   uint32_t numSamples);
4654:DSP/Inc/arm_math.h **** 
4655:DSP/Inc/arm_math.h **** 
4656:DSP/Inc/arm_math.h ****   /**
4657:DSP/Inc/arm_math.h ****    * @brief  Q15 complex conjugate.
4658:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4659:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
4660:DSP/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4661:DSP/Inc/arm_math.h ****    */
4662:DSP/Inc/arm_math.h ****   void arm_cmplx_conj_q15(
4663:DSP/Inc/arm_math.h ****   q15_t * pSrc,
4664:DSP/Inc/arm_math.h ****   q15_t * pDst,
4665:DSP/Inc/arm_math.h ****   uint32_t numSamples);
4666:DSP/Inc/arm_math.h **** 
4667:DSP/Inc/arm_math.h **** 
4668:DSP/Inc/arm_math.h ****   /**
4669:DSP/Inc/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4670:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4671:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the real output vector
4672:DSP/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4673:DSP/Inc/arm_math.h ****    */
4674:DSP/Inc/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4675:DSP/Inc/arm_math.h ****   float32_t * pSrc,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 86


4676:DSP/Inc/arm_math.h ****   float32_t * pDst,
4677:DSP/Inc/arm_math.h ****   uint32_t numSamples);
4678:DSP/Inc/arm_math.h **** 
4679:DSP/Inc/arm_math.h **** 
4680:DSP/Inc/arm_math.h ****   /**
4681:DSP/Inc/arm_math.h ****    * @brief  Q31 complex magnitude squared
4682:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4683:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the real output vector
4684:DSP/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4685:DSP/Inc/arm_math.h ****    */
4686:DSP/Inc/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4687:DSP/Inc/arm_math.h ****   q31_t * pSrc,
4688:DSP/Inc/arm_math.h ****   q31_t * pDst,
4689:DSP/Inc/arm_math.h ****   uint32_t numSamples);
4690:DSP/Inc/arm_math.h **** 
4691:DSP/Inc/arm_math.h **** 
4692:DSP/Inc/arm_math.h ****   /**
4693:DSP/Inc/arm_math.h ****    * @brief  Q15 complex magnitude squared
4694:DSP/Inc/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4695:DSP/Inc/arm_math.h ****    * @param[out] pDst        points to the real output vector
4696:DSP/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4697:DSP/Inc/arm_math.h ****    */
4698:DSP/Inc/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4699:DSP/Inc/arm_math.h ****   q15_t * pSrc,
4700:DSP/Inc/arm_math.h ****   q15_t * pDst,
4701:DSP/Inc/arm_math.h ****   uint32_t numSamples);
4702:DSP/Inc/arm_math.h **** 
4703:DSP/Inc/arm_math.h **** 
4704:DSP/Inc/arm_math.h ****  /**
4705:DSP/Inc/arm_math.h ****    * @ingroup groupController
4706:DSP/Inc/arm_math.h ****    */
4707:DSP/Inc/arm_math.h **** 
4708:DSP/Inc/arm_math.h ****   /**
4709:DSP/Inc/arm_math.h ****    * @defgroup PID PID Motor Control
4710:DSP/Inc/arm_math.h ****    *
4711:DSP/Inc/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
4712:DSP/Inc/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4713:DSP/Inc/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4714:DSP/Inc/arm_math.h ****    *
4715:DSP/Inc/arm_math.h ****    * This set of functions implements (PID) controllers
4716:DSP/Inc/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4717:DSP/Inc/arm_math.h ****    * of data and each call to the function returns a single processed value.
4718:DSP/Inc/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
4719:DSP/Inc/arm_math.h ****    * is the input sample value. The functions return the output value.
4720:DSP/Inc/arm_math.h ****    *
4721:DSP/Inc/arm_math.h ****    * \par Algorithm:
4722:DSP/Inc/arm_math.h ****    * <pre>
4723:DSP/Inc/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
4724:DSP/Inc/arm_math.h ****    *    A0 = Kp + Ki + Kd
4725:DSP/Inc/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4726:DSP/Inc/arm_math.h ****    *    A2 = Kd  </pre>
4727:DSP/Inc/arm_math.h ****    *
4728:DSP/Inc/arm_math.h ****    * \par
4729:DSP/Inc/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4730:DSP/Inc/arm_math.h ****    *
4731:DSP/Inc/arm_math.h ****    * \par
4732:DSP/Inc/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 87


4733:DSP/Inc/arm_math.h ****    *
4734:DSP/Inc/arm_math.h ****    * \par
4735:DSP/Inc/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4736:DSP/Inc/arm_math.h ****    * the measured output and the reference input.
4737:DSP/Inc/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4738:DSP/Inc/arm_math.h ****    * The proportional value determines the reaction to the current error,
4739:DSP/Inc/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
4740:DSP/Inc/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
4741:DSP/Inc/arm_math.h ****    *
4742:DSP/Inc/arm_math.h ****    * \par Instance Structure
4743:DSP/Inc/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4744:DSP/Inc/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4745:DSP/Inc/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4746:DSP/Inc/arm_math.h ****    *
4747:DSP/Inc/arm_math.h ****    * \par Reset Functions
4748:DSP/Inc/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4749:DSP/Inc/arm_math.h ****    *
4750:DSP/Inc/arm_math.h ****    * \par Initialization Functions
4751:DSP/Inc/arm_math.h ****    * There is also an associated initialization function for each data type.
4752:DSP/Inc/arm_math.h ****    * The initialization function performs the following operations:
4753:DSP/Inc/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4754:DSP/Inc/arm_math.h ****    * - Zeros out the values in the state buffer.
4755:DSP/Inc/arm_math.h ****    *
4756:DSP/Inc/arm_math.h ****    * \par
4757:DSP/Inc/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4758:DSP/Inc/arm_math.h ****    *
4759:DSP/Inc/arm_math.h ****    * \par Fixed-Point Behavior
4760:DSP/Inc/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4761:DSP/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4762:DSP/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4763:DSP/Inc/arm_math.h ****    */
4764:DSP/Inc/arm_math.h **** 
4765:DSP/Inc/arm_math.h ****   /**
4766:DSP/Inc/arm_math.h ****    * @addtogroup PID
4767:DSP/Inc/arm_math.h ****    * @{
4768:DSP/Inc/arm_math.h ****    */
4769:DSP/Inc/arm_math.h **** 
4770:DSP/Inc/arm_math.h ****   /**
4771:DSP/Inc/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4772:DSP/Inc/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4773:DSP/Inc/arm_math.h ****    * @param[in]     in  input sample to process
4774:DSP/Inc/arm_math.h ****    * @return out processed output sample.
4775:DSP/Inc/arm_math.h ****    */
4776:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_pid_f32(
4777:DSP/Inc/arm_math.h ****   arm_pid_instance_f32 * S,
4778:DSP/Inc/arm_math.h ****   float32_t in)
4779:DSP/Inc/arm_math.h ****   {
4780:DSP/Inc/arm_math.h ****     float32_t out;
4781:DSP/Inc/arm_math.h **** 
4782:DSP/Inc/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4783:DSP/Inc/arm_math.h ****     out = (S->A0 * in) +
4784:DSP/Inc/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4785:DSP/Inc/arm_math.h **** 
4786:DSP/Inc/arm_math.h ****     /* Update state */
4787:DSP/Inc/arm_math.h ****     S->state[1] = S->state[0];
4788:DSP/Inc/arm_math.h ****     S->state[0] = in;
4789:DSP/Inc/arm_math.h ****     S->state[2] = out;
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 88


4790:DSP/Inc/arm_math.h **** 
4791:DSP/Inc/arm_math.h ****     /* return to application */
4792:DSP/Inc/arm_math.h ****     return (out);
4793:DSP/Inc/arm_math.h **** 
4794:DSP/Inc/arm_math.h ****   }
4795:DSP/Inc/arm_math.h **** 
4796:DSP/Inc/arm_math.h ****   /**
4797:DSP/Inc/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
4798:DSP/Inc/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4799:DSP/Inc/arm_math.h ****    * @param[in]     in  input sample to process
4800:DSP/Inc/arm_math.h ****    * @return out processed output sample.
4801:DSP/Inc/arm_math.h ****    *
4802:DSP/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4803:DSP/Inc/arm_math.h ****    * \par
4804:DSP/Inc/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4805:DSP/Inc/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4806:DSP/Inc/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4807:DSP/Inc/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4808:DSP/Inc/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4809:DSP/Inc/arm_math.h ****    */
4810:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_pid_q31(
4811:DSP/Inc/arm_math.h ****   arm_pid_instance_q31 * S,
4812:DSP/Inc/arm_math.h ****   q31_t in)
4813:DSP/Inc/arm_math.h ****   {
4814:DSP/Inc/arm_math.h ****     q63_t acc;
4815:DSP/Inc/arm_math.h ****     q31_t out;
4816:DSP/Inc/arm_math.h **** 
4817:DSP/Inc/arm_math.h ****     /* acc = A0 * x[n]  */
4818:DSP/Inc/arm_math.h ****     acc = (q63_t) S->A0 * in;
4819:DSP/Inc/arm_math.h **** 
4820:DSP/Inc/arm_math.h ****     /* acc += A1 * x[n-1] */
4821:DSP/Inc/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4822:DSP/Inc/arm_math.h **** 
4823:DSP/Inc/arm_math.h ****     /* acc += A2 * x[n-2]  */
4824:DSP/Inc/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
4825:DSP/Inc/arm_math.h **** 
4826:DSP/Inc/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4827:DSP/Inc/arm_math.h ****     out = (q31_t) (acc >> 31U);
4828:DSP/Inc/arm_math.h **** 
4829:DSP/Inc/arm_math.h ****     /* out += y[n-1] */
4830:DSP/Inc/arm_math.h ****     out += S->state[2];
4831:DSP/Inc/arm_math.h **** 
4832:DSP/Inc/arm_math.h ****     /* Update state */
4833:DSP/Inc/arm_math.h ****     S->state[1] = S->state[0];
4834:DSP/Inc/arm_math.h ****     S->state[0] = in;
4835:DSP/Inc/arm_math.h ****     S->state[2] = out;
4836:DSP/Inc/arm_math.h **** 
4837:DSP/Inc/arm_math.h ****     /* return to application */
4838:DSP/Inc/arm_math.h ****     return (out);
4839:DSP/Inc/arm_math.h ****   }
4840:DSP/Inc/arm_math.h **** 
4841:DSP/Inc/arm_math.h **** 
4842:DSP/Inc/arm_math.h ****   /**
4843:DSP/Inc/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4844:DSP/Inc/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4845:DSP/Inc/arm_math.h ****    * @param[in]     in  input sample to process
4846:DSP/Inc/arm_math.h ****    * @return out processed output sample.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 89


4847:DSP/Inc/arm_math.h ****    *
4848:DSP/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4849:DSP/Inc/arm_math.h ****    * \par
4850:DSP/Inc/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4851:DSP/Inc/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4852:DSP/Inc/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4853:DSP/Inc/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
4854:DSP/Inc/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
4855:DSP/Inc/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4856:DSP/Inc/arm_math.h ****    */
4857:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_pid_q15(
4858:DSP/Inc/arm_math.h ****   arm_pid_instance_q15 * S,
4859:DSP/Inc/arm_math.h ****   q15_t in)
4860:DSP/Inc/arm_math.h ****   {
4861:DSP/Inc/arm_math.h ****     q63_t acc;
4862:DSP/Inc/arm_math.h ****     q15_t out;
4863:DSP/Inc/arm_math.h **** 
4864:DSP/Inc/arm_math.h **** #if defined (ARM_MATH_DSP)
4865:DSP/Inc/arm_math.h ****     __SIMD32_TYPE *vstate;
4866:DSP/Inc/arm_math.h **** 
4867:DSP/Inc/arm_math.h ****     /* Implementation of PID controller */
4868:DSP/Inc/arm_math.h **** 
4869:DSP/Inc/arm_math.h ****     /* acc = A0 * x[n]  */
4870:DSP/Inc/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4871:DSP/Inc/arm_math.h **** 
4872:DSP/Inc/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4873:DSP/Inc/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4874:DSP/Inc/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4875:DSP/Inc/arm_math.h **** #else
4876:DSP/Inc/arm_math.h ****     /* acc = A0 * x[n]  */
4877:DSP/Inc/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4878:DSP/Inc/arm_math.h **** 
4879:DSP/Inc/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4880:DSP/Inc/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4881:DSP/Inc/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
4882:DSP/Inc/arm_math.h **** #endif
4883:DSP/Inc/arm_math.h **** 
4884:DSP/Inc/arm_math.h ****     /* acc += y[n-1] */
4885:DSP/Inc/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4886:DSP/Inc/arm_math.h **** 
4887:DSP/Inc/arm_math.h ****     /* saturate the output */
4888:DSP/Inc/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4889:DSP/Inc/arm_math.h **** 
4890:DSP/Inc/arm_math.h ****     /* Update state */
4891:DSP/Inc/arm_math.h ****     S->state[1] = S->state[0];
4892:DSP/Inc/arm_math.h ****     S->state[0] = in;
4893:DSP/Inc/arm_math.h ****     S->state[2] = out;
4894:DSP/Inc/arm_math.h **** 
4895:DSP/Inc/arm_math.h ****     /* return to application */
4896:DSP/Inc/arm_math.h ****     return (out);
4897:DSP/Inc/arm_math.h ****   }
4898:DSP/Inc/arm_math.h **** 
4899:DSP/Inc/arm_math.h ****   /**
4900:DSP/Inc/arm_math.h ****    * @} end of PID group
4901:DSP/Inc/arm_math.h ****    */
4902:DSP/Inc/arm_math.h **** 
4903:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 90


4904:DSP/Inc/arm_math.h ****   /**
4905:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix inverse.
4906:DSP/Inc/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4907:DSP/Inc/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4908:DSP/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4909:DSP/Inc/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4910:DSP/Inc/arm_math.h ****    */
4911:DSP/Inc/arm_math.h ****   arm_status arm_mat_inverse_f32(
4912:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f32 * src,
4913:DSP/Inc/arm_math.h ****   arm_matrix_instance_f32 * dst);
4914:DSP/Inc/arm_math.h **** 
4915:DSP/Inc/arm_math.h **** 
4916:DSP/Inc/arm_math.h ****   /**
4917:DSP/Inc/arm_math.h ****    * @brief Floating-point matrix inverse.
4918:DSP/Inc/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4919:DSP/Inc/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4920:DSP/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4921:DSP/Inc/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4922:DSP/Inc/arm_math.h ****    */
4923:DSP/Inc/arm_math.h ****   arm_status arm_mat_inverse_f64(
4924:DSP/Inc/arm_math.h ****   const arm_matrix_instance_f64 * src,
4925:DSP/Inc/arm_math.h ****   arm_matrix_instance_f64 * dst);
4926:DSP/Inc/arm_math.h **** 
4927:DSP/Inc/arm_math.h **** 
4928:DSP/Inc/arm_math.h **** 
4929:DSP/Inc/arm_math.h ****   /**
4930:DSP/Inc/arm_math.h ****    * @ingroup groupController
4931:DSP/Inc/arm_math.h ****    */
4932:DSP/Inc/arm_math.h **** 
4933:DSP/Inc/arm_math.h ****   /**
4934:DSP/Inc/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
4935:DSP/Inc/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
4936:DSP/Inc/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
4937:DSP/Inc/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
4938:DSP/Inc/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
4939:DSP/Inc/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
4940:DSP/Inc/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
4941:DSP/Inc/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
4942:DSP/Inc/arm_math.h ****    *
4943:DSP/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
4944:DSP/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
4945:DSP/Inc/arm_math.h ****    * \par Algorithm
4946:DSP/Inc/arm_math.h ****    * \image html clarkeFormula.gif
4947:DSP/Inc/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
4948:DSP/Inc/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
4949:DSP/Inc/arm_math.h ****    * \par Fixed-Point Behavior
4950:DSP/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
4951:DSP/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
4952:DSP/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4953:DSP/Inc/arm_math.h ****    */
4954:DSP/Inc/arm_math.h **** 
4955:DSP/Inc/arm_math.h ****   /**
4956:DSP/Inc/arm_math.h ****    * @addtogroup clarke
4957:DSP/Inc/arm_math.h ****    * @{
4958:DSP/Inc/arm_math.h ****    */
4959:DSP/Inc/arm_math.h **** 
4960:DSP/Inc/arm_math.h ****   /**
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 91


4961:DSP/Inc/arm_math.h ****    *
4962:DSP/Inc/arm_math.h ****    * @brief  Floating-point Clarke transform
4963:DSP/Inc/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
4964:DSP/Inc/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
4965:DSP/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
4966:DSP/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
4967:DSP/Inc/arm_math.h ****    */
4968:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_f32(
4969:DSP/Inc/arm_math.h ****   float32_t Ia,
4970:DSP/Inc/arm_math.h ****   float32_t Ib,
4971:DSP/Inc/arm_math.h ****   float32_t * pIalpha,
4972:DSP/Inc/arm_math.h ****   float32_t * pIbeta)
4973:DSP/Inc/arm_math.h ****   {
4974:DSP/Inc/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
4975:DSP/Inc/arm_math.h ****     *pIalpha = Ia;
4976:DSP/Inc/arm_math.h **** 
4977:DSP/Inc/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
4978:DSP/Inc/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
4979:DSP/Inc/arm_math.h ****   }
4980:DSP/Inc/arm_math.h **** 
4981:DSP/Inc/arm_math.h **** 
4982:DSP/Inc/arm_math.h ****   /**
4983:DSP/Inc/arm_math.h ****    * @brief  Clarke transform for Q31 version
4984:DSP/Inc/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
4985:DSP/Inc/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
4986:DSP/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
4987:DSP/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
4988:DSP/Inc/arm_math.h ****    *
4989:DSP/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4990:DSP/Inc/arm_math.h ****    * \par
4991:DSP/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
4992:DSP/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
4993:DSP/Inc/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
4994:DSP/Inc/arm_math.h ****    */
4995:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_clarke_q31(
4996:DSP/Inc/arm_math.h ****   q31_t Ia,
4997:DSP/Inc/arm_math.h ****   q31_t Ib,
4998:DSP/Inc/arm_math.h ****   q31_t * pIalpha,
4999:DSP/Inc/arm_math.h ****   q31_t * pIbeta)
5000:DSP/Inc/arm_math.h ****   {
5001:DSP/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5002:DSP/Inc/arm_math.h **** 
5003:DSP/Inc/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
5004:DSP/Inc/arm_math.h ****     *pIalpha = Ia;
5005:DSP/Inc/arm_math.h **** 
5006:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5007:DSP/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
5008:DSP/Inc/arm_math.h **** 
5009:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5010:DSP/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
5011:DSP/Inc/arm_math.h **** 
5012:DSP/Inc/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
5013:DSP/Inc/arm_math.h ****     *pIbeta = __QADD(product1, product2);
5014:DSP/Inc/arm_math.h ****   }
5015:DSP/Inc/arm_math.h **** 
5016:DSP/Inc/arm_math.h ****   /**
5017:DSP/Inc/arm_math.h ****    * @} end of clarke group
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 92


5018:DSP/Inc/arm_math.h ****    */
5019:DSP/Inc/arm_math.h **** 
5020:DSP/Inc/arm_math.h ****   /**
5021:DSP/Inc/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5022:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
5023:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
5024:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5025:DSP/Inc/arm_math.h ****    */
5026:DSP/Inc/arm_math.h ****   void arm_q7_to_q31(
5027:DSP/Inc/arm_math.h ****   q7_t * pSrc,
5028:DSP/Inc/arm_math.h ****   q31_t * pDst,
5029:DSP/Inc/arm_math.h ****   uint32_t blockSize);
5030:DSP/Inc/arm_math.h **** 
5031:DSP/Inc/arm_math.h **** 
5032:DSP/Inc/arm_math.h **** 
5033:DSP/Inc/arm_math.h ****   /**
5034:DSP/Inc/arm_math.h ****    * @ingroup groupController
5035:DSP/Inc/arm_math.h ****    */
5036:DSP/Inc/arm_math.h **** 
5037:DSP/Inc/arm_math.h ****   /**
5038:DSP/Inc/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5039:DSP/Inc/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5040:DSP/Inc/arm_math.h ****    *
5041:DSP/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5042:DSP/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5043:DSP/Inc/arm_math.h ****    * \par Algorithm
5044:DSP/Inc/arm_math.h ****    * \image html clarkeInvFormula.gif
5045:DSP/Inc/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5046:DSP/Inc/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5047:DSP/Inc/arm_math.h ****    * \par Fixed-Point Behavior
5048:DSP/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5049:DSP/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5050:DSP/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5051:DSP/Inc/arm_math.h ****    */
5052:DSP/Inc/arm_math.h **** 
5053:DSP/Inc/arm_math.h ****   /**
5054:DSP/Inc/arm_math.h ****    * @addtogroup inv_clarke
5055:DSP/Inc/arm_math.h ****    * @{
5056:DSP/Inc/arm_math.h ****    */
5057:DSP/Inc/arm_math.h **** 
5058:DSP/Inc/arm_math.h ****    /**
5059:DSP/Inc/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5060:DSP/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5061:DSP/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5062:DSP/Inc/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5063:DSP/Inc/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5064:DSP/Inc/arm_math.h ****    */
5065:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_f32(
5066:DSP/Inc/arm_math.h ****   float32_t Ialpha,
5067:DSP/Inc/arm_math.h ****   float32_t Ibeta,
5068:DSP/Inc/arm_math.h ****   float32_t * pIa,
5069:DSP/Inc/arm_math.h ****   float32_t * pIb)
5070:DSP/Inc/arm_math.h ****   {
5071:DSP/Inc/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5072:DSP/Inc/arm_math.h ****     *pIa = Ialpha;
5073:DSP/Inc/arm_math.h **** 
5074:DSP/Inc/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 93


5075:DSP/Inc/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5076:DSP/Inc/arm_math.h ****   }
5077:DSP/Inc/arm_math.h **** 
5078:DSP/Inc/arm_math.h **** 
5079:DSP/Inc/arm_math.h ****   /**
5080:DSP/Inc/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5081:DSP/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5082:DSP/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5083:DSP/Inc/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5084:DSP/Inc/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5085:DSP/Inc/arm_math.h ****    *
5086:DSP/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5087:DSP/Inc/arm_math.h ****    * \par
5088:DSP/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5089:DSP/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5090:DSP/Inc/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5091:DSP/Inc/arm_math.h ****    */
5092:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_clarke_q31(
5093:DSP/Inc/arm_math.h ****   q31_t Ialpha,
5094:DSP/Inc/arm_math.h ****   q31_t Ibeta,
5095:DSP/Inc/arm_math.h ****   q31_t * pIa,
5096:DSP/Inc/arm_math.h ****   q31_t * pIb)
5097:DSP/Inc/arm_math.h ****   {
5098:DSP/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5099:DSP/Inc/arm_math.h **** 
5100:DSP/Inc/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5101:DSP/Inc/arm_math.h ****     *pIa = Ialpha;
5102:DSP/Inc/arm_math.h **** 
5103:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5104:DSP/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5105:DSP/Inc/arm_math.h **** 
5106:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5107:DSP/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5108:DSP/Inc/arm_math.h **** 
5109:DSP/Inc/arm_math.h ****     /* pIb is calculated by subtracting the products */
5110:DSP/Inc/arm_math.h ****     *pIb = __QSUB(product2, product1);
5111:DSP/Inc/arm_math.h ****   }
5112:DSP/Inc/arm_math.h **** 
5113:DSP/Inc/arm_math.h ****   /**
5114:DSP/Inc/arm_math.h ****    * @} end of inv_clarke group
5115:DSP/Inc/arm_math.h ****    */
5116:DSP/Inc/arm_math.h **** 
5117:DSP/Inc/arm_math.h ****   /**
5118:DSP/Inc/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5119:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
5120:DSP/Inc/arm_math.h ****    * @param[out] pDst       output pointer
5121:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5122:DSP/Inc/arm_math.h ****    */
5123:DSP/Inc/arm_math.h ****   void arm_q7_to_q15(
5124:DSP/Inc/arm_math.h ****   q7_t * pSrc,
5125:DSP/Inc/arm_math.h ****   q15_t * pDst,
5126:DSP/Inc/arm_math.h ****   uint32_t blockSize);
5127:DSP/Inc/arm_math.h **** 
5128:DSP/Inc/arm_math.h **** 
5129:DSP/Inc/arm_math.h **** 
5130:DSP/Inc/arm_math.h ****   /**
5131:DSP/Inc/arm_math.h ****    * @ingroup groupController
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 94


5132:DSP/Inc/arm_math.h ****    */
5133:DSP/Inc/arm_math.h **** 
5134:DSP/Inc/arm_math.h ****   /**
5135:DSP/Inc/arm_math.h ****    * @defgroup park Vector Park Transform
5136:DSP/Inc/arm_math.h ****    *
5137:DSP/Inc/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5138:DSP/Inc/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5139:DSP/Inc/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
5140:DSP/Inc/arm_math.h ****    * the stator vector current and rotor flux vector.
5141:DSP/Inc/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5142:DSP/Inc/arm_math.h ****    * current vector and the relationship from the two reference frames:
5143:DSP/Inc/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5144:DSP/Inc/arm_math.h ****    *
5145:DSP/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5146:DSP/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5147:DSP/Inc/arm_math.h ****    * \par Algorithm
5148:DSP/Inc/arm_math.h ****    * \image html parkFormula.gif
5149:DSP/Inc/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5150:DSP/Inc/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
5151:DSP/Inc/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5152:DSP/Inc/arm_math.h ****    * \par Fixed-Point Behavior
5153:DSP/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5154:DSP/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5155:DSP/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5156:DSP/Inc/arm_math.h ****    */
5157:DSP/Inc/arm_math.h **** 
5158:DSP/Inc/arm_math.h ****   /**
5159:DSP/Inc/arm_math.h ****    * @addtogroup park
5160:DSP/Inc/arm_math.h ****    * @{
5161:DSP/Inc/arm_math.h ****    */
5162:DSP/Inc/arm_math.h **** 
5163:DSP/Inc/arm_math.h ****   /**
5164:DSP/Inc/arm_math.h ****    * @brief Floating-point Park transform
5165:DSP/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5166:DSP/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5167:DSP/Inc/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
5168:DSP/Inc/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5169:DSP/Inc/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5170:DSP/Inc/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5171:DSP/Inc/arm_math.h ****    *
5172:DSP/Inc/arm_math.h ****    * The function implements the forward Park transform.
5173:DSP/Inc/arm_math.h ****    *
5174:DSP/Inc/arm_math.h ****    */
5175:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_f32(
5176:DSP/Inc/arm_math.h ****   float32_t Ialpha,
5177:DSP/Inc/arm_math.h ****   float32_t Ibeta,
5178:DSP/Inc/arm_math.h ****   float32_t * pId,
5179:DSP/Inc/arm_math.h ****   float32_t * pIq,
5180:DSP/Inc/arm_math.h ****   float32_t sinVal,
5181:DSP/Inc/arm_math.h ****   float32_t cosVal)
5182:DSP/Inc/arm_math.h ****   {
5183:DSP/Inc/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5184:DSP/Inc/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5185:DSP/Inc/arm_math.h **** 
5186:DSP/Inc/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5187:DSP/Inc/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5188:DSP/Inc/arm_math.h ****   }
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 95


5189:DSP/Inc/arm_math.h **** 
5190:DSP/Inc/arm_math.h **** 
5191:DSP/Inc/arm_math.h ****   /**
5192:DSP/Inc/arm_math.h ****    * @brief  Park transform for Q31 version
5193:DSP/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5194:DSP/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5195:DSP/Inc/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5196:DSP/Inc/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
5197:DSP/Inc/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5198:DSP/Inc/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5199:DSP/Inc/arm_math.h ****    *
5200:DSP/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5201:DSP/Inc/arm_math.h ****    * \par
5202:DSP/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5203:DSP/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5204:DSP/Inc/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5205:DSP/Inc/arm_math.h ****    */
5206:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_park_q31(
5207:DSP/Inc/arm_math.h ****   q31_t Ialpha,
5208:DSP/Inc/arm_math.h ****   q31_t Ibeta,
5209:DSP/Inc/arm_math.h ****   q31_t * pId,
5210:DSP/Inc/arm_math.h ****   q31_t * pIq,
5211:DSP/Inc/arm_math.h ****   q31_t sinVal,
5212:DSP/Inc/arm_math.h ****   q31_t cosVal)
5213:DSP/Inc/arm_math.h ****   {
5214:DSP/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5215:DSP/Inc/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5216:DSP/Inc/arm_math.h **** 
5217:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5218:DSP/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
5219:DSP/Inc/arm_math.h **** 
5220:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
5221:DSP/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
5222:DSP/Inc/arm_math.h **** 
5223:DSP/Inc/arm_math.h **** 
5224:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
5225:DSP/Inc/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
5226:DSP/Inc/arm_math.h **** 
5227:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5228:DSP/Inc/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
5229:DSP/Inc/arm_math.h **** 
5230:DSP/Inc/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5231:DSP/Inc/arm_math.h ****     *pId = __QADD(product1, product2);
5232:DSP/Inc/arm_math.h **** 
5233:DSP/Inc/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5234:DSP/Inc/arm_math.h ****     *pIq = __QSUB(product4, product3);
5235:DSP/Inc/arm_math.h ****   }
5236:DSP/Inc/arm_math.h **** 
5237:DSP/Inc/arm_math.h ****   /**
5238:DSP/Inc/arm_math.h ****    * @} end of park group
5239:DSP/Inc/arm_math.h ****    */
5240:DSP/Inc/arm_math.h **** 
5241:DSP/Inc/arm_math.h ****   /**
5242:DSP/Inc/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5243:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       is input pointer
5244:DSP/Inc/arm_math.h ****    * @param[out] pDst       is output pointer
5245:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 96


5246:DSP/Inc/arm_math.h ****    */
5247:DSP/Inc/arm_math.h ****   void arm_q7_to_float(
5248:DSP/Inc/arm_math.h ****   q7_t * pSrc,
5249:DSP/Inc/arm_math.h ****   float32_t * pDst,
5250:DSP/Inc/arm_math.h ****   uint32_t blockSize);
5251:DSP/Inc/arm_math.h **** 
5252:DSP/Inc/arm_math.h **** 
5253:DSP/Inc/arm_math.h ****   /**
5254:DSP/Inc/arm_math.h ****    * @ingroup groupController
5255:DSP/Inc/arm_math.h ****    */
5256:DSP/Inc/arm_math.h **** 
5257:DSP/Inc/arm_math.h ****   /**
5258:DSP/Inc/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5259:DSP/Inc/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5260:DSP/Inc/arm_math.h ****    *
5261:DSP/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5262:DSP/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5263:DSP/Inc/arm_math.h ****    * \par Algorithm
5264:DSP/Inc/arm_math.h ****    * \image html parkInvFormula.gif
5265:DSP/Inc/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5266:DSP/Inc/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5267:DSP/Inc/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5268:DSP/Inc/arm_math.h ****    * \par Fixed-Point Behavior
5269:DSP/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5270:DSP/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5271:DSP/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5272:DSP/Inc/arm_math.h ****    */
5273:DSP/Inc/arm_math.h **** 
5274:DSP/Inc/arm_math.h ****   /**
5275:DSP/Inc/arm_math.h ****    * @addtogroup inv_park
5276:DSP/Inc/arm_math.h ****    * @{
5277:DSP/Inc/arm_math.h ****    */
5278:DSP/Inc/arm_math.h **** 
5279:DSP/Inc/arm_math.h ****    /**
5280:DSP/Inc/arm_math.h ****    * @brief  Floating-point Inverse Park transform
5281:DSP/Inc/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5282:DSP/Inc/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5283:DSP/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5284:DSP/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5285:DSP/Inc/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5286:DSP/Inc/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5287:DSP/Inc/arm_math.h ****    */
5288:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_f32(
5289:DSP/Inc/arm_math.h ****   float32_t Id,
5290:DSP/Inc/arm_math.h ****   float32_t Iq,
5291:DSP/Inc/arm_math.h ****   float32_t * pIalpha,
5292:DSP/Inc/arm_math.h ****   float32_t * pIbeta,
5293:DSP/Inc/arm_math.h ****   float32_t sinVal,
5294:DSP/Inc/arm_math.h ****   float32_t cosVal)
5295:DSP/Inc/arm_math.h ****   {
5296:DSP/Inc/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5297:DSP/Inc/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5298:DSP/Inc/arm_math.h **** 
5299:DSP/Inc/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5300:DSP/Inc/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5301:DSP/Inc/arm_math.h ****   }
5302:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 97


5303:DSP/Inc/arm_math.h **** 
5304:DSP/Inc/arm_math.h ****   /**
5305:DSP/Inc/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5306:DSP/Inc/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5307:DSP/Inc/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5308:DSP/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5309:DSP/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5310:DSP/Inc/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5311:DSP/Inc/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5312:DSP/Inc/arm_math.h ****    *
5313:DSP/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5314:DSP/Inc/arm_math.h ****    * \par
5315:DSP/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5316:DSP/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5317:DSP/Inc/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5318:DSP/Inc/arm_math.h ****    */
5319:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_inv_park_q31(
5320:DSP/Inc/arm_math.h ****   q31_t Id,
5321:DSP/Inc/arm_math.h ****   q31_t Iq,
5322:DSP/Inc/arm_math.h ****   q31_t * pIalpha,
5323:DSP/Inc/arm_math.h ****   q31_t * pIbeta,
5324:DSP/Inc/arm_math.h ****   q31_t sinVal,
5325:DSP/Inc/arm_math.h ****   q31_t cosVal)
5326:DSP/Inc/arm_math.h ****   {
5327:DSP/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5328:DSP/Inc/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5329:DSP/Inc/arm_math.h **** 
5330:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5331:DSP/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
5332:DSP/Inc/arm_math.h **** 
5333:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5334:DSP/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
5335:DSP/Inc/arm_math.h **** 
5336:DSP/Inc/arm_math.h **** 
5337:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
5338:DSP/Inc/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
5339:DSP/Inc/arm_math.h **** 
5340:DSP/Inc/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5341:DSP/Inc/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
5342:DSP/Inc/arm_math.h **** 
5343:DSP/Inc/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5344:DSP/Inc/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
5345:DSP/Inc/arm_math.h **** 
5346:DSP/Inc/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5347:DSP/Inc/arm_math.h ****     *pIbeta = __QADD(product4, product3);
5348:DSP/Inc/arm_math.h ****   }
5349:DSP/Inc/arm_math.h **** 
5350:DSP/Inc/arm_math.h ****   /**
5351:DSP/Inc/arm_math.h ****    * @} end of Inverse park group
5352:DSP/Inc/arm_math.h ****    */
5353:DSP/Inc/arm_math.h **** 
5354:DSP/Inc/arm_math.h **** 
5355:DSP/Inc/arm_math.h ****   /**
5356:DSP/Inc/arm_math.h ****    * @brief  Converts the elements of the Q31 vector to floating-point vector.
5357:DSP/Inc/arm_math.h ****    * @param[in]  pSrc       is input pointer
5358:DSP/Inc/arm_math.h ****    * @param[out] pDst       is output pointer
5359:DSP/Inc/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 98


5360:DSP/Inc/arm_math.h ****    */
5361:DSP/Inc/arm_math.h ****   void arm_q31_to_float(
5362:DSP/Inc/arm_math.h ****   q31_t * pSrc,
5363:DSP/Inc/arm_math.h ****   float32_t * pDst,
5364:DSP/Inc/arm_math.h ****   uint32_t blockSize);
5365:DSP/Inc/arm_math.h **** 
5366:DSP/Inc/arm_math.h ****   /**
5367:DSP/Inc/arm_math.h ****    * @ingroup groupInterpolation
5368:DSP/Inc/arm_math.h ****    */
5369:DSP/Inc/arm_math.h **** 
5370:DSP/Inc/arm_math.h ****   /**
5371:DSP/Inc/arm_math.h ****    * @defgroup LinearInterpolate Linear Interpolation
5372:DSP/Inc/arm_math.h ****    *
5373:DSP/Inc/arm_math.h ****    * Linear interpolation is a method of curve fitting using linear polynomials.
5374:DSP/Inc/arm_math.h ****    * Linear interpolation works by effectively drawing a straight line between two neighboring samp
5375:DSP/Inc/arm_math.h ****    *
5376:DSP/Inc/arm_math.h ****    * \par
5377:DSP/Inc/arm_math.h ****    * \image html LinearInterp.gif "Linear interpolation"
5378:DSP/Inc/arm_math.h ****    *
5379:DSP/Inc/arm_math.h ****    * \par
5380:DSP/Inc/arm_math.h ****    * A  Linear Interpolate function calculates an output value(y), for the input(x)
5381:DSP/Inc/arm_math.h ****    * using linear interpolation of the input values x0, x1( nearest input values) and the output va
5382:DSP/Inc/arm_math.h ****    *
5383:DSP/Inc/arm_math.h ****    * \par Algorithm:
5384:DSP/Inc/arm_math.h ****    * <pre>
5385:DSP/Inc/arm_math.h ****    *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
5386:DSP/Inc/arm_math.h ****    *       where x0, x1 are nearest values of input x
5387:DSP/Inc/arm_math.h ****    *             y0, y1 are nearest values to output y
5388:DSP/Inc/arm_math.h ****    * </pre>
5389:DSP/Inc/arm_math.h ****    *
5390:DSP/Inc/arm_math.h ****    * \par
5391:DSP/Inc/arm_math.h ****    * This set of functions implements Linear interpolation process
5392:DSP/Inc/arm_math.h ****    * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
5393:DSP/Inc/arm_math.h ****    * sample of data and each call to the function returns a single processed value.
5394:DSP/Inc/arm_math.h ****    * <code>S</code> points to an instance of the Linear Interpolate function data structure.
5395:DSP/Inc/arm_math.h ****    * <code>x</code> is the input sample value. The functions returns the output value.
5396:DSP/Inc/arm_math.h ****    *
5397:DSP/Inc/arm_math.h ****    * \par
5398:DSP/Inc/arm_math.h ****    * if x is outside of the table boundary, Linear interpolation returns first value of the table
5399:DSP/Inc/arm_math.h ****    * if x is below input range and returns last value of table if x is above range.
5400:DSP/Inc/arm_math.h ****    */
5401:DSP/Inc/arm_math.h **** 
5402:DSP/Inc/arm_math.h ****   /**
5403:DSP/Inc/arm_math.h ****    * @addtogroup LinearInterpolate
5404:DSP/Inc/arm_math.h ****    * @{
5405:DSP/Inc/arm_math.h ****    */
5406:DSP/Inc/arm_math.h **** 
5407:DSP/Inc/arm_math.h ****   /**
5408:DSP/Inc/arm_math.h ****    * @brief  Process function for the floating-point Linear Interpolation Function.
5409:DSP/Inc/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
5410:DSP/Inc/arm_math.h ****    * @param[in]     x  input sample to process
5411:DSP/Inc/arm_math.h ****    * @return y processed output sample.
5412:DSP/Inc/arm_math.h ****    *
5413:DSP/Inc/arm_math.h ****    */
5414:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE float32_t arm_linear_interp_f32(
5415:DSP/Inc/arm_math.h ****   arm_linear_interp_instance_f32 * S,
5416:DSP/Inc/arm_math.h ****   float32_t x)
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 99


5417:DSP/Inc/arm_math.h ****   {
5418:DSP/Inc/arm_math.h ****     float32_t y;
5419:DSP/Inc/arm_math.h ****     float32_t x0, x1;                            /* Nearest input values */
5420:DSP/Inc/arm_math.h ****     float32_t y0, y1;                            /* Nearest output values */
5421:DSP/Inc/arm_math.h ****     float32_t xSpacing = S->xSpacing;            /* spacing between input values */
5422:DSP/Inc/arm_math.h ****     int32_t i;                                   /* Index variable */
5423:DSP/Inc/arm_math.h ****     float32_t *pYData = S->pYData;               /* pointer to output table */
5424:DSP/Inc/arm_math.h **** 
5425:DSP/Inc/arm_math.h ****     /* Calculation of index */
5426:DSP/Inc/arm_math.h ****     i = (int32_t) ((x - S->x1) / xSpacing);
5427:DSP/Inc/arm_math.h **** 
5428:DSP/Inc/arm_math.h ****     if (i < 0)
5429:DSP/Inc/arm_math.h ****     {
5430:DSP/Inc/arm_math.h ****       /* Iniatilize output for below specified range as least output value of table */
5431:DSP/Inc/arm_math.h ****       y = pYData[0];
5432:DSP/Inc/arm_math.h ****     }
5433:DSP/Inc/arm_math.h ****     else if ((uint32_t)i >= S->nValues)
5434:DSP/Inc/arm_math.h ****     {
5435:DSP/Inc/arm_math.h ****       /* Iniatilize output for above specified range as last output value of table */
5436:DSP/Inc/arm_math.h ****       y = pYData[S->nValues - 1];
5437:DSP/Inc/arm_math.h ****     }
5438:DSP/Inc/arm_math.h ****     else
5439:DSP/Inc/arm_math.h ****     {
5440:DSP/Inc/arm_math.h ****       /* Calculation of nearest input values */
5441:DSP/Inc/arm_math.h ****       x0 = S->x1 +  i      * xSpacing;
5442:DSP/Inc/arm_math.h ****       x1 = S->x1 + (i + 1) * xSpacing;
5443:DSP/Inc/arm_math.h **** 
5444:DSP/Inc/arm_math.h ****       /* Read of nearest output values */
5445:DSP/Inc/arm_math.h ****       y0 = pYData[i];
5446:DSP/Inc/arm_math.h ****       y1 = pYData[i + 1];
5447:DSP/Inc/arm_math.h **** 
5448:DSP/Inc/arm_math.h ****       /* Calculation of output */
5449:DSP/Inc/arm_math.h ****       y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
5450:DSP/Inc/arm_math.h **** 
5451:DSP/Inc/arm_math.h ****     }
5452:DSP/Inc/arm_math.h **** 
5453:DSP/Inc/arm_math.h ****     /* returns output value */
5454:DSP/Inc/arm_math.h ****     return (y);
5455:DSP/Inc/arm_math.h ****   }
5456:DSP/Inc/arm_math.h **** 
5457:DSP/Inc/arm_math.h **** 
5458:DSP/Inc/arm_math.h ****    /**
5459:DSP/Inc/arm_math.h ****    *
5460:DSP/Inc/arm_math.h ****    * @brief  Process function for the Q31 Linear Interpolation Function.
5461:DSP/Inc/arm_math.h ****    * @param[in] pYData   pointer to Q31 Linear Interpolation table
5462:DSP/Inc/arm_math.h ****    * @param[in] x        input sample to process
5463:DSP/Inc/arm_math.h ****    * @param[in] nValues  number of table values
5464:DSP/Inc/arm_math.h ****    * @return y processed output sample.
5465:DSP/Inc/arm_math.h ****    *
5466:DSP/Inc/arm_math.h ****    * \par
5467:DSP/Inc/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5468:DSP/Inc/arm_math.h ****    * This function can support maximum of table size 2^12.
5469:DSP/Inc/arm_math.h ****    *
5470:DSP/Inc/arm_math.h ****    */
5471:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q31_t arm_linear_interp_q31(
5472:DSP/Inc/arm_math.h ****   q31_t * pYData,
5473:DSP/Inc/arm_math.h ****   q31_t x,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 100


5474:DSP/Inc/arm_math.h ****   uint32_t nValues)
5475:DSP/Inc/arm_math.h ****   {
5476:DSP/Inc/arm_math.h ****     q31_t y;                                     /* output */
5477:DSP/Inc/arm_math.h ****     q31_t y0, y1;                                /* Nearest output values */
5478:DSP/Inc/arm_math.h ****     q31_t fract;                                 /* fractional part */
5479:DSP/Inc/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5480:DSP/Inc/arm_math.h **** 
5481:DSP/Inc/arm_math.h ****     /* Input is in 12.20 format */
5482:DSP/Inc/arm_math.h ****     /* 12 bits for the table index */
5483:DSP/Inc/arm_math.h ****     /* Index value calculation */
5484:DSP/Inc/arm_math.h ****     index = ((x & (q31_t)0xFFF00000) >> 20);
5485:DSP/Inc/arm_math.h **** 
5486:DSP/Inc/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5487:DSP/Inc/arm_math.h ****     {
5488:DSP/Inc/arm_math.h ****       return (pYData[nValues - 1]);
5489:DSP/Inc/arm_math.h ****     }
5490:DSP/Inc/arm_math.h ****     else if (index < 0)
5491:DSP/Inc/arm_math.h ****     {
5492:DSP/Inc/arm_math.h ****       return (pYData[0]);
5493:DSP/Inc/arm_math.h ****     }
5494:DSP/Inc/arm_math.h ****     else
5495:DSP/Inc/arm_math.h ****     {
5496:DSP/Inc/arm_math.h ****       /* 20 bits for the fractional part */
5497:DSP/Inc/arm_math.h ****       /* shift left by 11 to keep fract in 1.31 format */
5498:DSP/Inc/arm_math.h ****       fract = (x & 0x000FFFFF) << 11;
5499:DSP/Inc/arm_math.h **** 
5500:DSP/Inc/arm_math.h ****       /* Read two nearest output values from the index in 1.31(q31) format */
5501:DSP/Inc/arm_math.h ****       y0 = pYData[index];
5502:DSP/Inc/arm_math.h ****       y1 = pYData[index + 1];
5503:DSP/Inc/arm_math.h **** 
5504:DSP/Inc/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 2.30 format */
5505:DSP/Inc/arm_math.h ****       y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
5506:DSP/Inc/arm_math.h **** 
5507:DSP/Inc/arm_math.h ****       /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
5508:DSP/Inc/arm_math.h ****       y += ((q31_t) (((q63_t) y1 * fract) >> 32));
5509:DSP/Inc/arm_math.h **** 
5510:DSP/Inc/arm_math.h ****       /* Convert y to 1.31 format */
5511:DSP/Inc/arm_math.h ****       return (y << 1U);
5512:DSP/Inc/arm_math.h ****     }
5513:DSP/Inc/arm_math.h ****   }
5514:DSP/Inc/arm_math.h **** 
5515:DSP/Inc/arm_math.h **** 
5516:DSP/Inc/arm_math.h ****   /**
5517:DSP/Inc/arm_math.h ****    *
5518:DSP/Inc/arm_math.h ****    * @brief  Process function for the Q15 Linear Interpolation Function.
5519:DSP/Inc/arm_math.h ****    * @param[in] pYData   pointer to Q15 Linear Interpolation table
5520:DSP/Inc/arm_math.h ****    * @param[in] x        input sample to process
5521:DSP/Inc/arm_math.h ****    * @param[in] nValues  number of table values
5522:DSP/Inc/arm_math.h ****    * @return y processed output sample.
5523:DSP/Inc/arm_math.h ****    *
5524:DSP/Inc/arm_math.h ****    * \par
5525:DSP/Inc/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5526:DSP/Inc/arm_math.h ****    * This function can support maximum of table size 2^12.
5527:DSP/Inc/arm_math.h ****    *
5528:DSP/Inc/arm_math.h ****    */
5529:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q15_t arm_linear_interp_q15(
5530:DSP/Inc/arm_math.h ****   q15_t * pYData,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 101


5531:DSP/Inc/arm_math.h ****   q31_t x,
5532:DSP/Inc/arm_math.h ****   uint32_t nValues)
5533:DSP/Inc/arm_math.h ****   {
5534:DSP/Inc/arm_math.h ****     q63_t y;                                     /* output */
5535:DSP/Inc/arm_math.h ****     q15_t y0, y1;                                /* Nearest output values */
5536:DSP/Inc/arm_math.h ****     q31_t fract;                                 /* fractional part */
5537:DSP/Inc/arm_math.h ****     int32_t index;                               /* Index to read nearest output values */
5538:DSP/Inc/arm_math.h **** 
5539:DSP/Inc/arm_math.h ****     /* Input is in 12.20 format */
5540:DSP/Inc/arm_math.h ****     /* 12 bits for the table index */
5541:DSP/Inc/arm_math.h ****     /* Index value calculation */
5542:DSP/Inc/arm_math.h ****     index = ((x & (int32_t)0xFFF00000) >> 20);
5543:DSP/Inc/arm_math.h **** 
5544:DSP/Inc/arm_math.h ****     if (index >= (int32_t)(nValues - 1))
5545:DSP/Inc/arm_math.h ****     {
5546:DSP/Inc/arm_math.h ****       return (pYData[nValues - 1]);
5547:DSP/Inc/arm_math.h ****     }
5548:DSP/Inc/arm_math.h ****     else if (index < 0)
5549:DSP/Inc/arm_math.h ****     {
5550:DSP/Inc/arm_math.h ****       return (pYData[0]);
5551:DSP/Inc/arm_math.h ****     }
5552:DSP/Inc/arm_math.h ****     else
5553:DSP/Inc/arm_math.h ****     {
5554:DSP/Inc/arm_math.h ****       /* 20 bits for the fractional part */
5555:DSP/Inc/arm_math.h ****       /* fract is in 12.20 format */
5556:DSP/Inc/arm_math.h ****       fract = (x & 0x000FFFFF);
5557:DSP/Inc/arm_math.h **** 
5558:DSP/Inc/arm_math.h ****       /* Read two nearest output values from the index */
5559:DSP/Inc/arm_math.h ****       y0 = pYData[index];
5560:DSP/Inc/arm_math.h ****       y1 = pYData[index + 1];
5561:DSP/Inc/arm_math.h **** 
5562:DSP/Inc/arm_math.h ****       /* Calculation of y0 * (1-fract) and y is in 13.35 format */
5563:DSP/Inc/arm_math.h ****       y = ((q63_t) y0 * (0xFFFFF - fract));
5564:DSP/Inc/arm_math.h **** 
5565:DSP/Inc/arm_math.h ****       /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
5566:DSP/Inc/arm_math.h ****       y += ((q63_t) y1 * (fract));
5567:DSP/Inc/arm_math.h **** 
5568:DSP/Inc/arm_math.h ****       /* convert y to 1.15 format */
5569:DSP/Inc/arm_math.h ****       return (q15_t) (y >> 20);
5570:DSP/Inc/arm_math.h ****     }
5571:DSP/Inc/arm_math.h ****   }
5572:DSP/Inc/arm_math.h **** 
5573:DSP/Inc/arm_math.h **** 
5574:DSP/Inc/arm_math.h ****   /**
5575:DSP/Inc/arm_math.h ****    *
5576:DSP/Inc/arm_math.h ****    * @brief  Process function for the Q7 Linear Interpolation Function.
5577:DSP/Inc/arm_math.h ****    * @param[in] pYData   pointer to Q7 Linear Interpolation table
5578:DSP/Inc/arm_math.h ****    * @param[in] x        input sample to process
5579:DSP/Inc/arm_math.h ****    * @param[in] nValues  number of table values
5580:DSP/Inc/arm_math.h ****    * @return y processed output sample.
5581:DSP/Inc/arm_math.h ****    *
5582:DSP/Inc/arm_math.h ****    * \par
5583:DSP/Inc/arm_math.h ****    * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 b
5584:DSP/Inc/arm_math.h ****    * This function can support maximum of table size 2^12.
5585:DSP/Inc/arm_math.h ****    */
5586:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE q7_t arm_linear_interp_q7(
5587:DSP/Inc/arm_math.h ****   q7_t * pYData,
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 102


5588:DSP/Inc/arm_math.h ****   q31_t x,
5589:DSP/Inc/arm_math.h ****   uint32_t nValues)
5590:DSP/Inc/arm_math.h ****   {
5591:DSP/Inc/arm_math.h ****     q31_t y;                                     /* output */
5592:DSP/Inc/arm_math.h ****     q7_t y0, y1;                                 /* Nearest output values */
5593:DSP/Inc/arm_math.h ****     q31_t fract;                                 /* fractional part */
5594:DSP/Inc/arm_math.h ****     uint32_t index;                              /* Index to read nearest output values */
5595:DSP/Inc/arm_math.h **** 
5596:DSP/Inc/arm_math.h ****     /* Input is in 12.20 format */
5597:DSP/Inc/arm_math.h ****     /* 12 bits for the table index */
5598:DSP/Inc/arm_math.h ****     /* Index value calculation */
5599:DSP/Inc/arm_math.h ****     if (x < 0)
5600:DSP/Inc/arm_math.h ****     {
5601:DSP/Inc/arm_math.h ****       return (pYData[0]);
5602:DSP/Inc/arm_math.h ****     }
5603:DSP/Inc/arm_math.h ****     index = (x >> 20) & 0xfff;
5604:DSP/Inc/arm_math.h **** 
5605:DSP/Inc/arm_math.h ****     if (index >= (nValues - 1))
5606:DSP/Inc/arm_math.h ****     {
5607:DSP/Inc/arm_math.h ****       return (pYData[nValues - 1]);
5608:DSP/Inc/arm_math.h ****     }
5609:DSP/Inc/arm_math.h ****     else
5610:DSP/Inc/arm_math.h ****     {
5611:DSP/Inc/arm_math.h ****       /* 20 bits for the fractional part */
5612:DSP/Inc/arm_math.h ****       /* fract is in 12.20 format */
5613:DSP/Inc/arm_math.h ****       fract = (x & 0x000FFFFF);
5614:DSP/Inc/arm_math.h **** 
5615:DSP/Inc/arm_math.h ****       /* Read two nearest output values from the index and are in 1.7(q7) format */
5616:DSP/Inc/arm_math.h ****       y0 = pYData[index];
5617:DSP/Inc/arm_math.h ****       y1 = pYData[index + 1];
5618:DSP/Inc/arm_math.h **** 
5619:DSP/Inc/arm_math.h ****       /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
5620:DSP/Inc/arm_math.h ****       y = ((y0 * (0xFFFFF - fract)));
5621:DSP/Inc/arm_math.h **** 
5622:DSP/Inc/arm_math.h ****       /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
5623:DSP/Inc/arm_math.h ****       y += (y1 * fract);
5624:DSP/Inc/arm_math.h **** 
5625:DSP/Inc/arm_math.h ****       /* convert y to 1.7(q7) format */
5626:DSP/Inc/arm_math.h ****       return (q7_t) (y >> 20);
5627:DSP/Inc/arm_math.h ****      }
5628:DSP/Inc/arm_math.h ****   }
5629:DSP/Inc/arm_math.h **** 
5630:DSP/Inc/arm_math.h ****   /**
5631:DSP/Inc/arm_math.h ****    * @} end of LinearInterpolate group
5632:DSP/Inc/arm_math.h ****    */
5633:DSP/Inc/arm_math.h **** 
5634:DSP/Inc/arm_math.h ****   /**
5635:DSP/Inc/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for floating-point data.
5636:DSP/Inc/arm_math.h ****    * @param[in] x  input value in radians.
5637:DSP/Inc/arm_math.h ****    * @return  sin(x).
5638:DSP/Inc/arm_math.h ****    */
5639:DSP/Inc/arm_math.h ****   float32_t arm_sin_f32(
5640:DSP/Inc/arm_math.h ****   float32_t x);
5641:DSP/Inc/arm_math.h **** 
5642:DSP/Inc/arm_math.h **** 
5643:DSP/Inc/arm_math.h ****   /**
5644:DSP/Inc/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q31 data.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 103


5645:DSP/Inc/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5646:DSP/Inc/arm_math.h ****    * @return  sin(x).
5647:DSP/Inc/arm_math.h ****    */
5648:DSP/Inc/arm_math.h ****   q31_t arm_sin_q31(
5649:DSP/Inc/arm_math.h ****   q31_t x);
5650:DSP/Inc/arm_math.h **** 
5651:DSP/Inc/arm_math.h **** 
5652:DSP/Inc/arm_math.h ****   /**
5653:DSP/Inc/arm_math.h ****    * @brief  Fast approximation to the trigonometric sine function for Q15 data.
5654:DSP/Inc/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5655:DSP/Inc/arm_math.h ****    * @return  sin(x).
5656:DSP/Inc/arm_math.h ****    */
5657:DSP/Inc/arm_math.h ****   q15_t arm_sin_q15(
5658:DSP/Inc/arm_math.h ****   q15_t x);
5659:DSP/Inc/arm_math.h **** 
5660:DSP/Inc/arm_math.h **** 
5661:DSP/Inc/arm_math.h ****   /**
5662:DSP/Inc/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
5663:DSP/Inc/arm_math.h ****    * @param[in] x  input value in radians.
5664:DSP/Inc/arm_math.h ****    * @return  cos(x).
5665:DSP/Inc/arm_math.h ****    */
5666:DSP/Inc/arm_math.h ****   float32_t arm_cos_f32(
5667:DSP/Inc/arm_math.h ****   float32_t x);
5668:DSP/Inc/arm_math.h **** 
5669:DSP/Inc/arm_math.h **** 
5670:DSP/Inc/arm_math.h ****   /**
5671:DSP/Inc/arm_math.h ****    * @brief Fast approximation to the trigonometric cosine function for Q31 data.
5672:DSP/Inc/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5673:DSP/Inc/arm_math.h ****    * @return  cos(x).
5674:DSP/Inc/arm_math.h ****    */
5675:DSP/Inc/arm_math.h ****   q31_t arm_cos_q31(
5676:DSP/Inc/arm_math.h ****   q31_t x);
5677:DSP/Inc/arm_math.h **** 
5678:DSP/Inc/arm_math.h **** 
5679:DSP/Inc/arm_math.h ****   /**
5680:DSP/Inc/arm_math.h ****    * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
5681:DSP/Inc/arm_math.h ****    * @param[in] x  Scaled input value in radians.
5682:DSP/Inc/arm_math.h ****    * @return  cos(x).
5683:DSP/Inc/arm_math.h ****    */
5684:DSP/Inc/arm_math.h ****   q15_t arm_cos_q15(
5685:DSP/Inc/arm_math.h ****   q15_t x);
5686:DSP/Inc/arm_math.h **** 
5687:DSP/Inc/arm_math.h **** 
5688:DSP/Inc/arm_math.h ****   /**
5689:DSP/Inc/arm_math.h ****    * @ingroup groupFastMath
5690:DSP/Inc/arm_math.h ****    */
5691:DSP/Inc/arm_math.h **** 
5692:DSP/Inc/arm_math.h **** 
5693:DSP/Inc/arm_math.h ****   /**
5694:DSP/Inc/arm_math.h ****    * @defgroup SQRT Square Root
5695:DSP/Inc/arm_math.h ****    *
5696:DSP/Inc/arm_math.h ****    * Computes the square root of a number.
5697:DSP/Inc/arm_math.h ****    * There are separate functions for Q15, Q31, and floating-point data types.
5698:DSP/Inc/arm_math.h ****    * The square root function is computed using the Newton-Raphson algorithm.
5699:DSP/Inc/arm_math.h ****    * This is an iterative algorithm of the form:
5700:DSP/Inc/arm_math.h ****    * <pre>
5701:DSP/Inc/arm_math.h ****    *      x1 = x0 - f(x0)/f'(x0)
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 104


5702:DSP/Inc/arm_math.h ****    * </pre>
5703:DSP/Inc/arm_math.h ****    * where <code>x1</code> is the current estimate,
5704:DSP/Inc/arm_math.h ****    * <code>x0</code> is the previous estimate, and
5705:DSP/Inc/arm_math.h ****    * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
5706:DSP/Inc/arm_math.h ****    * For the square root function, the algorithm reduces to:
5707:DSP/Inc/arm_math.h ****    * <pre>
5708:DSP/Inc/arm_math.h ****    *     x0 = in/2                         [initial guess]
5709:DSP/Inc/arm_math.h ****    *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
5710:DSP/Inc/arm_math.h ****    * </pre>
5711:DSP/Inc/arm_math.h ****    */
5712:DSP/Inc/arm_math.h **** 
5713:DSP/Inc/arm_math.h **** 
5714:DSP/Inc/arm_math.h ****   /**
5715:DSP/Inc/arm_math.h ****    * @addtogroup SQRT
5716:DSP/Inc/arm_math.h ****    * @{
5717:DSP/Inc/arm_math.h ****    */
5718:DSP/Inc/arm_math.h **** 
5719:DSP/Inc/arm_math.h ****   /**
5720:DSP/Inc/arm_math.h ****    * @brief  Floating-point square root function.
5721:DSP/Inc/arm_math.h ****    * @param[in]  in    input value.
5722:DSP/Inc/arm_math.h ****    * @param[out] pOut  square root of input value.
5723:DSP/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5724:DSP/Inc/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5725:DSP/Inc/arm_math.h ****    */
5726:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
5727:DSP/Inc/arm_math.h ****   float32_t in,
5728:DSP/Inc/arm_math.h ****   float32_t * pOut)
5729:DSP/Inc/arm_math.h ****   {
5730:DSP/Inc/arm_math.h ****     if (in >= 0.0f)
5731:DSP/Inc/arm_math.h ****     {
5732:DSP/Inc/arm_math.h **** 
5733:DSP/Inc/arm_math.h **** #if   (__FPU_USED == 1) && defined ( __CC_ARM   )
5734:DSP/Inc/arm_math.h ****       *pOut = __sqrtf(in);
5735:DSP/Inc/arm_math.h **** #elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
5736:DSP/Inc/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5737:DSP/Inc/arm_math.h **** #elif (__FPU_USED == 1) && defined(__GNUC__)
5738:DSP/Inc/arm_math.h ****       *pOut = __builtin_sqrtf(in);
5739:DSP/Inc/arm_math.h **** #elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
5740:DSP/Inc/arm_math.h ****       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
5741:DSP/Inc/arm_math.h **** #else
5742:DSP/Inc/arm_math.h ****       *pOut = sqrtf(in);
5743:DSP/Inc/arm_math.h **** #endif
5744:DSP/Inc/arm_math.h **** 
5745:DSP/Inc/arm_math.h ****       return (ARM_MATH_SUCCESS);
5746:DSP/Inc/arm_math.h ****     }
5747:DSP/Inc/arm_math.h ****     else
5748:DSP/Inc/arm_math.h ****     {
5749:DSP/Inc/arm_math.h ****       *pOut = 0.0f;
5750:DSP/Inc/arm_math.h ****       return (ARM_MATH_ARGUMENT_ERROR);
5751:DSP/Inc/arm_math.h ****     }
5752:DSP/Inc/arm_math.h ****   }
5753:DSP/Inc/arm_math.h **** 
5754:DSP/Inc/arm_math.h **** 
5755:DSP/Inc/arm_math.h ****   /**
5756:DSP/Inc/arm_math.h ****    * @brief Q31 square root function.
5757:DSP/Inc/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFF
5758:DSP/Inc/arm_math.h ****    * @param[out] pOut  square root of input value.
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 105


5759:DSP/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5760:DSP/Inc/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5761:DSP/Inc/arm_math.h ****    */
5762:DSP/Inc/arm_math.h ****   arm_status arm_sqrt_q31(
5763:DSP/Inc/arm_math.h ****   q31_t in,
5764:DSP/Inc/arm_math.h ****   q31_t * pOut);
5765:DSP/Inc/arm_math.h **** 
5766:DSP/Inc/arm_math.h **** 
5767:DSP/Inc/arm_math.h ****   /**
5768:DSP/Inc/arm_math.h ****    * @brief  Q15 square root function.
5769:DSP/Inc/arm_math.h ****    * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
5770:DSP/Inc/arm_math.h ****    * @param[out] pOut  square root of input value.
5771:DSP/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARG
5772:DSP/Inc/arm_math.h ****    * <code>in</code> is negative value and returns zero output for negative values.
5773:DSP/Inc/arm_math.h ****    */
5774:DSP/Inc/arm_math.h ****   arm_status arm_sqrt_q15(
5775:DSP/Inc/arm_math.h ****   q15_t in,
5776:DSP/Inc/arm_math.h ****   q15_t * pOut);
5777:DSP/Inc/arm_math.h **** 
5778:DSP/Inc/arm_math.h ****   /**
5779:DSP/Inc/arm_math.h ****    * @} end of SQRT group
5780:DSP/Inc/arm_math.h ****    */
5781:DSP/Inc/arm_math.h **** 
5782:DSP/Inc/arm_math.h **** 
5783:DSP/Inc/arm_math.h ****   /**
5784:DSP/Inc/arm_math.h ****    * @brief floating-point Circular write function.
5785:DSP/Inc/arm_math.h ****    */
5786:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularWrite_f32(
  91              		.loc 2 5786 37 view .LVU24
  92              	.LBB11:
5787:DSP/Inc/arm_math.h ****   int32_t * circBuffer,
5788:DSP/Inc/arm_math.h ****   int32_t L,
5789:DSP/Inc/arm_math.h ****   uint16_t * writeOffset,
5790:DSP/Inc/arm_math.h ****   int32_t bufferInc,
5791:DSP/Inc/arm_math.h ****   const int32_t * src,
5792:DSP/Inc/arm_math.h ****   int32_t srcInc,
5793:DSP/Inc/arm_math.h ****   uint32_t blockSize)
5794:DSP/Inc/arm_math.h ****   {
5795:DSP/Inc/arm_math.h ****     uint32_t i = 0U;
  93              		.loc 2 5795 5 view .LVU25
5796:DSP/Inc/arm_math.h ****     int32_t wOffset;
  94              		.loc 2 5796 5 view .LVU26
5797:DSP/Inc/arm_math.h **** 
5798:DSP/Inc/arm_math.h ****     /* Copy the value of Index pointer that points
5799:DSP/Inc/arm_math.h ****      * to the current location where the input samples to be copied */
5800:DSP/Inc/arm_math.h ****     wOffset = *writeOffset;
  95              		.loc 2 5800 5 view .LVU27
  96              		.loc 2 5800 15 is_stmt 0 view .LVU28
  97 0024 7688     		ldrh	r6, [r6, #2]
  98              	.LVL7:
5801:DSP/Inc/arm_math.h **** 
5802:DSP/Inc/arm_math.h ****     /* Loop over the blockSize */
5803:DSP/Inc/arm_math.h ****     i = blockSize;
  99              		.loc 2 5803 5 is_stmt 1 view .LVU29
5804:DSP/Inc/arm_math.h **** 
5805:DSP/Inc/arm_math.h ****     while (i > 0U)
 100              		.loc 2 5805 5 view .LVU30
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 106


5803:DSP/Inc/arm_math.h **** 
 101              		.loc 2 5803 7 is_stmt 0 view .LVU31
 102 0026 5F46     		mov	r7, fp
 103 0028 9E46     		mov	lr, r3
 104              		.loc 2 5805 11 view .LVU32
 105 002a 00E0     		b	.L2
 106              	.LVL8:
 107              	.L3:
5806:DSP/Inc/arm_math.h ****     {
5807:DSP/Inc/arm_math.h ****       /* copy the input sample to the circular buffer */
5808:DSP/Inc/arm_math.h ****       circBuffer[wOffset] = *src;
5809:DSP/Inc/arm_math.h **** 
5810:DSP/Inc/arm_math.h ****       /* Update the input pointer */
5811:DSP/Inc/arm_math.h ****       src += srcInc;
5812:DSP/Inc/arm_math.h **** 
5813:DSP/Inc/arm_math.h ****       /* Circularly update wOffset.  Watch out for positive and negative value */
5814:DSP/Inc/arm_math.h ****       wOffset += bufferInc;
5815:DSP/Inc/arm_math.h ****       if (wOffset >= L)
5816:DSP/Inc/arm_math.h ****         wOffset -= L;
5817:DSP/Inc/arm_math.h **** 
5818:DSP/Inc/arm_math.h ****       /* Decrement the loop counter */
5819:DSP/Inc/arm_math.h ****       i--;
 108              		.loc 2 5819 7 is_stmt 1 view .LVU33
 109              		.loc 2 5819 8 is_stmt 0 view .LVU34
 110 002c 013F     		subs	r7, r7, #1
 111              	.LVL9:
 112              	.L2:
5805:DSP/Inc/arm_math.h ****     {
 113              		.loc 2 5805 14 is_stmt 1 view .LVU35
 114 002e 47B1     		cbz	r7, .L42
5808:DSP/Inc/arm_math.h **** 
 115              		.loc 2 5808 7 view .LVU36
5808:DSP/Inc/arm_math.h **** 
 116              		.loc 2 5808 29 is_stmt 0 view .LVU37
 117 0030 51F8043B 		ldr	r3, [r1], #4
 118              	.LVL10:
5808:DSP/Inc/arm_math.h **** 
 119              		.loc 2 5808 27 view .LVU38
 120 0034 45F82630 		str	r3, [r5, r6, lsl #2]
5811:DSP/Inc/arm_math.h **** 
 121              		.loc 2 5811 7 is_stmt 1 view .LVU39
 122              	.LVL11:
5814:DSP/Inc/arm_math.h ****       if (wOffset >= L)
 123              		.loc 2 5814 7 view .LVU40
5814:DSP/Inc/arm_math.h ****       if (wOffset >= L)
 124              		.loc 2 5814 15 is_stmt 0 view .LVU41
 125 0038 0136     		adds	r6, r6, #1
 126              	.LVL12:
5815:DSP/Inc/arm_math.h ****         wOffset -= L;
 127              		.loc 2 5815 7 is_stmt 1 view .LVU42
5815:DSP/Inc/arm_math.h ****         wOffset -= L;
 128              		.loc 2 5815 10 is_stmt 0 view .LVU43
 129 003a B442     		cmp	r4, r6
 130 003c F6DC     		bgt	.L3
5816:DSP/Inc/arm_math.h **** 
 131              		.loc 2 5816 9 is_stmt 1 view .LVU44
5816:DSP/Inc/arm_math.h **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 107


 132              		.loc 2 5816 17 is_stmt 0 view .LVU45
 133 003e 361B     		subs	r6, r6, r4
 134              	.LVL13:
5816:DSP/Inc/arm_math.h **** 
 135              		.loc 2 5816 17 view .LVU46
 136 0040 F4E7     		b	.L3
 137              	.L42:
5820:DSP/Inc/arm_math.h ****     }
5821:DSP/Inc/arm_math.h **** 
5822:DSP/Inc/arm_math.h ****     /* Update the index pointer */
5823:DSP/Inc/arm_math.h ****     *writeOffset = (uint16_t)wOffset;
 138              		.loc 2 5823 20 view .LVU47
 139 0042 7346     		mov	r3, lr
 140              		.loc 2 5823 5 is_stmt 1 view .LVU48
 141              		.loc 2 5823 20 is_stmt 0 view .LVU49
 142 0044 B6B2     		uxth	r6, r6
 143              	.LVL14:
 144              		.loc 2 5823 18 view .LVU50
 145 0046 0399     		ldr	r1, [sp, #12]
 146              	.LVL15:
 147              		.loc 2 5823 18 view .LVU51
 148 0048 4E80     		strh	r6, [r1, #2]	@ movhi
 149              	.LVL16:
 150              		.loc 2 5823 18 view .LVU52
 151              	.LBE11:
 152              	.LBE10:
  82:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                         (int32_t *) pSrc, 1, blockSize);
  83:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  84:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
  85:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
 153              		.loc 1 85 3 is_stmt 1 view .LVU53
 154              		.loc 1 85 40 is_stmt 0 view .LVU54
 155 004a A6EB0B06 		sub	r6, r6, fp
 156              	.LVL17:
 157              		.loc 1 85 55 view .LVU55
 158 004e DAF80010 		ldr	r1, [r10]
 159              	.LVL18:
  86:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  87:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Wraparound of readIndex */
  88:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   if (readIndex < 0)
 160              		.loc 1 88 3 is_stmt 1 view .LVU56
 161              		.loc 1 88 6 is_stmt 0 view .LVU57
 162 0052 711A     		subs	r1, r6, r1
 163              	.LVL19:
 164              		.loc 1 88 6 view .LVU58
 165 0054 06D4     		bmi	.L43
 166              	.LVL20:
 167              	.L5:
  89:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
  90:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     readIndex += (int32_t) delaySize;
  91:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
  92:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  93:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Working pointer for state buffer is updated */
  94:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   py = pState;
 168              		.loc 1 94 3 is_stmt 1 view .LVU59
  95:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
  96:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* blockSize samples are read from the state buffer */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 108


  97:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 169              		.loc 1 97 3 view .LVU60
 170              	.LBB12:
 171              	.LBI12:
5824:DSP/Inc/arm_math.h ****   }
5825:DSP/Inc/arm_math.h **** 
5826:DSP/Inc/arm_math.h **** 
5827:DSP/Inc/arm_math.h **** 
5828:DSP/Inc/arm_math.h ****   /**
5829:DSP/Inc/arm_math.h ****    * @brief floating-point Circular Read function.
5830:DSP/Inc/arm_math.h ****    */
5831:DSP/Inc/arm_math.h ****   CMSIS_INLINE __STATIC_INLINE void arm_circularRead_f32(
 172              		.loc 2 5831 37 view .LVU61
 173              	.LBB13:
5832:DSP/Inc/arm_math.h ****   int32_t * circBuffer,
5833:DSP/Inc/arm_math.h ****   int32_t L,
5834:DSP/Inc/arm_math.h ****   int32_t * readOffset,
5835:DSP/Inc/arm_math.h ****   int32_t bufferInc,
5836:DSP/Inc/arm_math.h ****   int32_t * dst,
5837:DSP/Inc/arm_math.h ****   int32_t * dst_base,
5838:DSP/Inc/arm_math.h ****   int32_t dst_length,
5839:DSP/Inc/arm_math.h ****   int32_t dstInc,
5840:DSP/Inc/arm_math.h ****   uint32_t blockSize)
5841:DSP/Inc/arm_math.h ****   {
5842:DSP/Inc/arm_math.h ****     uint32_t i = 0U;
 174              		.loc 2 5842 5 view .LVU62
5843:DSP/Inc/arm_math.h ****     int32_t rOffset, dst_end;
 175              		.loc 2 5843 5 view .LVU63
5844:DSP/Inc/arm_math.h **** 
5845:DSP/Inc/arm_math.h ****     /* Copy the value of Index pointer that points
5846:DSP/Inc/arm_math.h ****      * to the current location from where the input samples to be read */
5847:DSP/Inc/arm_math.h ****     rOffset = *readOffset;
 176              		.loc 2 5847 5 view .LVU64
5848:DSP/Inc/arm_math.h ****     dst_end = (int32_t) (dst_base + dst_length);
 177              		.loc 2 5848 5 view .LVU65
 178              		.loc 2 5848 35 is_stmt 0 view .LVU66
 179 0056 03EB8B06 		add	r6, r3, fp, lsl #2
 180              	.LVL21:
5849:DSP/Inc/arm_math.h **** 
5850:DSP/Inc/arm_math.h ****     /* Loop over the blockSize */
5851:DSP/Inc/arm_math.h ****     i = blockSize;
 181              		.loc 2 5851 5 is_stmt 1 view .LVU67
5852:DSP/Inc/arm_math.h **** 
5853:DSP/Inc/arm_math.h ****     while (i > 0U)
 182              		.loc 2 5853 5 view .LVU68
 183              		.loc 2 5853 11 is_stmt 0 view .LVU69
 184 005a 1F46     		mov	r7, r3
 185 005c 9146     		mov	r9, r2
 186 005e 5B46     		mov	r3, fp
 187              	.LVL22:
 188              		.loc 2 5853 11 view .LVU70
 189 0060 BE46     		mov	lr, r7
 190              	.LVL23:
 191              		.loc 2 5853 11 view .LVU71
 192 0062 04E0     		b	.L6
 193              	.LVL24:
 194              	.L43:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 109


 195              		.loc 2 5853 11 view .LVU72
 196              	.LBE13:
 197              	.LBE12:
  90:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 198              		.loc 1 90 5 is_stmt 1 view .LVU73
  90:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 199              		.loc 1 90 15 is_stmt 0 view .LVU74
 200 0064 2144     		add	r1, r1, r4
 201              	.LVL25:
  90:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 202              		.loc 1 90 15 view .LVU75
 203 0066 F6E7     		b	.L5
 204              	.LVL26:
 205              	.L45:
 206              	.LBB16:
 207              	.LBB14:
5854:DSP/Inc/arm_math.h ****     {
5855:DSP/Inc/arm_math.h ****       /* copy the sample from the circular buffer to the destination buffer */
5856:DSP/Inc/arm_math.h ****       *dst = circBuffer[rOffset];
5857:DSP/Inc/arm_math.h **** 
5858:DSP/Inc/arm_math.h ****       /* Update the input pointer */
5859:DSP/Inc/arm_math.h ****       dst += dstInc;
5860:DSP/Inc/arm_math.h **** 
5861:DSP/Inc/arm_math.h ****       if (dst == (int32_t *) dst_end)
5862:DSP/Inc/arm_math.h ****       {
5863:DSP/Inc/arm_math.h ****         dst = dst_base;
 208              		.loc 2 5863 13 view .LVU76
 209 0068 7746     		mov	r7, lr
 210              	.LVL27:
 211              		.loc 2 5863 13 view .LVU77
 212 006a 07E0     		b	.L7
 213              	.LVL28:
 214              	.L8:
5864:DSP/Inc/arm_math.h ****       }
5865:DSP/Inc/arm_math.h **** 
5866:DSP/Inc/arm_math.h ****       /* Circularly update rOffset.  Watch out for positive and negative value  */
5867:DSP/Inc/arm_math.h ****       rOffset += bufferInc;
5868:DSP/Inc/arm_math.h **** 
5869:DSP/Inc/arm_math.h ****       if (rOffset >= L)
5870:DSP/Inc/arm_math.h ****       {
5871:DSP/Inc/arm_math.h ****         rOffset -= L;
5872:DSP/Inc/arm_math.h ****       }
5873:DSP/Inc/arm_math.h **** 
5874:DSP/Inc/arm_math.h ****       /* Decrement the loop counter */
5875:DSP/Inc/arm_math.h ****       i--;
 215              		.loc 2 5875 7 is_stmt 1 view .LVU78
 216              		.loc 2 5875 8 is_stmt 0 view .LVU79
 217 006c 013B     		subs	r3, r3, #1
 218              	.LVL29:
 219              	.L6:
5853:DSP/Inc/arm_math.h ****     {
 220              		.loc 2 5853 14 is_stmt 1 view .LVU80
 221 006e 53B1     		cbz	r3, .L44
5856:DSP/Inc/arm_math.h **** 
 222              		.loc 2 5856 7 view .LVU81
5856:DSP/Inc/arm_math.h **** 
 223              		.loc 2 5856 12 is_stmt 0 view .LVU82
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 110


 224 0070 55F82120 		ldr	r2, [r5, r1, lsl #2]
 225 0074 47F8042B 		str	r2, [r7], #4
 226              	.LVL30:
5859:DSP/Inc/arm_math.h **** 
 227              		.loc 2 5859 7 is_stmt 1 view .LVU83
5861:DSP/Inc/arm_math.h ****       {
 228              		.loc 2 5861 7 view .LVU84
5861:DSP/Inc/arm_math.h ****       {
 229              		.loc 2 5861 10 is_stmt 0 view .LVU85
 230 0078 BE42     		cmp	r6, r7
 231 007a F5D0     		beq	.L45
 232              	.LVL31:
 233              	.L7:
5867:DSP/Inc/arm_math.h **** 
 234              		.loc 2 5867 7 is_stmt 1 view .LVU86
5867:DSP/Inc/arm_math.h **** 
 235              		.loc 2 5867 15 is_stmt 0 view .LVU87
 236 007c 0131     		adds	r1, r1, #1
 237              	.LVL32:
5869:DSP/Inc/arm_math.h ****       {
 238              		.loc 2 5869 7 is_stmt 1 view .LVU88
5869:DSP/Inc/arm_math.h ****       {
 239              		.loc 2 5869 10 is_stmt 0 view .LVU89
 240 007e 8C42     		cmp	r4, r1
 241 0080 F4DC     		bgt	.L8
5871:DSP/Inc/arm_math.h ****       }
 242              		.loc 2 5871 9 is_stmt 1 view .LVU90
 243              	.LVL33:
5871:DSP/Inc/arm_math.h ****       }
 244              		.loc 2 5871 17 is_stmt 0 view .LVU91
 245 0082 091B     		subs	r1, r1, r4
 246              	.LVL34:
5871:DSP/Inc/arm_math.h ****       }
 247              		.loc 2 5871 17 view .LVU92
 248 0084 F2E7     		b	.L8
 249              	.L44:
5871:DSP/Inc/arm_math.h ****       }
 250              		.loc 2 5871 17 view .LVU93
 251              	.LBE14:
 252              	.LBE16:
  98:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                        (int32_t *) pb, (int32_t *) pb, blockSize, 1,
  99:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                        blockSize);
 100:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 101:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Working pointer for the scratch buffer of state values */
 102:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   px = pb;
 103:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 104:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Working pointer for scratch buffer of output values */
 105:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   pOut = pDst;
 106:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 107:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 108:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** #if defined (ARM_MATH_DSP)
 109:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 110:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
 111:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 112:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Loop over the blockSize. Unroll by a factor of 4.
 113:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****    * Compute 4 Multiplications at a time. */
 114:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   blkCnt = blockSize >> 2;
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 111


 253              		.loc 1 114 10 view .LVU94
 254 0086 4A46     		mov	r2, r9
 255              	.LBB17:
 256              	.LBB15:
5876:DSP/Inc/arm_math.h ****     }
5877:DSP/Inc/arm_math.h **** 
5878:DSP/Inc/arm_math.h ****     /* Update the index pointer */
5879:DSP/Inc/arm_math.h ****     *readOffset = rOffset;
 257              		.loc 2 5879 5 is_stmt 1 view .LVU95
 258              	.LVL35:
 259              		.loc 2 5879 5 is_stmt 0 view .LVU96
 260              	.LBE15:
 261              	.LBE17:
 102:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 262              		.loc 1 102 3 is_stmt 1 view .LVU97
 105:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 263              		.loc 1 105 3 view .LVU98
 264              		.loc 1 114 3 view .LVU99
 265              		.loc 1 114 10 is_stmt 0 view .LVU100
 266 0088 4FEA9B01 		lsr	r1, fp, #2
 267              	.LVL36:
 268              		.loc 1 114 10 view .LVU101
 269 008c 0691     		str	r1, [sp, #24]
 270              	.LVL37:
 115:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 116:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (blkCnt > 0U)
 271              		.loc 1 116 3 is_stmt 1 view .LVU102
 114:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 272              		.loc 1 114 10 is_stmt 0 view .LVU103
 273 008e 8946     		mov	r9, r1
 274              	.LVL38:
 105:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 275              		.loc 1 105 8 view .LVU104
 276 0090 1746     		mov	r7, r2
 102:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 277              		.loc 1 102 6 view .LVU105
 278 0092 7146     		mov	r1, lr
 279              	.LVL39:
 102:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 280              		.loc 1 102 6 view .LVU106
 281 0094 0195     		str	r5, [sp, #4]
 282 0096 CDF80880 		str	r8, [sp, #8]
 283 009a CDF810A0 		str	r10, [sp, #16]
 284 009e 4B46     		mov	r3, r9
 285 00a0 F146     		mov	r9, lr
 286              	.LVL40:
 287              		.loc 1 116 9 view .LVU107
 288 00a2 34E0     		b	.L10
 289              	.LVL41:
 290              	.L11:
 117:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 118:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Perform Multiplications and store in the destination buffer */
 119:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 291              		.loc 1 119 5 is_stmt 1 view .LVU108
 292              		.loc 1 119 33 is_stmt 0 view .LVU109
 293 00a4 D1F800E0 		ldr	lr, [r1]
 294              		.loc 1 119 25 view .LVU110
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 112


 295 00a8 4FEAEE7A 		asr	r10, lr, #31
 296              		.loc 1 119 40 view .LVU111
 297 00ac 4FEAE078 		asr	r8, r0, #31
 298 00b0 0EFB08F5 		mul	r5, lr, r8
 299 00b4 00FB0A55 		mla	r5, r0, r10, r5
 300 00b8 AEFB00EA 		umull	lr, r10, lr, r0
 301 00bc 5544     		add	r5, r5, r10
 302              	.LVL42:
 303              		.loc 1 119 13 view .LVU112
 304 00be 3D60     		str	r5, [r7]
 120:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 305              		.loc 1 120 5 is_stmt 1 view .LVU113
 306              	.LVL43:
 307              		.loc 1 120 33 is_stmt 0 view .LVU114
 308 00c0 D1F804E0 		ldr	lr, [r1, #4]
 309              		.loc 1 120 25 view .LVU115
 310 00c4 4FEAEE75 		asr	r5, lr, #31
 311              		.loc 1 120 40 view .LVU116
 312 00c8 00FB05F5 		mul	r5, r0, r5
 313 00cc 0EFB0855 		mla	r5, lr, r8, r5
 314 00d0 A0FB0EAE 		umull	r10, lr, r0, lr
 315 00d4 7544     		add	r5, r5, lr
 316              	.LVL44:
 317              		.loc 1 120 13 view .LVU117
 318 00d6 7D60     		str	r5, [r7, #4]
 121:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 319              		.loc 1 121 5 is_stmt 1 view .LVU118
 320              	.LVL45:
 321              		.loc 1 121 33 is_stmt 0 view .LVU119
 322 00d8 D1F808E0 		ldr	lr, [r1, #8]
 323              		.loc 1 121 25 view .LVU120
 324 00dc 4FEAEE75 		asr	r5, lr, #31
 325              		.loc 1 121 40 view .LVU121
 326 00e0 00FB05F5 		mul	r5, r0, r5
 327 00e4 0EFB0855 		mla	r5, lr, r8, r5
 328 00e8 A0FB0EAE 		umull	r10, lr, r0, lr
 329 00ec 7544     		add	r5, r5, lr
 330              	.LVL46:
 331              		.loc 1 121 13 view .LVU122
 332 00ee BD60     		str	r5, [r7, #8]
 122:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 333              		.loc 1 122 5 is_stmt 1 view .LVU123
 334              	.LVL47:
 335              		.loc 1 122 33 is_stmt 0 view .LVU124
 336 00f0 D1F80CE0 		ldr	lr, [r1, #12]
 337              		.loc 1 122 25 view .LVU125
 338 00f4 4FEAEE75 		asr	r5, lr, #31
 339              		.loc 1 122 40 view .LVU126
 340 00f8 00FB05F5 		mul	r5, r0, r5
 341 00fc 0EFB0855 		mla	r5, lr, r8, r5
 342 0100 A0FB0EE8 		umull	lr, r8, r0, lr
 343 0104 4544     		add	r5, r5, r8
 344              	.LVL48:
 345              		.loc 1 122 13 view .LVU127
 346 0106 FD60     		str	r5, [r7, #12]
 123:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 124:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the loop counter */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 113


 125:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt--;
 347              		.loc 1 125 5 is_stmt 1 view .LVU128
 348              		.loc 1 125 11 is_stmt 0 view .LVU129
 349 0108 013B     		subs	r3, r3, #1
 350              	.LVL49:
 122:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 351              		.loc 1 122 10 view .LVU130
 352 010a 1037     		adds	r7, r7, #16
 353              	.LVL50:
 122:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 354              		.loc 1 122 37 view .LVU131
 355 010c 1031     		adds	r1, r1, #16
 356              	.LVL51:
 357              	.L10:
 116:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 358              		.loc 1 116 17 is_stmt 1 view .LVU132
 359 010e 002B     		cmp	r3, #0
 360 0110 C8D1     		bne	.L11
 126:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 127:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 128:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* If the blockSize is not a multiple of 4,
 129:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****    * compute the remaining samples */
 130:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   blkCnt = blockSize % 0x4U;
 361              		.loc 1 130 10 is_stmt 0 view .LVU133
 362 0112 019D     		ldr	r5, [sp, #4]
 363 0114 DDF80880 		ldr	r8, [sp, #8]
 364 0118 DDF810A0 		ldr	r10, [sp, #16]
 365              		.loc 1 130 3 is_stmt 1 view .LVU134
 366              		.loc 1 130 10 is_stmt 0 view .LVU135
 367 011c 0BF0030E 		and	lr, fp, #3
 368              	.LVL52:
 131:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 132:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (blkCnt > 0U)
 369              		.loc 1 132 3 is_stmt 1 view .LVU136
 370 0120 CDF804E0 		str	lr, [sp, #4]
 371              	.LVL53:
 372              		.loc 1 132 3 is_stmt 0 view .LVU137
 373 0124 0295     		str	r5, [sp, #8]
 374              	.LVL54:
 375              		.loc 1 132 3 view .LVU138
 376 0126 CDF81080 		str	r8, [sp, #16]
 377              	.LVL55:
 378              		.loc 1 132 3 view .LVU139
 379 012a 8046     		mov	r8, r0
 380 012c 7346     		mov	r3, lr
 381              		.loc 1 132 9 view .LVU140
 382 012e 0EE0     		b	.L12
 383              	.LVL56:
 384              	.L13:
 133:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 134:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Perform Multiplications and store in the destination buffer */
 135:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 385              		.loc 1 135 5 is_stmt 1 view .LVU141
 386              		.loc 1 135 33 is_stmt 0 view .LVU142
 387 0130 51F8040B 		ldr	r0, [r1], #4
 388              	.LVL57:
 389              		.loc 1 135 25 view .LVU143
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 114


 390 0134 C517     		asrs	r5, r0, #31
 391              		.loc 1 135 40 view .LVU144
 392 0136 4FEAE87E 		asr	lr, r8, #31
 393 013a 08FB05F5 		mul	r5, r8, r5
 394 013e 00FB0E55 		mla	r5, r0, lr, r5
 395 0142 A8FB00E0 		umull	lr, r0, r8, r0
 396 0146 2844     		add	r0, r0, r5
 397              	.LVL58:
 398              		.loc 1 135 13 view .LVU145
 399 0148 47F8040B 		str	r0, [r7], #4
 400              	.LVL59:
 136:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 137:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the loop counter */
 138:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt--;
 401              		.loc 1 138 5 is_stmt 1 view .LVU146
 402              		.loc 1 138 11 is_stmt 0 view .LVU147
 403 014c 013B     		subs	r3, r3, #1
 404              	.LVL60:
 405              	.L12:
 132:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 406              		.loc 1 132 17 is_stmt 1 view .LVU148
 407 014e 002B     		cmp	r3, #0
 408 0150 EED1     		bne	.L13
 139:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 140:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 141:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Load the coefficient value and
 142:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****    * increment the coefficient buffer for the next set of state values */
 143:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   coeff = *pCoeffs++;
 409              		.loc 1 143 19 is_stmt 0 view .LVU149
 410 0152 DDF804E0 		ldr	lr, [sp, #4]
 411 0156 029D     		ldr	r5, [sp, #8]
 412 0158 DDF81080 		ldr	r8, [sp, #16]
 413              	.LVL61:
 414              		.loc 1 143 19 view .LVU150
 415 015c 4B46     		mov	r3, r9
 416              	.LVL62:
 417              		.loc 1 143 3 is_stmt 1 view .LVU151
 418              		.loc 1 143 19 is_stmt 0 view .LVU152
 419 015e 08F10801 		add	r1, r8, #8
 420              	.LVL63:
 421              		.loc 1 143 19 view .LVU153
 422 0162 0191     		str	r1, [sp, #4]
 423              	.LVL64:
 424              		.loc 1 143 9 view .LVU154
 425 0164 D8F80410 		ldr	r1, [r8, #4]
 426              	.LVL65:
 144:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 145:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 146:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
 427              		.loc 1 146 3 is_stmt 1 view .LVU155
 428              		.loc 1 146 27 is_stmt 0 view .LVU156
 429 0168 0398     		ldr	r0, [sp, #12]
 430 016a 4088     		ldrh	r0, [r0, #2]
 431              		.loc 1 146 40 view .LVU157
 432 016c A0EB0B00 		sub	r0, r0, fp
 433              		.loc 1 146 65 view .LVU158
 434 0170 0AF10809 		add	r9, r10, #8
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 115


 435              	.LVL66:
 436              		.loc 1 146 55 view .LVU159
 437 0174 DAF80470 		ldr	r7, [r10, #4]
 438              	.LVL67:
 147:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 148:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Wraparound of readIndex */
 149:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   if (readIndex < 0)
 439              		.loc 1 149 3 is_stmt 1 view .LVU160
 440              		.loc 1 149 6 is_stmt 0 view .LVU161
 441 0178 C01B     		subs	r0, r0, r7
 442              	.LVL68:
 443              		.loc 1 149 6 view .LVU162
 444 017a 0CD4     		bmi	.L46
 445              	.LVL69:
 446              	.L14:
 150:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 151:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     readIndex += (int32_t) delaySize;
 152:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 153:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 154:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Loop over the number of taps. */
 155:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   tapCnt = (uint32_t) numTaps - 2U;
 447              		.loc 1 155 3 is_stmt 1 view .LVU163
 448              		.loc 1 155 10 is_stmt 0 view .LVU164
 449 017c ACF1020A 		sub	r10, ip, #2
 450              	.LVL70:
 156:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 157:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (tapCnt > 0U)
 451              		.loc 1 157 3 is_stmt 1 view .LVU165
 452 0180 CDF80890 		str	r9, [sp, #8]
 453 0184 5746     		mov	r7, r10
 454 0186 CDF81CE0 		str	lr, [sp, #28]
 455 018a DDF80CA0 		ldr	r10, [sp, #12]
 456              	.LVL71:
 457              		.loc 1 157 3 is_stmt 0 view .LVU166
 458 018e 9646     		mov	lr, r2
 459 0190 9946     		mov	r9, r3
 460              	.LVL72:
 461              		.loc 1 157 3 view .LVU167
 462 0192 0346     		mov	r3, r0
 463              	.LVL73:
 464              		.loc 1 157 9 view .LVU168
 465 0194 7EE0     		b	.L15
 466              	.LVL74:
 467              	.L46:
 151:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 468              		.loc 1 151 5 is_stmt 1 view .LVU169
 151:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 469              		.loc 1 151 15 is_stmt 0 view .LVU170
 470 0196 2044     		add	r0, r0, r4
 471              	.LVL75:
 151:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 472              		.loc 1 151 15 view .LVU171
 473 0198 F0E7     		b	.L14
 474              	.LVL76:
 475              	.L48:
 476              	.LBB18:
 477              	.LBB19:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 116


5863:DSP/Inc/arm_math.h ****       }
 478              		.loc 2 5863 13 view .LVU172
 479 019a 4A46     		mov	r2, r9
 480              	.LVL77:
5863:DSP/Inc/arm_math.h ****       }
 481              		.loc 2 5863 13 view .LVU173
 482 019c 07E0     		b	.L16
 483              	.LVL78:
 484              	.L17:
5875:DSP/Inc/arm_math.h ****     }
 485              		.loc 2 5875 7 is_stmt 1 view .LVU174
5875:DSP/Inc/arm_math.h ****     }
 486              		.loc 2 5875 8 is_stmt 0 view .LVU175
 487 019e 0138     		subs	r0, r0, #1
 488              	.LVL79:
 489              	.L24:
5853:DSP/Inc/arm_math.h ****     {
 490              		.loc 2 5853 14 is_stmt 1 view .LVU176
 491 01a0 50B1     		cbz	r0, .L47
5856:DSP/Inc/arm_math.h **** 
 492              		.loc 2 5856 7 view .LVU177
5856:DSP/Inc/arm_math.h **** 
 493              		.loc 2 5856 12 is_stmt 0 view .LVU178
 494 01a2 55F82310 		ldr	r1, [r5, r3, lsl #2]
 495 01a6 42F8041B 		str	r1, [r2], #4
 496              	.LVL80:
5859:DSP/Inc/arm_math.h **** 
 497              		.loc 2 5859 7 is_stmt 1 view .LVU179
5861:DSP/Inc/arm_math.h ****       {
 498              		.loc 2 5861 7 view .LVU180
5861:DSP/Inc/arm_math.h ****       {
 499              		.loc 2 5861 10 is_stmt 0 view .LVU181
 500 01aa 9642     		cmp	r6, r2
 501 01ac F5D0     		beq	.L48
 502              	.LVL81:
 503              	.L16:
5867:DSP/Inc/arm_math.h **** 
 504              		.loc 2 5867 7 is_stmt 1 view .LVU182
5867:DSP/Inc/arm_math.h **** 
 505              		.loc 2 5867 15 is_stmt 0 view .LVU183
 506 01ae 0133     		adds	r3, r3, #1
 507              	.LVL82:
5869:DSP/Inc/arm_math.h ****       {
 508              		.loc 2 5869 7 is_stmt 1 view .LVU184
5869:DSP/Inc/arm_math.h ****       {
 509              		.loc 2 5869 10 is_stmt 0 view .LVU185
 510 01b0 9C42     		cmp	r4, r3
 511 01b2 F4DC     		bgt	.L17
5871:DSP/Inc/arm_math.h ****       }
 512              		.loc 2 5871 9 is_stmt 1 view .LVU186
5871:DSP/Inc/arm_math.h ****       }
 513              		.loc 2 5871 17 is_stmt 0 view .LVU187
 514 01b4 1B1B     		subs	r3, r3, r4
 515              	.LVL83:
5871:DSP/Inc/arm_math.h ****       }
 516              		.loc 2 5871 17 view .LVU188
 517 01b6 F2E7     		b	.L17
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 117


 518              	.L47:
5871:DSP/Inc/arm_math.h ****       }
 519              		.loc 2 5871 17 view .LVU189
 520              	.LBE19:
 521              	.LBE18:
 158:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 159:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Working pointer for state buffer is updated */
 160:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     py = pState;
 161:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 162:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* blockSize samples are read from the state buffer */
 163:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 164:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                          (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 165:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                          blockSize);
 166:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 167:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Working pointer for the scratch buffer of state values */
 168:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     px = pb;
 169:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 170:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Working pointer for scratch buffer of output values */
 171:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     pOut = pDst;
 172:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 173:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Loop over the blockSize. Unroll by a factor of 4.
 174:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****      * Compute 4 MACS at a time. */
 175:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt = blockSize >> 2;
 522              		.loc 1 175 12 view .LVU190
 523 01b8 6146     		mov	r1, ip
 524 01ba DDF818C0 		ldr	ip, [sp, #24]
 525              	.LVL84:
 171:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 526              		.loc 1 171 10 view .LVU191
 527 01be 7346     		mov	r3, lr
 528              	.LVL85:
 168:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 529              		.loc 1 168 8 view .LVU192
 530 01c0 4A46     		mov	r2, r9
 531              	.LVL86:
 168:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 532              		.loc 1 168 8 view .LVU193
 533 01c2 0397     		str	r7, [sp, #12]
 534 01c4 0495     		str	r5, [sp, #16]
 535 01c6 6546     		mov	r5, ip
 536 01c8 0594     		str	r4, [sp, #20]
 537 01ca 35E0     		b	.L19
 538              	.LVL87:
 539              	.L20:
 176:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 177:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     while (blkCnt > 0U)
 178:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 179:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out = *pOut;
 540              		.loc 1 179 7 is_stmt 1 view .LVU194
 180:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out += ((q63_t) * px++ * coeff) >> 32;
 541              		.loc 1 180 7 view .LVU195
 542              		.loc 1 180 23 is_stmt 0 view .LVU196
 543 01cc 1068     		ldr	r0, [r2]
 544              		.loc 1 180 15 view .LVU197
 545 01ce 4FEAE078 		asr	r8, r0, #31
 546              		.loc 1 180 30 view .LVU198
 547 01d2 CC17     		asrs	r4, r1, #31
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 118


 548 01d4 00FB04F7 		mul	r7, r0, r4
 549 01d8 01FB0877 		mla	r7, r1, r8, r7
 550 01dc A0FB01C8 		umull	ip, r8, r0, r1
 551 01e0 4744     		add	r7, r7, r8
 552              		.loc 1 180 11 view .LVU199
 553 01e2 1868     		ldr	r0, [r3]
 554 01e4 C019     		adds	r0, r0, r7
 555              	.LVL88:
 181:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 556              		.loc 1 181 7 is_stmt 1 view .LVU200
 557              		.loc 1 181 15 is_stmt 0 view .LVU201
 558 01e6 1860     		str	r0, [r3]
 559              	.LVL89:
 182:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 183:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out = *pOut;
 560              		.loc 1 183 7 is_stmt 1 view .LVU202
 184:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out += ((q63_t) * px++ * coeff) >> 32;
 561              		.loc 1 184 7 view .LVU203
 562              		.loc 1 184 23 is_stmt 0 view .LVU204
 563 01e8 5068     		ldr	r0, [r2, #4]
 564              		.loc 1 184 15 view .LVU205
 565 01ea C717     		asrs	r7, r0, #31
 566              		.loc 1 184 30 view .LVU206
 567 01ec 01FB07F7 		mul	r7, r1, r7
 568 01f0 00FB0477 		mla	r7, r0, r4, r7
 569 01f4 A1FB008C 		umull	r8, ip, r1, r0
 570 01f8 6744     		add	r7, r7, ip
 571              		.loc 1 184 11 view .LVU207
 572 01fa 5868     		ldr	r0, [r3, #4]
 573 01fc C019     		adds	r0, r0, r7
 574              	.LVL90:
 185:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 575              		.loc 1 185 7 is_stmt 1 view .LVU208
 576              		.loc 1 185 15 is_stmt 0 view .LVU209
 577 01fe 5860     		str	r0, [r3, #4]
 578              	.LVL91:
 186:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 187:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out = *pOut;
 579              		.loc 1 187 7 is_stmt 1 view .LVU210
 188:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out += ((q63_t) * px++ * coeff) >> 32;
 580              		.loc 1 188 7 view .LVU211
 581              		.loc 1 188 23 is_stmt 0 view .LVU212
 582 0200 9068     		ldr	r0, [r2, #8]
 583              		.loc 1 188 15 view .LVU213
 584 0202 C717     		asrs	r7, r0, #31
 585              		.loc 1 188 30 view .LVU214
 586 0204 01FB07F7 		mul	r7, r1, r7
 587 0208 00FB0477 		mla	r7, r0, r4, r7
 588 020c A1FB008C 		umull	r8, ip, r1, r0
 589 0210 6744     		add	r7, r7, ip
 590              		.loc 1 188 11 view .LVU215
 591 0212 9868     		ldr	r0, [r3, #8]
 592 0214 C019     		adds	r0, r0, r7
 593              	.LVL92:
 189:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 594              		.loc 1 189 7 is_stmt 1 view .LVU216
 595              		.loc 1 189 15 is_stmt 0 view .LVU217
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 119


 596 0216 9860     		str	r0, [r3, #8]
 597              	.LVL93:
 190:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 191:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out = *pOut;
 598              		.loc 1 191 7 is_stmt 1 view .LVU218
 599              		.loc 1 191 13 is_stmt 0 view .LVU219
 600 0218 D868     		ldr	r0, [r3, #12]
 601              	.LVL94:
 192:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out += ((q63_t) * px++ * coeff) >> 32;
 602              		.loc 1 192 7 is_stmt 1 view .LVU220
 603              		.loc 1 192 23 is_stmt 0 view .LVU221
 604 021a D768     		ldr	r7, [r2, #12]
 605              		.loc 1 192 15 view .LVU222
 606 021c 4FEAE77C 		asr	ip, r7, #31
 607              		.loc 1 192 30 view .LVU223
 608 0220 01FB0CFC 		mul	ip, r1, ip
 609 0224 07FB04C4 		mla	r4, r7, r4, ip
 610 0228 A1FB077C 		umull	r7, ip, r1, r7
 611 022c 6444     		add	r4, r4, ip
 612              		.loc 1 192 11 view .LVU224
 613 022e 0019     		adds	r0, r0, r4
 614              	.LVL95:
 193:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 615              		.loc 1 193 7 is_stmt 1 view .LVU225
 616              		.loc 1 193 15 is_stmt 0 view .LVU226
 617 0230 D860     		str	r0, [r3, #12]
 618              	.LVL96:
 194:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 195:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       /* Decrement the loop counter */
 196:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       blkCnt--;
 619              		.loc 1 196 7 is_stmt 1 view .LVU227
 620              		.loc 1 196 13 is_stmt 0 view .LVU228
 621 0232 013D     		subs	r5, r5, #1
 622              	.LVL97:
 193:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 623              		.loc 1 193 12 view .LVU229
 624 0234 1033     		adds	r3, r3, #16
 625              	.LVL98:
 192:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 626              		.loc 1 192 27 view .LVU230
 627 0236 1032     		adds	r2, r2, #16
 628              	.LVL99:
 629              	.L19:
 177:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 630              		.loc 1 177 19 is_stmt 1 view .LVU231
 631 0238 002D     		cmp	r5, #0
 632 023a C7D1     		bne	.L20
 197:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 198:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 199:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* If the blockSize is not a multiple of 4,
 200:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****      * compute the remaining samples */
 201:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt = blockSize % 0x4U;
 633              		.loc 1 201 12 is_stmt 0 view .LVU232
 634 023c 049D     		ldr	r5, [sp, #16]
 635              	.LVL100:
 636              		.loc 1 201 12 view .LVU233
 637 023e 059C     		ldr	r4, [sp, #20]
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 120


 638 0240 0798     		ldr	r0, [sp, #28]
 639 0242 A846     		mov	r8, r5
 640 0244 10E0     		b	.L21
 641              	.LVL101:
 642              	.L22:
 202:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 203:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     while (blkCnt > 0U)
 204:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 205:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       /* Perform Multiply-Accumulate */
 206:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out = *pOut;
 643              		.loc 1 206 7 is_stmt 1 view .LVU234
 207:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out += ((q63_t) * px++ * coeff) >> 32;
 644              		.loc 1 207 7 view .LVU235
 645              		.loc 1 207 23 is_stmt 0 view .LVU236
 646 0246 52F8047B 		ldr	r7, [r2], #4
 647              	.LVL102:
 648              		.loc 1 207 15 view .LVU237
 649 024a 4FEAE77C 		asr	ip, r7, #31
 650              		.loc 1 207 30 view .LVU238
 651 024e CD17     		asrs	r5, r1, #31
 652 0250 01FB0CFC 		mul	ip, r1, ip
 653 0254 07FB05C5 		mla	r5, r7, r5, ip
 654 0258 A1FB077C 		umull	r7, ip, r1, r7
 655 025c 6544     		add	r5, r5, ip
 656              		.loc 1 207 11 view .LVU239
 657 025e 1F68     		ldr	r7, [r3]
 658 0260 7D19     		adds	r5, r7, r5
 659              	.LVL103:
 208:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 660              		.loc 1 208 7 is_stmt 1 view .LVU240
 661              		.loc 1 208 15 is_stmt 0 view .LVU241
 662 0262 43F8045B 		str	r5, [r3], #4
 663              	.LVL104:
 209:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 210:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       /* Decrement the loop counter */
 211:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       blkCnt--;
 664              		.loc 1 211 7 is_stmt 1 view .LVU242
 665              		.loc 1 211 13 is_stmt 0 view .LVU243
 666 0266 0138     		subs	r0, r0, #1
 667              	.LVL105:
 668              	.L21:
 203:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 669              		.loc 1 203 19 is_stmt 1 view .LVU244
 670 0268 0028     		cmp	r0, #0
 671 026a ECD1     		bne	.L22
 212:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 213:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 214:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Load the coefficient value and
 215:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****      * increment the coefficient buffer for the next set of state values */
 216:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     coeff = *pCoeffs++;
 672              		.loc 1 216 21 is_stmt 0 view .LVU245
 673 026c 039F     		ldr	r7, [sp, #12]
 674 026e 4546     		mov	r5, r8
 675              		.loc 1 216 5 is_stmt 1 view .LVU246
 676              		.loc 1 216 21 is_stmt 0 view .LVU247
 677 0270 019A     		ldr	r2, [sp, #4]
 678              	.LVL106:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 121


 679              		.loc 1 216 11 view .LVU248
 680 0272 52F8041B 		ldr	r1, [r2], #4
 681              	.LVL107:
 217:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 218:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 219:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
 682              		.loc 1 219 5 is_stmt 1 view .LVU249
 683              		.loc 1 219 29 is_stmt 0 view .LVU250
 684 0276 BAF80230 		ldrh	r3, [r10, #2]
 685              	.LVL108:
 686              		.loc 1 219 42 view .LVU251
 687 027a A3EB0B03 		sub	r3, r3, fp
 688              		.loc 1 219 67 view .LVU252
 689 027e DDF808C0 		ldr	ip, [sp, #8]
 690              	.LVL109:
 691              		.loc 1 219 57 view .LVU253
 692 0282 5CF8048B 		ldr	r8, [ip], #4
 693              	.LVL110:
 220:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 221:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Wraparound of readIndex */
 222:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     if (readIndex < 0)
 694              		.loc 1 222 5 is_stmt 1 view .LVU254
 695              		.loc 1 222 8 is_stmt 0 view .LVU255
 696 0286 B3EB0803 		subs	r3, r3, r8
 697              	.LVL111:
 698              		.loc 1 222 8 view .LVU256
 699 028a 08D4     		bmi	.L49
 700              	.LVL112:
 701              	.L23:
 223:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       readIndex += (int32_t) delaySize;
 225:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 226:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 227:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the tap loop counter */
 228:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     tapCnt--;
 702              		.loc 1 228 5 is_stmt 1 view .LVU257
 703              		.loc 1 228 11 is_stmt 0 view .LVU258
 704 028c 013F     		subs	r7, r7, #1
 705              	.LVL113:
 219:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 706              		.loc 1 219 67 view .LVU259
 707 028e CDF808C0 		str	ip, [sp, #8]
 216:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 708              		.loc 1 216 21 view .LVU260
 709 0292 0192     		str	r2, [sp, #4]
 710              	.LVL114:
 711              	.L15:
 157:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 712              		.loc 1 157 17 is_stmt 1 view .LVU261
 713 0294 2FB1     		cbz	r7, .L50
 714              	.LBB21:
 715              	.LBB20:
5851:DSP/Inc/arm_math.h **** 
 716              		.loc 2 5851 7 is_stmt 0 view .LVU262
 717 0296 5846     		mov	r0, fp
 718              	.LBE20:
 719              	.LBE21:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 122


 720 0298 4A46     		mov	r2, r9
 721 029a 8C46     		mov	ip, r1
 722 029c 80E7     		b	.L24
 723              	.LVL115:
 724              	.L49:
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 725              		.loc 1 224 7 is_stmt 1 view .LVU263
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 726              		.loc 1 224 17 is_stmt 0 view .LVU264
 727 029e 2344     		add	r3, r3, r4
 728              	.LVL116:
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 729              		.loc 1 224 17 view .LVU265
 730 02a0 F4E7     		b	.L23
 731              	.LVL117:
 732              	.L50:
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 733              		.loc 1 224 17 view .LVU266
 734 02a2 1846     		mov	r0, r3
 735 02a4 7246     		mov	r2, lr
 736 02a6 DDF81CE0 		ldr	lr, [sp, #28]
 737              	.LVL118:
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 738              		.loc 1 224 17 view .LVU267
 739 02aa 4B46     		mov	r3, r9
 740              	.LVL119:
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 741              		.loc 1 224 17 view .LVU268
 742 02ac CC46     		mov	ip, r9
 743 02ae 9046     		mov	r8, r2
 744 02b0 5F46     		mov	r7, fp
 745              	.LVL120:
 224:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 746              		.loc 1 224 17 view .LVU269
 747 02b2 02E0     		b	.L25
 748              	.LVL121:
 749              	.L52:
 750              	.LBB22:
 751              	.LBB23:
5863:DSP/Inc/arm_math.h ****       }
 752              		.loc 2 5863 13 view .LVU270
 753 02b4 9C46     		mov	ip, r3
 754              	.LVL122:
5863:DSP/Inc/arm_math.h ****       }
 755              		.loc 2 5863 13 view .LVU271
 756 02b6 07E0     		b	.L26
 757              	.LVL123:
 758              	.L27:
5875:DSP/Inc/arm_math.h ****     }
 759              		.loc 2 5875 7 is_stmt 1 view .LVU272
5875:DSP/Inc/arm_math.h ****     }
 760              		.loc 2 5875 8 is_stmt 0 view .LVU273
 761 02b8 013F     		subs	r7, r7, #1
 762              	.LVL124:
 763              	.L25:
5853:DSP/Inc/arm_math.h ****     {
 764              		.loc 2 5853 14 is_stmt 1 view .LVU274
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 123


 765 02ba 57B1     		cbz	r7, .L51
5856:DSP/Inc/arm_math.h **** 
 766              		.loc 2 5856 7 view .LVU275
5856:DSP/Inc/arm_math.h **** 
 767              		.loc 2 5856 12 is_stmt 0 view .LVU276
 768 02bc 55F82020 		ldr	r2, [r5, r0, lsl #2]
 769 02c0 4CF8042B 		str	r2, [ip], #4
 770              	.LVL125:
5859:DSP/Inc/arm_math.h **** 
 771              		.loc 2 5859 7 is_stmt 1 view .LVU277
5861:DSP/Inc/arm_math.h ****       {
 772              		.loc 2 5861 7 view .LVU278
5861:DSP/Inc/arm_math.h ****       {
 773              		.loc 2 5861 10 is_stmt 0 view .LVU279
 774 02c4 6645     		cmp	r6, ip
 775 02c6 F5D0     		beq	.L52
 776              	.LVL126:
 777              	.L26:
5867:DSP/Inc/arm_math.h **** 
 778              		.loc 2 5867 7 is_stmt 1 view .LVU280
5867:DSP/Inc/arm_math.h **** 
 779              		.loc 2 5867 15 is_stmt 0 view .LVU281
 780 02c8 0130     		adds	r0, r0, #1
 781              	.LVL127:
5869:DSP/Inc/arm_math.h ****       {
 782              		.loc 2 5869 7 is_stmt 1 view .LVU282
5869:DSP/Inc/arm_math.h ****       {
 783              		.loc 2 5869 10 is_stmt 0 view .LVU283
 784 02ca 8442     		cmp	r4, r0
 785 02cc F4DC     		bgt	.L27
5871:DSP/Inc/arm_math.h ****       }
 786              		.loc 2 5871 9 is_stmt 1 view .LVU284
5871:DSP/Inc/arm_math.h ****       }
 787              		.loc 2 5871 17 is_stmt 0 view .LVU285
 788 02ce 001B     		subs	r0, r0, r4
 789              	.LVL128:
5871:DSP/Inc/arm_math.h ****       }
 790              		.loc 2 5871 17 view .LVU286
 791 02d0 F2E7     		b	.L27
 792              	.L51:
5871:DSP/Inc/arm_math.h ****       }
 793              		.loc 2 5871 17 view .LVU287
 794              	.LBE23:
 795              	.LBE22:
 229:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 230:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 231:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Compute last tap without the final read of pTapDelay */
 232:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 233:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Working pointer for state buffer is updated */
 234:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	py = pState;
 235:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 236:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* blockSize samples are read from the state buffer */
 237:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 238:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 239:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 											 blockSize);
 240:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 241:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Working pointer for the scratch buffer of state values */
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 124


 242:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	px = pb;
 243:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 244:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Working pointer for scratch buffer of output values */
 245:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	pOut = pDst;
 246:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 247:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Loop over the blockSize. Unroll by a factor of 4.
 248:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	 * Compute 4 MACS at a time. */
 249:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	blkCnt = blockSize >> 2;
 796              		.loc 1 249 9 view .LVU288
 797 02d2 4246     		mov	r2, r8
 798 02d4 069E     		ldr	r6, [sp, #24]
 799              	.LVL129:
 245:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 800              		.loc 1 245 7 view .LVU289
 801 02d6 4046     		mov	r0, r8
 802              	.LVL130:
 245:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 803              		.loc 1 245 7 view .LVU290
 804 02d8 34E0     		b	.L29
 805              	.LVL131:
 806              	.L30:
 250:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 251:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	while (blkCnt > 0U)
 252:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 253:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out = *pOut;
 807              		.loc 1 253 3 is_stmt 1 view .LVU291
 254:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out += ((q63_t) * px++ * coeff) >> 32;
 808              		.loc 1 254 3 view .LVU292
 809              		.loc 1 254 19 is_stmt 0 view .LVU293
 810 02da 1C68     		ldr	r4, [r3]
 811              		.loc 1 254 11 view .LVU294
 812 02dc 4FEAE478 		asr	r8, r4, #31
 813              		.loc 1 254 26 view .LVU295
 814 02e0 CF17     		asrs	r7, r1, #31
 815 02e2 04FB07F5 		mul	r5, r4, r7
 816 02e6 01FB0855 		mla	r5, r1, r8, r5
 817 02ea A4FB01C8 		umull	ip, r8, r4, r1
 818 02ee 4544     		add	r5, r5, r8
 819              		.loc 1 254 7 view .LVU296
 820 02f0 0468     		ldr	r4, [r0]
 821 02f2 6419     		adds	r4, r4, r5
 822              	.LVL132:
 255:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 823              		.loc 1 255 3 is_stmt 1 view .LVU297
 824              		.loc 1 255 11 is_stmt 0 view .LVU298
 825 02f4 0460     		str	r4, [r0]
 826              	.LVL133:
 256:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 257:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out = *pOut;
 827              		.loc 1 257 3 is_stmt 1 view .LVU299
 258:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out += ((q63_t) * px++ * coeff) >> 32;
 828              		.loc 1 258 3 view .LVU300
 829              		.loc 1 258 19 is_stmt 0 view .LVU301
 830 02f6 5C68     		ldr	r4, [r3, #4]
 831              		.loc 1 258 11 view .LVU302
 832 02f8 E517     		asrs	r5, r4, #31
 833              		.loc 1 258 26 view .LVU303
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 125


 834 02fa 01FB05F5 		mul	r5, r1, r5
 835 02fe 04FB0755 		mla	r5, r4, r7, r5
 836 0302 A1FB04C8 		umull	ip, r8, r1, r4
 837 0306 4544     		add	r5, r5, r8
 838              		.loc 1 258 7 view .LVU304
 839 0308 4468     		ldr	r4, [r0, #4]
 840 030a 6419     		adds	r4, r4, r5
 841              	.LVL134:
 259:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 842              		.loc 1 259 3 is_stmt 1 view .LVU305
 843              		.loc 1 259 11 is_stmt 0 view .LVU306
 844 030c 4460     		str	r4, [r0, #4]
 845              	.LVL135:
 260:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 261:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out = *pOut;
 846              		.loc 1 261 3 is_stmt 1 view .LVU307
 262:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out += ((q63_t) * px++ * coeff) >> 32;
 847              		.loc 1 262 3 view .LVU308
 848              		.loc 1 262 19 is_stmt 0 view .LVU309
 849 030e 9D68     		ldr	r5, [r3, #8]
 850              		.loc 1 262 11 view .LVU310
 851 0310 EC17     		asrs	r4, r5, #31
 852              		.loc 1 262 26 view .LVU311
 853 0312 01FB04F4 		mul	r4, r1, r4
 854 0316 05FB0744 		mla	r4, r5, r7, r4
 855 031a A1FB05C8 		umull	ip, r8, r1, r5
 856 031e 4444     		add	r4, r4, r8
 857              		.loc 1 262 7 view .LVU312
 858 0320 8568     		ldr	r5, [r0, #8]
 859 0322 2D19     		adds	r5, r5, r4
 860              	.LVL136:
 263:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 861              		.loc 1 263 3 is_stmt 1 view .LVU313
 862              		.loc 1 263 11 is_stmt 0 view .LVU314
 863 0324 8560     		str	r5, [r0, #8]
 864              	.LVL137:
 264:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 265:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out = *pOut;
 865              		.loc 1 265 3 is_stmt 1 view .LVU315
 266:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out += ((q63_t) * px++ * coeff) >> 32;
 866              		.loc 1 266 3 view .LVU316
 867              		.loc 1 266 19 is_stmt 0 view .LVU317
 868 0326 DD68     		ldr	r5, [r3, #12]
 869              		.loc 1 266 11 view .LVU318
 870 0328 EC17     		asrs	r4, r5, #31
 871              		.loc 1 266 26 view .LVU319
 872 032a 01FB04F4 		mul	r4, r1, r4
 873 032e 05FB0744 		mla	r4, r5, r7, r4
 874 0332 A1FB05C7 		umull	ip, r7, r1, r5
 875 0336 3C44     		add	r4, r4, r7
 876              		.loc 1 266 7 view .LVU320
 877 0338 C568     		ldr	r5, [r0, #12]
 878 033a 2D19     		adds	r5, r5, r4
 879              	.LVL138:
 267:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 880              		.loc 1 267 3 is_stmt 1 view .LVU321
 881              		.loc 1 267 11 is_stmt 0 view .LVU322
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 126


 882 033c C560     		str	r5, [r0, #12]
 883              	.LVL139:
 268:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 269:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		/* Decrement the loop counter */
 270:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		blkCnt--;
 884              		.loc 1 270 3 is_stmt 1 view .LVU323
 885              		.loc 1 270 9 is_stmt 0 view .LVU324
 886 033e 013E     		subs	r6, r6, #1
 887              	.LVL140:
 267:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 888              		.loc 1 267 8 view .LVU325
 889 0340 1030     		adds	r0, r0, #16
 890              	.LVL141:
 266:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 891              		.loc 1 266 23 view .LVU326
 892 0342 1033     		adds	r3, r3, #16
 893              	.LVL142:
 894              	.L29:
 251:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 895              		.loc 1 251 16 is_stmt 1 view .LVU327
 896 0344 002E     		cmp	r6, #0
 897 0346 C8D1     		bne	.L30
 271:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	}
 272:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 273:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* If the blockSize is not a multiple of 4,
 274:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	 * compute the remaining samples */
 275:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	blkCnt = blockSize % 0x4U;
 898              		.loc 1 275 9 is_stmt 0 view .LVU328
 899 0348 7746     		mov	r7, lr
 900 034a 10E0     		b	.L31
 901              	.LVL143:
 902              	.L32:
 276:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 277:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	while (blkCnt > 0U)
 278:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 279:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		/* Perform Multiply-Accumulate */
 280:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out = *pOut;
 903              		.loc 1 280 3 is_stmt 1 view .LVU329
 904              		.loc 1 280 9 is_stmt 0 view .LVU330
 905 034c 0568     		ldr	r5, [r0]
 906              	.LVL144:
 281:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out += ((q63_t) * px++ * coeff) >> 32;
 907              		.loc 1 281 3 is_stmt 1 view .LVU331
 908              		.loc 1 281 19 is_stmt 0 view .LVU332
 909 034e 53F8046B 		ldr	r6, [r3], #4
 910              	.LVL145:
 911              		.loc 1 281 11 view .LVU333
 912 0352 F417     		asrs	r4, r6, #31
 913              		.loc 1 281 26 view .LVU334
 914 0354 4FEAE17C 		asr	ip, r1, #31
 915 0358 01FB04F4 		mul	r4, r1, r4
 916 035c 06FB0C44 		mla	r4, r6, ip, r4
 917 0360 A1FB066C 		umull	r6, ip, r1, r6
 918 0364 6444     		add	r4, r4, ip
 919              		.loc 1 281 7 view .LVU335
 920 0366 2D19     		adds	r5, r5, r4
 921              	.LVL146:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 127


 282:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 922              		.loc 1 282 3 is_stmt 1 view .LVU336
 923              		.loc 1 282 11 is_stmt 0 view .LVU337
 924 0368 40F8045B 		str	r5, [r0], #4
 925              	.LVL147:
 283:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 284:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		/* Decrement the loop counter */
 285:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		blkCnt--;
 926              		.loc 1 285 3 is_stmt 1 view .LVU338
 927              		.loc 1 285 9 is_stmt 0 view .LVU339
 928 036c 013F     		subs	r7, r7, #1
 929              	.LVL148:
 930              	.L31:
 277:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 931              		.loc 1 277 16 is_stmt 1 view .LVU340
 932 036e 002F     		cmp	r7, #0
 933 0370 ECD1     		bne	.L32
 277:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 934              		.loc 1 277 16 is_stmt 0 view .LVU341
 935 0372 0699     		ldr	r1, [sp, #24]
 936              	.LVL149:
 277:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 937              		.loc 1 277 16 view .LVU342
 938 0374 0DE0     		b	.L33
 939              	.LVL150:
 940              	.L34:
 286:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	}
 287:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 288:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Working output pointer is updated */
 289:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   pOut = pDst;
 290:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 291:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Output is converted into 1.31 format. */
 292:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Loop over the blockSize. Unroll by a factor of 4.
 293:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****    * process 4 output samples at a time. */
 294:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   blkCnt = blockSize >> 2;
 295:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 296:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (blkCnt > 0U)
 297:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 298:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     in = *pOut << 1;
 941              		.loc 1 298 5 is_stmt 1 view .LVU343
 942              		.loc 1 298 10 is_stmt 0 view .LVU344
 943 0376 1368     		ldr	r3, [r2]
 944              		.loc 1 298 8 view .LVU345
 945 0378 5B00     		lsls	r3, r3, #1
 946              	.LVL151:
 299:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 947              		.loc 1 299 5 is_stmt 1 view .LVU346
 948              		.loc 1 299 13 is_stmt 0 view .LVU347
 949 037a 1360     		str	r3, [r2]
 300:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     in = *pOut << 1;
 950              		.loc 1 300 5 is_stmt 1 view .LVU348
 951              		.loc 1 300 10 is_stmt 0 view .LVU349
 952 037c 5368     		ldr	r3, [r2, #4]
 953              	.LVL152:
 954              		.loc 1 300 8 view .LVU350
 955 037e 5B00     		lsls	r3, r3, #1
 956              	.LVL153:
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 128


 301:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 957              		.loc 1 301 5 is_stmt 1 view .LVU351
 958              		.loc 1 301 13 is_stmt 0 view .LVU352
 959 0380 5360     		str	r3, [r2, #4]
 302:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     in = *pOut << 1;
 960              		.loc 1 302 5 is_stmt 1 view .LVU353
 961              		.loc 1 302 10 is_stmt 0 view .LVU354
 962 0382 9368     		ldr	r3, [r2, #8]
 963              	.LVL154:
 964              		.loc 1 302 8 view .LVU355
 965 0384 5B00     		lsls	r3, r3, #1
 966              	.LVL155:
 303:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 967              		.loc 1 303 5 is_stmt 1 view .LVU356
 968              		.loc 1 303 13 is_stmt 0 view .LVU357
 969 0386 9360     		str	r3, [r2, #8]
 304:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     in = *pOut << 1;
 970              		.loc 1 304 5 is_stmt 1 view .LVU358
 971              		.loc 1 304 10 is_stmt 0 view .LVU359
 972 0388 D368     		ldr	r3, [r2, #12]
 973              	.LVL156:
 974              		.loc 1 304 8 view .LVU360
 975 038a 5B00     		lsls	r3, r3, #1
 976              	.LVL157:
 305:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 977              		.loc 1 305 5 is_stmt 1 view .LVU361
 978              		.loc 1 305 13 is_stmt 0 view .LVU362
 979 038c D360     		str	r3, [r2, #12]
 306:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 307:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the loop counter */
 308:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt--;
 980              		.loc 1 308 5 is_stmt 1 view .LVU363
 981              		.loc 1 308 11 is_stmt 0 view .LVU364
 982 038e 0139     		subs	r1, r1, #1
 983              	.LVL158:
 305:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 984              		.loc 1 305 10 view .LVU365
 985 0390 1032     		adds	r2, r2, #16
 986              	.LVL159:
 987              	.L33:
 296:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 988              		.loc 1 296 17 is_stmt 1 view .LVU366
 989 0392 0029     		cmp	r1, #0
 990 0394 EFD1     		bne	.L34
 991 0396 7146     		mov	r1, lr
 992              	.LVL160:
 296:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 993              		.loc 1 296 17 is_stmt 0 view .LVU367
 994 0398 04E0     		b	.L35
 995              	.LVL161:
 996              	.L36:
 309:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 310:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 311:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* If the blockSize is not a multiple of 4,
 312:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****    * process the remaining output samples */
 313:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   blkCnt = blockSize % 0x4U;
 314:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 129


 315:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (blkCnt > 0U)
 316:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 317:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     in = *pOut << 1;
 997              		.loc 1 317 5 is_stmt 1 view .LVU368
 998              		.loc 1 317 10 is_stmt 0 view .LVU369
 999 039a 1368     		ldr	r3, [r2]
 1000              		.loc 1 317 8 view .LVU370
 1001 039c 5B00     		lsls	r3, r3, #1
 1002              	.LVL162:
 318:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 1003              		.loc 1 318 5 is_stmt 1 view .LVU371
 1004              		.loc 1 318 13 is_stmt 0 view .LVU372
 1005 039e 42F8043B 		str	r3, [r2], #4
 1006              	.LVL163:
 319:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 320:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the loop counter */
 321:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt--;
 1007              		.loc 1 321 5 is_stmt 1 view .LVU373
 1008              		.loc 1 321 11 is_stmt 0 view .LVU374
 1009 03a2 0139     		subs	r1, r1, #1
 1010              	.LVL164:
 1011              	.L35:
 315:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 1012              		.loc 1 315 17 is_stmt 1 view .LVU375
 1013 03a4 0029     		cmp	r1, #0
 1014 03a6 F8D1     		bne	.L36
 322:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 323:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 324:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** #else
 325:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 326:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Run the below code for Cortex-M0 */
 327:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   blkCnt = blockSize;
 328:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 329:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (blkCnt > 0U)
 330:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 331:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Perform Multiplications and store in the destination buffer */
 332:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
 333:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 334:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the loop counter */
 335:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt--;
 336:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 337:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 338:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Load the coefficient value and
 339:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****    * increment the coefficient buffer for the next set of state values */
 340:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   coeff = *pCoeffs++;
 341:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 342:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Read Index, from where the state buffer should be read, is calculated. */
 343:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
 344:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 345:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Wraparound of readIndex */
 346:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   if (readIndex < 0)
 347:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 348:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     readIndex += (int32_t) delaySize;
 349:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 350:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 351:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Loop over the number of taps. */
 352:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   tapCnt = (uint32_t) numTaps - 2U;
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 130


 353:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 354:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (tapCnt > 0U)
 355:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 356:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Working pointer for state buffer is updated */
 357:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     py = pState;
 358:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 359:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* blockSize samples are read from the state buffer */
 360:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 361:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                          (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 362:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****                          blockSize);
 363:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 364:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Working pointer for the scratch buffer of state values */
 365:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     px = pb;
 366:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 367:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Working pointer for scratch buffer of output values */
 368:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     pOut = pDst;
 369:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 370:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt = blockSize;
 371:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 372:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     while (blkCnt > 0U)
 373:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 374:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       /* Perform Multiply-Accumulate */
 375:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out = *pOut;
 376:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       out += ((q63_t) * px++ * coeff) >> 32;
 377:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       *pOut++ = (q31_t) (out);
 378:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 379:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       /* Decrement the loop counter */
 380:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       blkCnt--;
 381:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 382:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 383:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Load the coefficient value and
 384:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****      * increment the coefficient buffer for the next set of state values */
 385:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     coeff = *pCoeffs++;
 386:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 387:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Read Index, from where the state buffer should be read, is calculated. */
 388:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
 389:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 390:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Wraparound of readIndex */
 391:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     if (readIndex < 0)
 392:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     {
 393:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****       readIndex += (int32_t) delaySize;
 394:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     }
 395:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 396:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the tap loop counter */
 397:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     tapCnt--;
 398:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 399:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 400:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Compute last tap without the final read of pTapDelay */
 401:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 402:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Working pointer for state buffer is updated */
 403:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	py = pState;
 404:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 405:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* blockSize samples are read from the state buffer */
 406:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
 407:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
 408:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 											 blockSize);
 409:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 131


 410:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Working pointer for the scratch buffer of state values */
 411:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	px = pb;
 412:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 413:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	/* Working pointer for scratch buffer of output values */
 414:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	pOut = pDst;
 415:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 416:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	blkCnt = blockSize;
 417:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 418:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	while (blkCnt > 0U)
 419:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	{
 420:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		/* Perform Multiply-Accumulate */
 421:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out = *pOut;
 422:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		out += ((q63_t) * px++ * coeff) >> 32;
 423:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		*pOut++ = (q31_t) (out);
 424:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 425:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		/* Decrement the loop counter */
 426:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 		blkCnt--;
 427:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 	}
 428:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 429:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Working output pointer is updated */
 430:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   pOut = pDst;
 431:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 432:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   /* Output is converted into 1.31 format. */
 433:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   blkCnt = blockSize;
 434:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 435:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   while (blkCnt > 0U)
 436:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   {
 437:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     in = *pOut << 1;
 438:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     *pOut++ = in;
 439:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 440:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     /* Decrement the loop counter */
 441:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****     blkCnt--;
 442:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c ****   }
 443:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 444:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** #endif /*   #if defined (ARM_MATH_DSP) */
 445:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** 
 446:DSP/Source/FilteringFunctions/arm_fir_sparse_q31.c **** }
 1015              		.loc 1 446 1 is_stmt 0 view .LVU376
 1016 03a8 09B0     		add	sp, sp, #36
 1017              	.LCFI2:
 1018              		.cfi_def_cfa_offset 36
 1019              		@ sp needed
 1020 03aa BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1021              		.loc 1 446 1 view .LVU377
 1022              		.cfi_endproc
 1023              	.LFE139:
 1025              		.text
 1026              	.Letext0:
 1027              		.file 3 "/Users/luban/.local/xPacks/arm-none-eabi-gcc/xpack-arm-none-eabi-gcc-13.2.1-1.1/arm-none-
 1028              		.file 4 "/Users/luban/.local/xPacks/arm-none-eabi-gcc/xpack-arm-none-eabi-gcc-13.2.1-1.1/arm-none-
ARM GAS  /var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s 			page 132


DEFINED SYMBOLS
                            *ABS*:00000000 arm_fir_sparse_q31.c
/var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s:21     .text.arm_fir_sparse_q31:00000000 $t
/var/folders/ck/g3dcd5x55xs4107jgdl0snvr0000gn/T//ccBIAOqu.s:27     .text.arm_fir_sparse_q31:00000000 arm_fir_sparse_q31

NO UNDEFINED SYMBOLS
